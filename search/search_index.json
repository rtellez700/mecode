{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mecode","text":"<p>`  </p>"},{"location":"#overview","title":"Overview","text":"<p>Mecode is designed to simplify GCode generation. It is not a slicer, thus it can not convert CAD models to 3D printer ready code. It simply provides a convenient, human-readable layer just above GCode. If you often find yourself manually writing your own GCode, then mecode is for you.</p>"},{"location":"#why-mecode","title":"Why <code>mecode</code>?","text":"<ul> <li> <p> Set up in 5 minutes</p> <p>Install <code>mecode</code> with <code>pip</code> and get up and running in minutes</p> <p> Installation</p> </li> <li> <p> Matrix Transformation</p> <p><code>mecode</code> is capable of transforming toolpaths (e.g., rotation matrices).</p> <p> Transforms</p> </li> <li> <p> Multimaterial Support</p> <p>Multimaterial support enabled on multiaxis printers via <code>rename_axis</code></p> <p> Multimaterial example</p> </li> <li> <p> Visualization</p> <p>Gcode toolpath visualization enabled by matplotlib with color coding support for complex prints.</p> <p> Visualizations</p> </li> <li> <p> Serial Communication</p> <p>With the option <code>direct_write=True</code>, a serial connection to a Printer can be established via USB serial at a virtual COM port (e.g., RS-232).</p> <p> Direct connection</p> </li> <li> <p> Open Source, MIT</p> <p><code>mecode</code> is licensed under MIT and available on GitHub or the License tab</p> <p> License</p> </li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This software was developed by the Lewis Lab at Harvard University. It is based on Jack Minardi's<sup>1</sup> codebase (https://github.com/jminardi/mecode) which is no longer maintained.</p> <ol> <li> <p>jack@minardi.org \u21a9</p> </li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>Warning</p> <p>This document is a work in progress.</p> <p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at github.com/rtellez700/mecode/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p><code>mecode</code> could always use more documentation, whether as part of the official <code>mecode</code> docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at github.com/rtellez700/mecode/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>mecode</code> for local development.</p> <ol> <li>Fork the <code>mecode</code> repo on GitHub.</li> <li> <p>Clone your fork locally:: <pre><code>    git clone git@github.com:your_name_here/mecode.git\n</code></pre></p> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: <pre><code>    mkvirtualenv mecocde\n    cd mecocde/\n    python setup.py develop\n</code></pre></p> </li> <li> <p>Create a branch for local development: <pre><code>    git checkout -b name-of-your-bugfix-or-feature\n</code></pre></p> </li> </ol> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: <pre><code>    $ flake8 mecode tests\n    $ python setup.py test\n    $ tox\n</code></pre></li> </ol> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> <ol> <li> <p>Commit your changes and push your branch to GitHub: <pre><code>    $ git add .\n    $ git commit -m \"Your detailed description of your changes.\"\n    $ git push origin name-of-your-bugfix-or-feature\n</code></pre></p> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.3, 3.4, 3.5 and for PyPy. Check    https://travis-ci.org/rtellez700/mecode/pull_requests    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#download-an-ide","title":"Download an IDE","text":"<p>We recommend using Visual Studio Code</p>"},{"location":"install/#confirm-python-is-installed","title":"Confirm python is installed","text":"<p>In the command line or termainal run <pre><code>python --version\n</code></pre> This should output the current version of python if installed. E.g.,  <code>Python 3.10.9</code> To download python visit python.org/downloads.</p>"},{"location":"install/#confirm-git-is-installed","title":"Confirm git is installed","text":"<p>Most Mac or linux systems come with git pre-installed. To confirm if git is installed run the following in the command line on Windows or terminal on Mac: <pre><code>git --version\n</code></pre> This should output the current version of git if installed. E.g., <code>git version 2.39.2</code> To download git visit git-scm.com/downloads.</p>"},{"location":"install/#configure-virtual-environment","title":"Configure virtual environment","text":"<p>Although no virtual environment is required to install <code>mecode</code>, it is highly recommended to avoid dependency issues when working with multiple python packages.</p> CondaMamba <p>Install latest version of miniconda.</p> <p>Note</p> <p>If prompted to add conda to path, the answer is almost always yes. If you're not sure, check yes to avoid <code>conda not found</code> issues down the road.</p> <p>Create a new environment for working with <code>mecode</code>. E.g., to create a virtual environment <code>3dp</code></p> <pre><code>    conda create -n 3dp\n</code></pre> <p>Once created, activate the virtual environment</p> <p><pre><code>    conda activate 3dp\n</code></pre> Using conda install pip and git  <pre><code>    conda install pip git\n</code></pre></p> <p>Install latest version of Mamba.</p> <p>Create a new environment for working with <code>mecode</code>. E.g., to create a virtual environment <code>3dp</code></p> <pre><code>    mamba create -n 3dp\n</code></pre> <p>Once created, activate the virtual environment</p> <p><pre><code>    mamba activate 3dp\n</code></pre> Using mamba install pip and git  <pre><code>    mamba install pip git\n</code></pre></p>"},{"location":"install/#installing-mecode","title":"Installing mecode","text":"GitHubPyPiConda-Forge <p><pre><code>    pip install git+https://github.com/rtellez700/mecode.git\n</code></pre> If you currently have an old version of mecode, use the following instead: <pre><code>    pip install git+https://github.com/rtellez700/mecode.git --upgrade --force-reinstall\n</code></pre> When a new version is available you can re-run the previous command.</p> <p>In-progress</p> <p>In-progress</p> <p>Open up Visual Studio Code to start you first mecode script. Run <code>code .</code> in the command line / terminal to open VS code for the current directory. Otherwise, open VS Code and choose the appropriate project folder. For more information on how to use VS Code please check out their documentation at https://code.visualstudio.com/learn</p>"},{"location":"learn/","title":"Under the hood","text":"<p>For every printing move, <code>mecode</code> stores all relevant printing conditions, coordinates, etc inside a <code>history</code> list of <code>print_move</code> dictionaries. The schema of this dictionary is the following:</p> <pre><code>{\n    'REL_MODE': bool,\n    'ACCEL' : float,\n    'DECEL' : float,\n    'PRINTING': {\n        'extruder_id': {\n            'printing': bool,\n            'value': float\n        }\n    },\n    'PRINT_SPEED': float,\n    'COORDS': Tuple[float, float, float],\n    'ORIGIN': Tuple[float, float, float],\n    'CURRENT_POSITION': {'X': float, 'Y': float, 'Z': float},\n    'COLOR': Tuple[float, float, float]\n}\n</code></pre> <p>The first entry in the list is given as the origin and with default acceleration, deceleration, and origin</p> <pre><code>history = [{\n    'REL_MODE': True,\n    'ACCEL' : 2500,\n    'DECEL' : 2500,\n    'PRINTING': {},\n    'PRINT_SPEED': 0,\n    'COORDS': (0,0,0),\n    'ORIGIN': (0,0,0),\n    'CURRENT_POSITION': {'X': 0, 'Y': 0, 'Z': 0},\n    'COLOR': None\n}]\n</code></pre> <p>Descriptions</p> Variable Description <code>REL_MODE</code> True if the current <code>print_move</code> is in relative coordinates <code>ACCEL</code> Printer acceleration in mm/s^2 <code>DECEL</code> Printer deceleration in mm/s^2 <code>PRINTING</code> <code>dict</code> that contains current printing/extrusion state <code>PRINTING[extruder_id]</code> Once an extrusion source is turned on, <code>mecode</code> automatically adds a printing state to <code>PRINTING</code> that can be accessed via <code>PRINTING['extruder_id']</code> <code>PRINTING[extruder_id]['printing]</code> Once <code>extruder_id</code> is created, you can check if this source is currently extruding via <code>PRINTING[extruder_id][printing]</code> <code>PRINTING[extruder_id]['printing]</code> Once <code>extruder_id</code> is created, you can check what extrusion rate is (in instrument units, e.g., psi for Nordson pressuder adapter) via <code>PRINTING[extruder_id][value]</code> <code>PRINTING_SPEED</code> Printer speed in mm/s <code>COORDS</code> Current <code>print_move</code>'s, relative or absolute, coordinates in determined by <code>REL_MODE</code> <code>ORIGIN</code> Current definition of origin. A G92 command will overwrite this <code>CURRENT_POSITION</code> Hold current absolute coordinates of printer, with relative/absolute mode already taken into account <code>COLOR</code> Color of current <code>print_move</code>. Useful for specifying custom filament color--especially for multimaterial printing <p>In <code>mecode</code>, the printing history, e.g., to use in a third-party package or own python, can be accessed via <code>g.history[...]</code>. Where <code>g.history[n]</code> specifies the <code>n</code><sup>th</sup> <code>print_move</code>.</p>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#basic-use","title":"Basic Use","text":"<p>To use, simply instantiate the <code>G</code> object and use its methods to trace your desired tool path.</p> <pre><code>from mecode import G\n\ng = G()\n\n# move 10mm in x and 10mm in y\ng.move(10, 10)  (1)\n\n# counterclockwise arc with a radius of 20\ng.arc(x=10, y=5, radius=20, direction='CCW')\n\n# trace a rectangle meander with 1mm spacing between passes\ng.meander(5, 10, spacing=1)\n\n# move the tool head to position (1, 1)\ng.abs_move(x=1, y=1)  \n\n# move the tool head to the origin (0, 0)\ng.home()\n</code></pre> <p>By default <code>mecode</code> simply prints the generated GCode to stdout. If instead you want to generate a file, you can pass a filename and turn off the printing when instantiating the <code>G</code> object.</p> <pre><code>g = G(outfile='path/to/file.gcode', print_lines=False)\n</code></pre> <p>NOTE: <code>g.teardown()</code> must be called after all commands are executed if you are writing to a file. This can be accomplished automatically by using G as a context manager like so:</p> <pre><code>with G(outfile='file.gcode') as g:\n    g.move(10)\n</code></pre> <p>When the <code>with</code> block is exited, <code>g.teardown()</code> will be automatically called.</p> <p>The resulting toolpath can be visualized in 3D using the <code>matplotlib</code> or <code>vpython</code> package with the <code>view()</code> method:</p> <pre><code>g = G()\ng.meander(10, 10, 1)\ng.view()\n</code></pre>"},{"location":"quick-start/#visualization","title":"Visualization","text":"<p>The graphics backend can be specified when calling the <code>view()</code> method and providing one of the following as the <code>backend</code> argument:</p> <ul> <li><code>2d</code> -- 2D visualization figure</li> <li><code>3d</code> -- 3D visualization figure (1)</li> <li><code>animated</code> -- animated rendering (2)</li> </ul> <ol> <li><code>matplotlib</code> is also supported for backwards compatibility</li> <li><code>vpython</code> is also supported for backwards compatibility</li> </ol> <p>E.g. <pre><code>g.view('matplotlib')\n</code></pre></p> <p>Check out tutorials/visualization for more advanced visualizations.</p>"},{"location":"api-reference/matrix/","title":"matrix","text":""},{"location":"api-reference/matrix/#mecode.matrix.GMatrix","title":"<code>GMatrix</code>","text":"<p>               Bases: <code>G</code></p> <p>This class passes points through a 2D transformation matrix before fowarding them to the G class.  A 2D transformation matrix was choosen over a 3D transformation matrix because GCode's ARC command cannot be arbitrary rotated in a 3 dimensions.</p> <p>This lets you write code like:</p> <p>def box(g, height, width):     g.move(0, width)     g.move(height, 0)     g.move(0, -width)     g.move(-height, 0)</p> <p>def boxes(g, height, width):     g.push_matrix()     box(g, height, width)     g.rotate(math.pi/8)     box(g, height, width)     g.pop_matrix()</p> <p>To get two boxes at a 45 degree angle from each other.</p> <p>The 2D transformation matrices are arranged in a stack, similar to OpenGL.</p> <p>numpy is required.</p> Source code in <code>mecode/matrix.py</code> <pre><code>class GMatrix(G):\n    \"\"\"This class passes points through a 2D transformation matrix before\n    fowarding them to the G class.  A 2D transformation matrix was\n    choosen over a 3D transformation matrix because GCode's ARC\n    command cannot be arbitrary rotated in a 3 dimensions.\n\n    This lets you write code like:\n\n    def box(g, height, width):\n        g.move(0, width)\n        g.move(height, 0)\n        g.move(0, -width)\n        g.move(-height, 0)\n\n    def boxes(g, height, width):\n        g.push_matrix()\n        box(g, height, width)\n        g.rotate(math.pi/8)\n        box(g, height, width)\n        g.pop_matrix()\n\n    To get two boxes at a 45 degree angle from each other.\n\n    The 2D transformation matrices are arranged in a stack,\n    similar to OpenGL.\n\n    numpy is required.\n\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(GMatrix, self).__init__(*args, **kwargs)\n        # self._matrix_setup()\n        self.stack = [np.identity(3)]\n        # self.position_savepoints = []\n\n    def push_matrix(self):\n        # Push a copy of the current matrix onto the stack\n        self.stack.append(self.stack[-1].copy())\n\n    def pop_matrix(self):\n        # Pop the top matrix off the stack\n        if len(self.stack) &gt; 1:\n            self.stack.pop()\n        else:\n            self.stack = [np.identity(3)]\n            warnings.warn(\n                \"Cannot pop all items from stack. Setting stack to default identity matrix. To save transforms to stack, call g.push_matrix() before applying transformation.\"\n            )\n            # raise IndexError(\"Cannot pop from an empty matrix stack\")\n\n    def apply_transform(self, transform):\n        # Apply a transformation matrix to the current matrix\n        transormed_matrix = self.stack[-1] @ transform\n\n        # get machine epsilon\n        epsilon = np.finfo(transormed_matrix.dtype).eps\n\n        # round values smaller than machine epsilon to zero\n        self.stack[-1] = np.where(\n            np.abs(transormed_matrix) &lt; epsilon, 0, transormed_matrix\n        )\n\n    def get_current_matrix(self):\n        # Get the current matrix (top of the stack)\n        return self.stack[-1]\n\n    def translate(self, x, y):\n        # Create a translation matrix and apply it\n        translation_matrix = np.array([[1, 0, x], [0, 1, y], [0, 0, 1]])\n        self.apply_transform(translation_matrix)\n\n    def rotate(self, angle):\n        # Create a rotation matrix for the angle\n        c = np.cos(angle)\n        s = np.sin(angle)\n        rotation_matrix = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n        self.apply_transform(rotation_matrix)\n\n    def scale(self, sx, sy=None):\n        if sy is None:\n            sy = sx\n\n        # Create a scaling matrix and apply it\n        scaling_matrix = np.array([[sx, 0, 0], [0, sy, 0], [0, 0, 1]])\n        self.apply_transform(scaling_matrix)\n\n    def abs_move(self, x=None, y=None, z=None, **kwargs):\n        # if x is None or y is None or z is None:\n        #     raise ValueError('x, y, and z must be provided when using the GMatrix class.')\n\n        if x is None:\n            x = self.current_position[\"x\"]\n        if y is None:\n            y = self.current_position[\"y\"]\n        if z is None:\n            z = self.current_position[\"z\"]\n\n        # abs_move ends up invoking move, which means that\n        # we don't need to do a matrix transform here.\n        # NOTE: this also ends up calling `move` below instead of the parent class since method is overriden below\n        super(GMatrix, self).abs_move(x, y, z, **kwargs)\n\n    def move(self, x=None, y=None, z=None, **kwargs):\n        x_p, y_p, z_p = self._transform_point(x, y, z)\n\n        # NOTE: untransformed z is being used here. If support for 3D transformations is added, this should be updated\n        super(GMatrix, self).move(x_p, y_p, z, **kwargs)\n\n    def _transform_point(self, x, y, z):\n        current_matrix = self.get_current_matrix()\n\n        if x is None:\n            x = 0\n        if y is None:\n            y = 0\n        if z is None:\n            z = 0\n\n        return current_matrix @ np.array([x, y, z])\n</code></pre>"},{"location":"api-reference/matrix3D/","title":"matrix3D","text":""},{"location":"api-reference/matrix3D/#mecode.matrix3D.GMatrix3D","title":"<code>GMatrix3D</code>","text":"<p>               Bases: <code>G</code></p> <p>This class passes points through a 3D transformation matrix before forwarding them to the G class, allowing transformations in all three dimensions.</p> <p>The 3D transformation matrices are arranged in a stack, similar to OpenGL.</p> <p>numpy is required.</p> Source code in <code>mecode/matrix3D.py</code> <pre><code>class GMatrix3D(G):\n    \"\"\"This class passes points through a 3D transformation matrix before\n    forwarding them to the G class, allowing transformations in all three\n    dimensions.\n\n    The 3D transformation matrices are arranged in a stack, similar to OpenGL.\n\n    numpy is required.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(GMatrix3D, self).__init__(*args, **kwargs)\n        self.stack = [np.identity(4)]  # Start with a 4x4 identity matrix\n\n    def push_matrix(self):\n        # Push a copy of the current matrix onto the stack\n        self.stack.append(self.stack[-1].copy())\n\n    def pop_matrix(self):\n        # Pop the top matrix off the stack\n        if len(self.stack) &gt; 1:\n            self.stack.pop()\n        else:\n            self.stack = [np.identity(4)]\n            warnings.warn(\n                \"Cannot pop all items from stack. Resetting to default identity matrix.\"\n            )\n\n    def apply_transform(self, transform):\n        # Apply a transformation matrix to the current matrix\n        transformed_matrix = self.stack[-1] @ transform\n\n        # Round values smaller than machine epsilon to zero\n        epsilon = np.finfo(transformed_matrix.dtype).eps\n        self.stack[-1] = np.where(\n            np.abs(transformed_matrix) &lt; epsilon, 0, transformed_matrix\n        )\n\n    def get_current_matrix(self):\n        # Get the current matrix (top of the stack)\n        return self.stack[-1]\n\n    def translate(self, x=0, y=0, z=0):\n        # Create a 3D translation matrix and apply it\n        translation_matrix = np.array([\n            [1, 0, 0, x],\n            [0, 1, 0, y],\n            [0, 0, 1, z],\n            [0, 0, 0, 1]\n        ])\n        self.apply_transform(translation_matrix)\n\n    def rotate_x(self, angle):\n        # Create a rotation matrix around the X-axis\n        c, s = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([\n            [1, 0, 0, 0],\n            [0, c, -s, 0],\n            [0, s, c, 0],\n            [0, 0, 0, 1]\n        ])\n        self.apply_transform(rotation_matrix)\n\n    def rotate_y(self, angle):\n        # Create a rotation matrix around the Y-axis\n        c, s = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([\n            [c, 0, s, 0],\n            [0, 1, 0, 0],\n            [-s, 0, c, 0],\n            [0, 0, 0, 1]\n        ])\n        self.apply_transform(rotation_matrix)\n\n    def rotate_z(self, angle):\n        # Create a rotation matrix around the Z-axis\n        c, s = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([\n            [c, -s, 0, 0],\n            [s, c, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ])\n        self.apply_transform(rotation_matrix)\n\n    def scale(self, sx, sy=None, sz=None):\n        if sy is None:\n            sy = sx\n        if sz is None:\n            sz = sx\n        # Create a scaling matrix and apply it\n        scaling_matrix = np.array([\n            [sx, 0, 0, 0],\n            [0, sy, 0, 0],\n            [0, 0, sz, 0],\n            [0, 0, 0, 1]\n        ])\n        self.apply_transform(scaling_matrix)\n\n    def abs_move(self, x=None, y=None, z=None, **kwargs):\n        if x is None:\n            x = self.current_position[\"x\"]\n        if y is None:\n            y = self.current_position[\"y\"]\n        if z is None:\n            z = self.current_position[\"z\"]\n        super(GMatrix3D, self).abs_move(x, y, z, **kwargs)\n\n    def move(self, x=None, y=None, z=None, **kwargs):\n        x_p, y_p, z_p = self._transform_point(x, y, z)\n        super(GMatrix3D, self).move(x_p, y_p, z_p, **kwargs)\n\n    def _transform_point(self, x, y, z):\n        current_matrix = self.get_current_matrix()\n\n        if x is None:\n            x = 0\n        if y is None:\n            y = 0\n        if z is None:\n            z = 0\n\n        transformed_point = current_matrix @ np.array([x, y, z, 1])\n        return transformed_point[:3]  # Return only x, y, z\n</code></pre>"},{"location":"api-reference/mecode/","title":"mecode","text":""},{"location":"api-reference/mecode/#mecode.main.G","title":"<code>G</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>mecode/main.py</code> <pre><code>class G(object):\n\n    def __init__(self,\n                    outfile=None,\n                    print_lines=True,\n                    header=None,\n                    footer=None,\n                    aerotech_include=True,\n                    output_digits=6,\n                    direct_write=False,\n                    direct_write_mode='socket',\n                    printer_host='localhost',\n                    printer_port=8000,\n                    baudrate=250000,\n                    two_way_comm=True,\n                    x_axis='X',\n                    y_axis='Y',\n                    z_axis='Z',\n                    extrude=False,\n                    filament_diameter=1.75,\n                    layer_height=0.19,\n                    extrusion_width=0.35,\n                    extrusion_multiplier=1,\n                    setup=True,\n                    lineend='os'):\n        \"\"\"\n        Parameters\n        ----------\n        outfile : path or None (default: None)\n            If a path is specified, the compiled gcode will be writen to that\n            file.\n        print_lines : bool (default: True)\n            Whether or not to print the compiled GCode to stdout\n\n        Other Parameters\n        ----------------\n        header : path or None (default: None)\n            Optional path to a file containing lines to be written at the\n            beginning of the output file\n        footer : path or None (default: None)\n            Optional path to a file containing lines to be written at the end\n            of the output file.\n        aerotech_include : bool (default: True)\n            If true, add aerotech specific functions and var defs to outfile.\n        output_digits : int (default: 6)\n            How many digits to include after the decimal in the output gcode.\n        direct_write : bool (default: False)\n            If True a socket or serial port is opened to the printer and the\n            GCode is sent directly over.\n        direct_write_mode : str (either 'socket' or 'serial') (default: socket)\n            Specify the channel your printer communicates over, only used if\n            `direct_write` is True.\n        printer_host : str (default: 'localhost')\n            Hostname of the printer, only used if `direct_write` is True.\n        printer_port : int (default: 8000)\n            Port of the printer, only used if `direct_write` is True.\n        baudrate: int (default: 250000)\n            The baudrate to connect to the printer with.\n        two_way_comm : bool (default: True)\n            If True, mecode waits for a response after every line of GCode is\n            sent over the socket. The response is returned by the `write`\n            method. Only applies if `direct_write` is True.\n        x_axis : str (default 'X')\n            The name of the x axis (used in the exported gcode)\n        y_axis : str (default 'Y')\n            The name of the z axis (used in the exported gcode)\n        z_axis : str (default 'Z')\n            The name of the z axis (used in the exported gcode)\n        extrude : True or False (default: False)\n            If True, a flow calculation will be done in the move command. The\n            neccesary length of filament to be pushed through on a move command\n            will be tagged on as a kwarg. ex. X5 Y5 E3\n        filament_diameter: float (default 1.75)\n            the diameter of FDM filament you are using\n        layer_height : float\n            Layer height for FDM printing. Only relavent when extrude = True.\n        extrusion width: float\n            total width of the capsule shaped cross section of a squashed filament.\n        extrusion_multiplier: float (default = 1)\n            The length of extrusion filament to be pushed through on a move\n            command will be multiplied by this number before being applied.\n        setup : Bool (default: True)\n            Whether or not to automatically call the setup function.\n        lineend : str (default: 'os')\n            Line ending to use when writing to a file or printer. The special\n            value 'os' can be passed to fall back on python's automatic\n            lineending insertion.\n\n        \"\"\"\n        self.outfile = outfile\n        self.print_lines = print_lines\n        self.header = header\n        self.footer = footer\n        self.aerotech_include = aerotech_include\n        self.output_digits = output_digits\n        self.direct_write = direct_write\n        self.direct_write_mode = direct_write_mode\n        self.printer_host = printer_host\n        self.printer_port = printer_port\n        self.baudrate = baudrate\n        self.two_way_comm = two_way_comm\n        self.x_axis = x_axis\n        self.y_axis = y_axis\n        self.z_axis = z_axis\n\n        self.extrude = extrude\n        self.filament_diameter = filament_diameter\n        self.layer_height = layer_height\n        self.extrusion_width = extrusion_width\n        self.extrusion_multiplier = extrusion_multiplier\n\n        self.history = [{\n            'REL_MODE': True,\n            'ACCEL' : 2500,\n            'DECEL' : 2500,\n            # 'P' : PRESSURE,\n            # 'P_COM_PORT': P_COM_PORT,\n            'PRINTING': {}, #{'Call togglePress': {'printing': False, 'value': 0}},\n            'PRINT_SPEED': 0,\n            'COORDS': (0,0,0),\n            'ORIGIN': (0,0,0),\n            'CURRENT_POSITION': {'X': 0, 'Y': 0, 'Z': 0},\n            # 'VARIABLES': VARIABLES\n            'COLOR': None\n        }]\n\n        self._current_position = defaultdict(float)\n        self.is_relative = True\n        self.position_history = [(0, 0, 0)]\n        self.color_history = [DEFAULT_FILAMENT_COLOR]\n        self.speed = 0\n        self.speed_history = []\n        self.extruding = [None, False, 0] # source, if_printing, printing_value\n        self.extruding_history = []\n        self.extrusion_state = {}#defaultdict()\n\n        self.print_time = 0\n        self.version = None\n\n        self._socket = None\n        self._p = None\n\n        # If the user passes in a line ending then we need to open the output\n        # file in binary mode, otherwise python will try to be smart and\n        # convert line endings in a platform dependent way.\n        if lineend == 'os':\n            mode = 'w+'\n            self.lineend = '\\n'\n        else:\n            mode = 'wb+'\n            self.lineend = lineend\n\n        if is_str(outfile):\n            self.out_fd = open(outfile, mode)\n        elif outfile is not None:  # if outfile not str assume it is an open file\n            self.out_fd = outfile\n        else:\n            self.out_fd = None\n\n        if setup:\n            self.setup()\n\n        self._check_latest_version()\n\n    @property\n    def current_position(self):\n        return self._current_position\n\n    def _check_latest_version(self):\n        import re, requests\n        from packaging import version\n\n        def read_version_from_setup():\n            try:\n                import pkg_resources  # part of setuptools\n\n                version = pkg_resources.require(\"mecode\")[0].version\n\n                return version\n            except:\n                return None\n\n        def read_version_from_github(username, repo, path='setup.py'):\n            # GitHub raw content URL\n            raw_url = f'https://raw.githubusercontent.com/{username}/{repo}/main/{path}'\n\n            try:\n                # Make a GET request to the raw content URL\n                response = requests.get(raw_url)\n                response.raise_for_status()  # Raise an exception for HTTP errors\n\n                # Use regular expression to find the version string\n                version_match = re.search(r\"'version': ['\\\"]([^'\\\"]*)['\\\"]\", response.text)\n\n                if version_match:\n                    version = version_match.group(1)\n                    return version\n                else:\n                    print(\"Version not found in remote setup.py.\")\n                    return None\n\n            except requests.exceptions.RequestException as e:\n                print(f\"Error: {e}\")\n                return None\n\n        github_username = 'rtellez700'\n        github_repo = 'mecode'\n\n        remote_package_version = read_version_from_github(github_username, github_repo)\n\n        local_package_version = read_version_from_setup()\n\n        if local_package_version and 'unittest' not in sys.modules.keys():\n            self.version = local_package_version\n            print(f\"\\nRunning mecode v{local_package_version}\")\n\n        # confirm that a version is already installed first\n        if 'unittest' not in sys.modules.keys():\n            if local_package_version is not None and remote_package_version is not None:\n                if version.parse(local_package_version) &lt; version.parse(remote_package_version):\n                    print(\"A new mecode version is available. To upgrade to the latest version run:\\n\\t&gt;&gt;&gt; pip install git+https://github.com/rtellez700/mecode.git --upgrade\")\n\n    def __enter__(self):\n        \"\"\"\n        Context manager entry\n        Can use like:\n\n        with mecode.G(  outfile=self.outfile,\n                        print_lines=False,\n                        aerotech_include=False) as g:\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"\n        Context manager exit\n        \"\"\"\n        self.teardown()\n\n    # GCode Aliases  ########################################################\n\n    def set_home(self, x=None, y=None, z=None, **kwargs):\n        \"\"\" Set the current position to the given position without moving.\n\n        Examples\n        --------\n\n        set the current position to X=0, Y=0\n        &gt;&gt;&gt; g.set_home(0, 0)\n\n        \"\"\"\n        args = self._format_args(x, y, z, **kwargs)\n        self.write('G92 ' + args)\n\n        self._update_current_position(x=x, y=y, z=z, mode='absolute', **kwargs)\n\n\n        # Handle None values and default to zero if None\n        x = 0 if x is None else x\n        y = 0 if y is None else y\n        z = 0 if z is None else z\n\n        new_origin = (self.history[-1]['CURRENT_POSITION']['X'] + x,\n                      self.history[-1]['CURRENT_POSITION']['Y'] + y,\n                      self.history[-1]['CURRENT_POSITION']['Z'] + z)\n\n        self.history[-1]['ORIGIN'] = new_origin\n\n\n    def reset_home(self):\n        \"\"\" Reset the position back to machine coordinates without moving.\n        \"\"\"\n        # FIXME This does not work with internal current_position\n        # FIXME You must call an abs_move after this to re-sync\n        # current_position\n        self.write('G92.1')\n\n    def relative(self):\n        \"\"\" Enter relative movement mode, in general this method should not be\n        used, most methods handle it automatically.\n\n        \"\"\"\n        if not self.is_relative:\n            self.write('G91')\n            self.is_relative = True\n\n    def absolute(self):\n        \"\"\" Enter absolute movement mode, in general this method should not be\n        used, most methods handle it automatically.\n\n        \"\"\"\n        if self.is_relative:\n            self.write('G90')\n            self.is_relative = False\n\n    def feed(self, rate):\n        \"\"\" Set the feed rate (tool head speed) in mm/s\n\n        Parameters\n        ----------\n        rate : float\n            The speed to move the tool head in mm/s.\n\n        \"\"\"\n        self.write('G1 F{}'.format(rate))\n        self.speed = rate\n\n    def dwell(self, time):\n        \"\"\" Pause code executions for the given amount of time.\n\n        Parameters\n        ----------\n        time : float\n            Time in milliseconds to pause code execution.\n\n        \"\"\"\n        self.write('G4 P{}'.format(time))\n\n    def auto_home(self,\n            X = True,\n            Y = True,\n            Z = True,\n            restore_leveling_after = None,\n            skip_if_trusted = None,\n            nozzle_raise_distance = None,\n            ):\n        \"\"\" Automatically calibrate the axis positions.\n\n        Parameters\n        ----------\n        home_x : bool (default: True)\n            Home the X axis.\n        home_y : bool (default: True)\n            Home the Y axis.\n        home_z : bool (default: True)\n            Home the Z axis.\n        restore_leveling_after : bool (default: True)\n            Restore bed leveling state after homing.\n        skip_if_trusted : bool (default: False)\n            Skip homing if the position is already trusted.\n        nozzle_raise_distance : float (default: 0.0)\n            The distance to raise the nozzle before homing.\n        \"\"\"\n        fields = dict(\n                G28 = True,\n                L = restore_leveling_after,\n                O = skip_if_trusted,\n                R = nozzle_raise_distance,\n                X = X,\n                Y = Y,\n                Z = Z)\n        fields = [key for key, val in fields.items() if val]\n        self.write(\" \".join(fields))\n\n    def park_toolhead(self, z_mode = None):\n        \"\"\" Park the toolhead if supported.\n\n        Parameters\n        ----------\n        z_mode : int\n            0: Raise the nozzle to the Z-park height\n            1: Raise or lower the nozzle to the Z-park height\n            2: Raise the nozzle by the Z-park amount\n        \"\"\"\n        if z_mode is not None:\n            self.write(\"G27 P{}\".format(z_mode))\n        else:\n            self.write(\"G27\")\n\n    def finish_moves(self, wait=True):\n        \"\"\" Halts the processing of G-code until moves are completed.\n\n        Parameters\n        ----------\n        wait : bool (default: True)\n            Whether to pause python execution as well.\n        \"\"\"\n        self.write(\"M400\", resp_needed=wait)\n\n    def break_and_continue(self):\n        \"\"\" Stop waiting and continue processing G-code.\n        \"\"\"\n        self.write(\"M108\")\n\n    # Composed Functions  #####################################################\n\n    def setup(self):\n        \"\"\" Set the environment into a consistent state to start off. This\n        method must be called before any other commands.\n\n        \"\"\"\n        self._write_header()\n        if self.is_relative:\n            self.write('G91')\n        else:\n            self.write('G90')\n\n    def teardown(self, wait=True):\n        \"\"\" Close the outfile file after writing the footer if opened. This\n        method must be called once after all commands.\n\n        Parameters\n        ----------\n        wait : Bool (default: True)\n            Only used if direct_write_model == 'serial'. If True, this method\n            waits to return until all buffered lines have been acknowledged.\n\n        \"\"\"\n        if self.out_fd is not None:\n            if self.aerotech_include is True:\n                with open(os.path.join(HERE, 'footer.txt')) as fd:\n                    self._write_out(lines=fd.readlines())\n            if self.footer is not None:\n                with open(self.footer) as fd:\n                    self._write_out(lines=fd.readlines())\n            self.out_fd.close()\n        if self._socket is not None:\n            self._socket.close()\n        if self._p is not None:\n            self._p.disconnect(wait)\n\n        # do not calculate print time during unittests\n        if 'unittest' not in sys.modules.keys():\n            self.calc_print_time()\n\n    def home(self):\n        \"\"\" Move the tool head to the home position (X=0, Y=0).\n        \"\"\"\n        self.abs_move(x=0, y=0)\n\n    def move_inc(self, disp=None, speed=None, axis=None, accel=None, decel=None):\n        ''' Typically used to move linear actuator incrementally. Operates in\n        relative mode.\n\n        disp : float\n            amount to displace `axis`. Negative values can be used for retraction\n        speed : float\n            Speed to move `axis` at\n        accel : float\n            If provided, will set the acceleration of `axis`\n            TODO: NOT CURRENTLY SUPPORTED\n        decel : float\n            If provided, will set the deceleration of `axis`\n            TODO: NOT CURRENTLY SUPPORTED\n        '''\n        # self.extrude = True\n        # if accel is not None:\n\n        self.write(f'MOVEINC {axis} {disp:.6f} {speed:.6f}')\n        # self.extrude = False\n\n    def move(self, x=None, y=None, z=None, k=None, theta=None, rapid=False, color=DEFAULT_FILAMENT_COLOR, comment='', **kwargs):\n        \"\"\" Move the tool head to the given position. This method operates in\n        relative mode unless a manual call to [absolute][mecode.main.G.absolute] was given previously.\n        If an absolute movement is desired, the [abs_move][mecode.main.G.abs_move] method is\n        recommended instead.\n\n        points : floats\n            Must specify endpoint as kwargs, e.g. x=5, y=5\n        k : Vector (default: None)\n            If supplied, will rotate points (x,y,z) about the axis given by k in accordance with \n            the Rodrigues' formula: v'=vcos(\u03b8)+(k x v)sin(\u03b8)+k(k\u22c5v)(1 - cos(\u03b8))\n        theta : float (default: None)\n            Used together with k for Rodrigues' formula\n        rapid : Bool (default: False)\n            Executes an uncoordinated move to the specified location.\n        color : hex string or rgb(a) string\n            Specifies a color to be added to color history for viewing.\n        comment : str (default: '')\n            Adds a comment to the end of the line.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # move the tool head 10 mm in x and 10 mm in y\n        &gt;&gt;&gt; g.move(x=10, y=10)\n\n        &gt;&gt;&gt; # the x, y, and z keywords may be omitted:\n        &gt;&gt;&gt; g.move(10, 10, 10)\n\n        &gt;&gt;&gt; # move the A axis up 20 mm\n        &gt;&gt;&gt; g.move(A=20)\n\n        \"\"\"\n\n        if self.speed == 0:\n            msg = 'WARNING! no print speed has been set. Will default to previously used print speed.'\n            self.write('; ' + msg)\n\n            warnings.warn('''\n                            &gt;&gt;&gt; No print speed has been specified\n                            e.g., to set print speed to 15 mm/s use:\n                            \\t\\t g.feed(15)\n\n                            If this is not the intended behavior please set a print speed. You can ignore this if your testing out features such as testing serial communication etc.\n                            ''')\n\n        if self.extrude is True and 'E' not in kwargs.keys():\n            if self.is_relative is not True:\n                x_move = self.current_position['x'] if x is None else x\n                y_move = self.current_position['y'] if y is None else y\n                x_distance = abs(x_move - self.current_position['x'])\n                y_distance = abs(y_move - self.current_position['y'])\n                current_extruder_position = self.current_position['E']\n            else:\n                x_distance = 0 if x is None else x\n                y_distance = 0 if y is None else y\n                current_extruder_position = 0\n            line_length = math.sqrt(x_distance**2 + y_distance**2)\n            area = self.layer_height*(self.extrusion_width-self.layer_height) + \\\n                3.14159*(self.layer_height/2)**2\n            volume = line_length*area\n            filament_length = ((4*volume)/(3.14149*self.filament_diameter**2))*self.extrusion_multiplier\n            kwargs['E'] = filament_length + current_extruder_position\n\n        if k is None:\n            self._update_current_position(x=x, y=y, z=z, color=color, **kwargs)\n        else:\n            if theta is None:\n                raise ValueError(f'Both k and theta need to be supplied but got k={k} and theta={theta}')\n            v = np.array([x, y, z])\n            k = k / np.linalg.norm(k)  # Ensure k is a unit vector\n            v_rot = (v * np.cos(theta) +\n                    np.cross(k, v) * np.sin(theta) +\n                    k * np.dot(k, v) * (1 - np.cos(theta)))\n\n            x,y,z = v_rot\n\n        self._update_print_time(x,y,z)\n        # new_state = self.history[-1].copy()\n        # new_state['COORDS'] = (x, y, z)\n        # new_state['CURRENT_POSITION'] = {'X': self._current_position['x'], 'Y': self._current_position['y'], 'Z': self._current_position['z']}\n        # self.history.append(new_state)\n        args = self._format_args(x, y, z, **kwargs)\n        cmd = 'G0 ' if rapid else 'G1 '\n        self.write(cmd + args + f'; {comment}')\n\n    def abs_move(self, x=None, y=None, z=None, rapid=False, **kwargs):\n        \"\"\" Same as [move][mecode.main.G.move] method, but positions are interpreted as absolute.\n        \"\"\"\n        if self.is_relative:\n            self.absolute()\n            self.move(x=x, y=y, z=z, rapid=rapid, **kwargs)\n            self.relative()\n        else:\n            self.move(x=x, y=y, z=z, rapid=rapid, **kwargs)\n\n    def rapid(self, x=None, y=None, z=None, **kwargs):\n        \"\"\" Executes an uncoordinated move to the specified location.\n        \"\"\"\n        self.move(x, y, z, rapid=True, **kwargs)\n\n    def abs_rapid(self, x=None, y=None, z=None, **kwargs):\n        \"\"\" Executes an uncoordinated abs move to the specified location.\n        \"\"\"\n        self.abs_move(x, y, z, rapid=True, **kwargs)\n\n    def retract(self, retraction):\n        if self.extrude is False:\n            self.move(E = -retraction)\n        else:\n            self.extrude = False\n            self.move(E = -retraction)\n            self.extrude = True\n\n    def circle(self, radius, center=None,  direction='CW', linearize=True, **kwargs):\n        \"\"\" Generates a circle starting from the current position if center is None,\n        otherwise from center.\n\n        Parameters\n        ----------\n        direction : str (either 'CW' or 'CCW') (default: 'CW')\n            The direction to execute the arc in.\n        radius : float\n            The radius of the circle.\n        center : (float, float)\n            The center coordinates of the circle\n        linearize : Bool (default: True)\n            Represent the arc of the circle as a series of straight lines.\n\n        Examples\n        --------\n        TODO: updates these\n        &gt;&gt;&gt; # arc 10 mm up in y and 10 mm over in x with a radius of 20.\n        &gt;&gt;&gt; g.arc(x=10, y=10, radius=20)\n\n        &gt;&gt;&gt; # move 10 mm up on the A axis, arcing through y with a radius of 20\n        &gt;&gt;&gt; g.arc(A=10, y=0, radius=20)\n\n        &gt;&gt;&gt; # arc through x and y while moving linearly on axis A\n        &gt;&gt;&gt; g.arc(x=10, y=10, radius=50, helix_dim='A', helix_len=5)\n\n        \"\"\"\n        if direction == 'CW':\n            self.arc(x=radius, y=radius, radius=radius, direction='CW', linearize=linearize, **kwargs)\n            self.arc(x=radius, y=-radius, radius=radius, direction='CW', linearize=linearize, **kwargs)\n            self.arc(x=-radius, y=-radius, radius=radius, direction='CW', linearize=linearize, **kwargs)\n            self.arc(x=-radius, y=radius, radius=radius, direction='CW', linearize=linearize, **kwargs)\n        elif direction == 'CCW':\n            self.arc(x=-radius, y=radius, radius=radius, direction='CCW', linearize=linearize, **kwargs)\n            self.arc(x=-radius, y=-radius, radius=radius, direction='CCW', linearize=linearize, **kwargs)\n            self.arc(x=radius, y=-radius, radius=radius, direction='CCW', linearize=linearize, **kwargs)\n            self.arc(x=radius, y=radius, radius=radius, direction='CCW', linearize=linearize, **kwargs)\n    def _arc_points(self, center, radius, start_angle, end_angle, num_points=100):\n        \"\"\"\n        Calculate points along a circular arc.\n\n        :param center: Tuple of (x, y) coordinates of the arc center\n        :param radius: Radius of the arc\n        :param start_angle: Starting angle in radians\n        :param end_angle: Ending angle in radians\n        :param num_points: Number of points to generate along the arc\n        :return: List of points along the arc as (x, y)\n        \"\"\"\n        angles = np.linspace(start_angle, end_angle, num_points)\n        points = [(center[0] + radius * np.cos(angle), center[1] + radius * np.sin(angle)) for angle in angles]\n\n        return points\n\n    def _g02(self, center, radius, start_point, end_point, clockwise=True, num_points=100):\n        \"\"\"\n        Generate points for clockwise circular arc (G02).\n\n        :param center: Tuple of (x, y) coordinates of the arc center\n        :param radius: Radius of the arc\n        :param start_point: Tuple of (x, y) coordinates of the starting point\n        :param end_point: Tuple of (x, y) coordinates of the end point\n        :param clockwise: Boolean indicating direction (True for clockwise)\n        :param num_points: Number of points to generate along the arc\n        :return: List of points along the arc as (x, y)\n        \"\"\"\n        start_angle = np.arctan2(start_point[1] - center[1], start_point[0] - center[0])\n        end_angle = np.arctan2(end_point[1] - center[1], end_point[0] - center[0])\n\n        if clockwise:\n            if end_angle &gt; start_angle:\n                end_angle -= 2 * np.pi\n        else:\n            if start_angle &gt; end_angle:\n                start_angle -= 2 * np.pi\n\n        return self._arc_points(center, radius, start_angle, end_angle, num_points)\n\n    def _g03(self, center, radius, start_point, end_point):\n        \"\"\"\n        Generate points for counterclockwise circular arc (G03).\n\n        :param center: Tuple of (x, y) coordinates of the arc center\n        :param radius: Radius of the arc\n        :param start_point: Tuple of (x, y) coordinates of the starting point\n        :param end_point: Tuple of (x, y) coordinates of the end point\n        :param counterclockwise: Boolean indicating direction (True for counterclockwise)\n        :param num_points: Number of points to generate along the arc\n        :return: List of points along the arc as (x, y)\n        \"\"\"\n        return self._g02(center, radius, start_point, end_point, clockwise=False)\n\n    def arc_v2(self, end_point, center, radius, plane='xy', direction='CW', linearize=True, **kwargs):\n        if plane not in {'xy', 'yz', 'xz'}:\n            raise ValueError(\"Plane must be one of 'xy', 'yz', or 'xz'.\")\n        if direction not in {'CW', 'CCW'}:\n            raise ValueError(\"Direction must be 'CW' or 'CCW'.\")\n\n        if self.z_axis != 'Z':\n            axis = self.z_axis\n\n        if direction == 'CW':\n            points = self._g02(center, radius, (0,0), end_point)\n        elif direction == 'CCW':\n            points = self._g03(center, radius, (0,0), end_point)\n\n        rel_pts = []\n        for i in range(1, len(points)):\n            dx0 = points[i][0] - points[i-1][0]\n            dx1 = points[i][1] - points[i-1][1]\n            rel_pts.append((dx0, dx1))\n\n        command = 'G02' if direction == 'CW' else 'G03'\n        for x0, x1 in rel_pts:\n            if plane == 'xy':\n                if linearize:\n                    self.move(x=x0, y=x1, **kwargs)\n                else:\n                    # left in for visualization purposes\n                    self._update_current_position(x=x0, y=x1)\n            elif plane == 'yz':\n                if linearize:\n                    self.move(y=x0, z=x1, **kwargs)\n                else:\n                    # left in for visualization purposes\n                    self._update_current_position(y=x0, z=x1)\n            elif plane == 'xz':\n                if linearize:\n                    self.move(x=x0, z=x1, **kwargs)\n                else:\n                    # left in for visualization purposes\n                    self._update_current_position(x=x0, z=x1)\n\n        if plane == 'xy':\n            plane_selector = 'G17'\n            args = self._format_args(x=end_point[0], y=end_point[1])\n        elif plane == 'yz':\n            plane_selector = 'G19'\n            args = self._format_args(y=end_point[0], z=end_point[1])\n        elif plane == 'xz':\n            plane_selector = 'G18'\n            args = self._format_args(x=end_point[0], z=end_point[1])\n\n        self.write(f'{plane_selector} {command} {args} {radius:.{self.output_digits}f}')\n\n    def abs_arc_v2(self, end_point, center, radius, plane='xy', direction='CW', linearize=True, **kwargs):\n        if plane not in {'xy', 'yz', 'xz'}:\n            raise ValueError(\"Plane must be one of 'xy', 'yz', or 'xz'.\")\n        if direction not in {'CW', 'CCW'}:\n            raise ValueError(\"Direction must be 'CW' or 'CCW'.\")\n\n        if plane == 'xy':\n            start_point = self._current_position['x'], self._current_position['y']\n        elif plane == 'yz':\n            start_point = self._current_position['y'], self._current_position['z']\n        elif plane == 'xz':\n            start_point = self._current_position['x'], self._current_position['z']\n\n        if direction == 'CW':\n            points = self._g02(center, radius, start_point, end_point)\n        elif direction == 'CCW':\n            points = self._g03(center, radius, start_point, end_point)\n\n        command = 'G02' if direction == 'CW' else 'G03'\n        for x0, x1 in points:\n            if plane == 'xy':\n                if linearize:\n                    self.abs_move(x=x0, y=x1, **kwargs)\n                else:\n                    # left in for visualization purposes\n                    self._update_current_position(x=x0, y=x1)\n            elif plane == 'yz':\n                if linearize:\n                    self.abs_move(y=x0, z=x1, **kwargs)\n                else:\n                    # left in for visualization purposes\n                    self._update_current_position(y=x0, z=x1)\n            elif plane == 'xz':\n                if linearize:\n                    self.abs_move(x=x0, z=x1, **kwargs)\n                else:\n                    # left in for visualization purposes\n                    self._update_current_position(x=x0, z=x1)\n\n        if plane == 'xy':\n            plane_selector = 'G17'\n            args = self._format_args(x=end_point[0], y=end_point[1])\n        elif plane == 'yz':\n            plane_selector = 'G19'\n            args = self._format_args(y=end_point[0], z=end_point[1])\n        elif plane == 'xz':\n            plane_selector = 'G18'\n            args = self._format_args(x=end_point[0], z=end_point[1])\n\n        self.write(f'{plane_selector} {command} {args} {radius:.{self.output_digits}f}')\n\n    def arc(self, x=None, y=None, z=None, direction='CW', radius='auto',\n            helix_dim=None, helix_len=0, linearize=True, color=(0,1,0,0.5), **kwargs):\n        \"\"\" Arc to the given point with the given radius and in the given\n        direction. If helix_dim and helix_len are specified then the tool head\n        will also perform a linear movement through the given dimension while\n        completing the arc. Note: Helix and flow calculation do not currently\n        work with linearize.\n\n        Parameters\n        ----------\n        direction : str (either 'CW' or 'CCW') (default: 'CW')\n            The direction to execute the arc in.\n        radius : 'auto' or float (default: 'auto')\n            The radius of the arc. A negative value will select the longer of\n            the two possible arc segments. If auto is selected the radius will\n            be set to half the linear distance to desired point.\n        helix_dim : str or None (default: None)\n            The linear dimension to complete the helix through\n        helix_len : float\n            The length to move in the linear helix dimension.\n        linearize : Bool (default: True)\n            Represent the arc as a series of straight lines.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # arc 10 mm up in y and 10 mm over in x with a radius of 20.\n        &gt;&gt;&gt; g.arc(x=10, y=10, radius=20)\n\n        &gt;&gt;&gt; # move 10 mm up on the A axis, arcing through y with a radius of 20\n        &gt;&gt;&gt; g.arc(A=10, y=0, radius=20)\n\n        &gt;&gt;&gt; # arc through x and y while moving linearly on axis A\n        &gt;&gt;&gt; g.arc(x=10, y=10, radius=50, helix_dim='A', helix_len=5)\n\n        \"\"\"\n        dims = dict(kwargs)\n        if x is not None:\n            dims['x'] = x\n        if y is not None:\n            dims['y'] = y\n        if z is not None:\n            dims['z'] = z\n        msg = 'Must specify two of x, y, or z.'\n        if len(dims) != 2:\n            raise RuntimeError(msg)\n        dimensions = [k.lower() for k in dims.keys()]\n        if 'x' in dimensions and 'y' in dimensions:\n            plane_selector = 'G17'  # XY plane\n            axis = helix_dim\n        elif 'x' in dimensions:\n            plane_selector = 'G18'  # XZ plane\n            dimensions.remove('x')\n            axis = dimensions[0].upper()\n        elif 'y' in dimensions:\n            plane_selector = 'G19'  # YZ plane\n            dimensions.remove('y')\n            axis = dimensions[0].upper()\n        else:\n            raise RuntimeError(msg)\n        if self.z_axis != 'Z':\n            axis = self.z_axis\n\n        if direction == 'CW':\n            command = 'G2'\n        elif direction == 'CCW':\n            command = 'G3'\n\n        values = [v for v in dims.values()]\n        if self.is_relative:\n            dist = math.sqrt(values[0] ** 2 + values[1] ** 2)\n            if radius == 'auto':\n                radius = dist / 2.0\n            elif abs(radius) &lt; dist / 2.0:\n                msg = 'Radius {} to small for distance {}'.format(radius, dist)\n                raise RuntimeError(msg)\n            vect_dir= [values[0]/dist,values[1]/dist]\n            if direction == 'CW':\n                arc_rotation_matrix = np.array([[0, -1],[1, 0]])\n            elif direction =='CCW':\n                arc_rotation_matrix = np.array([[0, 1],[-1, 0]])\n            perp_vect_dir = np.array(vect_dir)*arc_rotation_matrix\n            a_vect= np.array([values[0]/2,values[1]/2])\n            b_length = math.sqrt(radius**2-(dist/2)**2)\n            b_vect = b_length*perp_vect_dir\n            c_vect = a_vect+b_vect\n            # center_coords = c_vect\n            final_pos = a_vect*2-c_vect\n            initial_pos = -c_vect\n        else:\n            k = [ky for ky in dims.keys()]\n            cp = self._current_position\n            dist = math.sqrt(\n                (cp[k[0]] - values[0]) ** 2 + (cp[k[1]] - values[1]) ** 2\n            )\n\n            if radius == 'auto':\n                radius = dist / 2.0\n            elif abs(radius) &lt; dist / 2.0:\n                msg = 'Radius {} to small for distance {}'.format(radius, dist)\n                raise RuntimeError(msg)\n\n            vect_dir= [(values[0]-cp[k[0]])/dist,(values[1]-cp[k[1]])/dist]\n            if direction == 'CW':\n                arc_rotation_matrix = np.array([[0, -1],[1, 0]])\n            elif direction =='CCW':\n                arc_rotation_matrix = np.array([[0, 1],[-1, 0]])\n            perp_vect_dir = np.array(vect_dir)*arc_rotation_matrix\n            a_vect = np.array([(values[0]-cp[k[0]])/2.0,(values[1]-cp[k[1]])/2.0])\n            b_length = math.sqrt(radius**2-(dist/2)**2)\n            b_vect = b_length*perp_vect_dir\n            c_vect = a_vect+b_vect\n            # center_coords = np.array(cp[k[:2]])+c_vect\n\n            final_pos = np.array([cp[k] for k in k[:2]])+a_vect*2-c_vect\n            initial_pos = np.array([cp[k] for k in k[:2]])\n\n            # final_pos = np.array(cp[k[:2]])+a_vect*2-c_vect\n            # initial_pos = np.array(cp[k[:2]])\n\n        #extrude feature implementation\n        # only designed for flow calculations in x-y plane\n        if self.extrude is True:\n            area = self.layer_height*(self.extrusion_width-self.layer_height) + 3.14159*(self.layer_height/2)**2\n            if self.is_relative is not True:\n                current_extruder_position = self.current_position['E']\n            else:\n                current_extruder_position = 0\n\n            circle_circumference = 2*3.14159*abs(radius)\n\n            arc_angle = ((2*math.asin(dist/(2*abs(radius))))/(2*3.14159))*360\n            shortest_arc_length = (arc_angle/180)*3.14159*abs(radius)\n            if radius &gt; 0:\n                arc_length = shortest_arc_length\n            else:\n                arc_length = circle_circumference - shortest_arc_length\n            volume = arc_length*area\n            filament_length = ((4*volume)/(3.14149*self.filament_diameter**2))*self.extrusion_multiplier\n            dims['E'] = filament_length + current_extruder_position\n\n        if linearize:\n            #Curved formed from straight lines\n            final_pos = np.array(final_pos.tolist()).flatten()\n            initial_pos = np.array(initial_pos.tolist()).flatten()\n            final_angle = np.arctan2(final_pos[1],final_pos[0])\n            initial_angle = np.arctan2(initial_pos[1],initial_pos[0])\n\n            if direction == 'CW':\n                angle_difference = 2*np.pi-(final_angle-initial_angle)%(2*np.pi)\n            elif direction == 'CCW':\n                angle_difference = (initial_angle-final_angle)%(-2*np.pi)\n\n            step_range = [0, angle_difference]\n            step_size = np.pi/16\n            angle_step = np.arange(step_range[0],step_range[1]+np.sign(angle_difference)*step_size,np.sign(angle_difference)*step_size)\n\n            segments = []\n            for angle in angle_step:\n                radius_vect = -c_vect\n                radius_rotation_matrix = np.array([[math.cos(angle), -math.sin(angle)],\n                                 [math.sin(angle), math.cos(angle)]])\n                int_point = radius_vect*radius_rotation_matrix\n                segments.append(int_point)\n\n            for i in range(len(segments)-1):\n                move_line = segments[i+1]-segments[i]\n                self.move(*move_line.tolist()[0], color=color)\n        else:\n            #Standard output\n            if axis is not None:\n                self.write('G16 X Y {}'.format(axis))  # coordinate axis assignment\n            self.write(plane_selector)\n            args = self._format_args(**dims)\n            if helix_dim is None:\n                self.write('{0} {1} R{2:.{digits}f}'.format(command, args, radius,\n                                                            digits=self.output_digits))\n            else:\n                self.write('{0} {1} R{2:.{digits}f} G1 {3}{4}'.format(\n                    command, args, radius, helix_dim.upper(), helix_len, digits=self.output_digits))\n                dims[helix_dim] = helix_len\n\n            self._update_current_position(**dims)\n\n    def abs_arc(self, direction='CW', radius='auto', **kwargs):\n        \"\"\" Same as [arc][mecode.main.G.arc] method, but positions are interpreted as absolute.\n        \"\"\"\n        if self.is_relative:\n            self.absolute()\n            self.arc(direction=direction, radius=radius, **kwargs)\n            self.relative()\n        else:\n            self.arc(direction=direction, radius=radius, **kwargs)\n\n    def rect(self, x, y, direction='CW', start='LL'):\n        \"\"\" Trace a rectangle with the given width and height.\n\n        Parameters\n        ----------\n        x : float\n            The width of the rectangle in the x dimension.\n        y : float\n            The height of the rectangle in the y dimension.\n        direction : str (either 'CW' or 'CCW') (default: 'CW')\n            Which direction to complete the rectangle in.\n        start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')\n            The start of the rectangle -  L/U = lower/upper, L/R = left/right\n            This assumes an origin in the lower left.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # trace a 10x10 clockwise square, starting in the lower left corner\n        &gt;&gt;&gt; g.rect(10, 10)\n\n        &gt;&gt;&gt; # 1x5 counterclockwise rect starting in the upper right corner\n        &gt;&gt;&gt; g.rect(1, 5, direction='CCW', start='UR')\n\n        \"\"\"\n        if direction == 'CW':\n            if start.upper() == 'LL':\n                self.move(y=y)\n                self.move(x=x)\n                self.move(y=-y)\n                self.move(x=-x)\n            elif start.upper() == 'UL':\n                self.move(x=x)\n                self.move(y=-y)\n                self.move(x=-x)\n                self.move(y=y)\n            elif start.upper() == 'UR':\n                self.move(y=-y)\n                self.move(x=-x)\n                self.move(y=y)\n                self.move(x=x)\n            elif start.upper() == 'LR':\n                self.move(x=-x)\n                self.move(y=y)\n                self.move(x=x)\n                self.move(y=-y)\n        elif direction == 'CCW':\n            if start.upper() == 'LL':\n                self.move(x=x)\n                self.move(y=y)\n                self.move(x=-x)\n                self.move(y=-y)\n            elif start.upper() == 'UL':\n                self.move(y=-y)\n                self.move(x=x)\n                self.move(y=y)\n                self.move(x=-x)\n            elif start.upper() == 'UR':\n                self.move(x=-x)\n                self.move(y=-y)\n                self.move(x=x)\n                self.move(y=y)\n            elif start.upper() == 'LR':\n                self.move(y=y)\n                self.move(x=-x)\n                self.move(y=-y)\n                self.move(x=x)\n\n    def round_rect(self, x, y, direction='CW', start='LL', radius=0, linearize=True):\n        r\"\"\" Trace a rectangle with the given width and height with rounded corners,\n            note that starting point is not actually in corner of rectangle.\n\n        Parameters\n        ----------\n        x : float\n            The width of the rectangle in the x dimension.\n        y : float\n            The height of the rectangle in the y dimension.\n        direction : str (either 'CW' or 'CCW') (default: 'CW')\n            Which direction to complete the rectangle in.\n        start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')\n            The start of the rectangle -  L/U = lower/upper, L/R = left/right\n            This assumes an origin in the lower left.\n        radius : radius of the corners of the rectangle\n\n        Examples\n        --------\n        &gt;&gt;&gt; # trace a 10x10 clockwise square with radius of 3, starting in the lower left corner\n        &gt;&gt;&gt; g.round_rect(10, 10, radius=3)\n\n        &gt;&gt;&gt; # 1x5 counterclockwise rect with radius of 2 starting in the upper right corner\n        &gt;&gt;&gt; g.round_rect(1, 5, direction='CCW', start='UR', radius=2)\n\n                                    ______________\n                                   /              \\\n                                  /                \\\n        starts here for 'UL' - &gt; |                  | &lt;- starts here for 'UR'\n                                 |                  |\n        starts here for 'LL' - &gt; |                  | &lt;- starts here for 'LR'\n                                  \\                /\n                                   \\______________/\n\n        \"\"\"\n        if direction == 'CW':\n            if start.upper() == 'LL':\n                self.move(y=y-2*radius)\n                self.arc(x=radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(x=x-2*radius)\n                self.arc(x=radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(y=-(y-2*radius))\n                self.arc(x=-radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(x=-(x-2*radius))\n                self.arc(x=-radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n            elif start.upper() == 'UL':\n                self.arc(x=radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(x=x-2*radius)\n                self.arc(x=radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(y=-(y-2*radius))\n                self.arc(x=-radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(x=-(x-2*radius))\n                self.arc(x=-radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(y=y-2*radius)\n            elif start.upper() == 'UR':\n                self.move(y=-(y-2*radius))\n                self.arc(x=-radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(x=-(x-2*radius))\n                self.arc(x=-radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(y=y-2*radius)\n                self.arc(x=radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(x=x-2*radius)\n                self.arc(x=radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n            elif start.upper() == 'LR':\n                self.arc(x=-radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(x=-(x-2*radius))\n                self.arc(x=-radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(y=y-2*radius)\n                self.arc(x=radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(x=x-2*radius)\n                self.arc(x=radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n                self.move(y=-(y-2*radius))\n        elif direction == 'CCW':\n            if start.upper() == 'LL':\n                self.arc(x=radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(x=x-2*radius)\n                self.arc(x=radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(y=y-2*radius)\n                self.arc(x=-radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(x=-(x-2*radius))\n                self.arc(x=-radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(y=-(y-2*radius))\n            elif start.upper() == 'UL':\n                self.move(y=-(y-2*radius))\n                self.arc(x=radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(x=x-2*radius)\n                self.arc(x=radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(y=y-2*radius)\n                self.arc(x=-radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(x=-(x-2*radius))\n                self.arc(x=-radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n            elif start.upper() == 'UR':\n                self.arc(x=-radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(x=-(x-2*radius))\n                self.arc(x=-radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(y=-(y-2*radius))\n                self.arc(x=radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(x=x-2*radius)\n                self.arc(x=radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(y=y-2*radius)\n            elif start.upper() == 'LR':\n                self.move(y=y-2*radius)\n                self.arc(x=-radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(x=-(x-2*radius))\n                self.arc(x=-radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(y=-(y-2*radius))\n                self.arc(x=radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n                self.move(x=x-2*radius)\n                self.arc(x=radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n\n    def meander(self, x, y, spacing, start='LL', orientation='x', tail=False,\n                minor_feed=None, color=(0,0,0,0.5), mode='auto'):\n        \"\"\" Infill a rectangle with a square wave meandering pattern. If the\n        relevant dimension is not a multiple of the spacing, the spacing will\n        be tweaked to ensure the dimensions work out.\n\n        Parameters\n        ----------\n        x : float\n            The width of the rectangle in the x dimension.\n        y : float\n            The height of the rectangle in the y dimension.\n        spacing : float\n            The space between parallel meander lines.\n        start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')\n            The start of the meander -  L/U = lower/upper, L/R = left/right\n            This assumes an origin in the lower left.\n        orientation : str ('x' or 'y') (default: 'x')\n        tail : Bool (default: False)\n            Whether or not to terminate the meander in the minor axis\n        minor_feed : float or None (default: None)\n            Feed rate to use in the minor axis\n        color : hex string or rgb(a) string\n            Specifies a color to be added to color history for viewing.\n        mode : str (either 'auto' or 'manual')\n            If set to auto (default value) will auto correct spacing to fit within x and y dimensions.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # meander through a 10x10 square with a spacing of 1mm starting in\n        &gt;&gt;&gt; # the lower left.\n        &gt;&gt;&gt; g.meander(10, 10, 1)\n\n        &gt;&gt;&gt; # 3x5 meander with a spacing of 1 and with parallel lines through y\n        &gt;&gt;&gt; g.meander(3, 5, spacing=1, orientation='y')\n\n        &gt;&gt;&gt; # 10x5 meander with a spacing of 2 starting in the upper right.\n        &gt;&gt;&gt; g.meander(10, 5, 2, start='UR')\n\n        \"\"\"\n        if start.upper() == 'UL':\n            x, y = x, -y\n        elif start.upper() == 'UR':\n            x, y = -x, -y\n        elif start.upper() == 'LR':\n            x, y = -x, y\n\n        # Major axis is the parallel lines, minor axis is the jog.\n        if orientation == 'x':\n            major, major_name = x, 'x'\n            minor, minor_name = y, 'y'\n        else:\n            major, major_name = y, 'y'\n            minor, minor_name = x, 'x'\n\n        if mode.lower() == 'auto':\n            actual_spacing = self._meander_spacing(minor, spacing)\n            if abs(actual_spacing) != spacing:\n                msg = ';WARNING! meander spacing updated from {} to {}'\n                self.write(msg.format(spacing, actual_spacing))\n                self.write(f\";\\t IF YOU INTENDED TO USE A SPACING OF {spacing:.4f} USE mode='manual'\")\n            spacing = actual_spacing\n        sign = 1\n\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        major_feed = self.speed\n        if not minor_feed:\n            minor_feed = self.speed\n\n        n_passes = int(self._meander_passes(minor, spacing))\n\n        for j in range(n_passes):\n            self.move(**{major_name: (sign * major), 'color': color})\n            if minor_feed != major_feed:\n                self.feed(minor_feed)\n            if (j &lt; n_passes-1):\n                self.move(**{minor_name: spacing, 'color': color})\n            if (j==n_passes-1) and ( tail==True ):\n                self.move(**{minor_name: spacing, 'color': color})\n\n            if minor_feed != major_feed:\n                self.feed(major_feed)\n            sign = -1 * sign\n\n        if was_absolute:\n            self.absolute()\n\n    def serpentine(self, L, n_lines, spacing, start='LL', orientation='x', color=(0,0,0,0.5)):\n        \"\"\" Generate a square wave meandering/serpentine pattern. Unlike [meander][mecode.main.G.meander],\n         will not tweak spacing dimension.\n\n        Parameters\n        ----------\n        L : float\n            Major axis dimension.\n        n_lines : int\n            The number of lines to generate\n        spacing : float\n            The space between parallel serpentine paths.\n        start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')\n            The start of the meander -  L/U = lower/upper, L/R = left/right\n            This assumes an origin in the lower left.\n        orientation : str ('x' or 'y') (default: 'x')\n        color : hex string or rgb(a) string\n            Specifies a color to be added to color history for viewing.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # meander through a 10x10 square with a spacing of 1mm starting in\n        &gt;&gt;&gt; # the lower left.\n        &gt;&gt;&gt; g.meander(10, 10, 1)\n\n        &gt;&gt;&gt; # 3x5 meander with a spacing of 1 and with parallel lines through y\n        &gt;&gt;&gt; g.meander(3, 5, spacing=1, orientation='y')\n\n        &gt;&gt;&gt; # 10x5 meander with a spacing of 2 starting in the upper right.\n        &gt;&gt;&gt; g.meander(10, 5, 2, start='UR')\n\n        \"\"\"\n        if orientation.lower() == 'x':\n            major, major_name = L, 'x'\n            minor, minor_name = spacing, 'y'\n        else:\n            major, major_name = L, 'y'\n            minor, minor_name = spacing, 'x'\n\n        sign_minor = +1\n        sign_major = +1\n        if start.upper() == 'UL':\n            sign_major = +1 if orientation.lower()=='x' else -1\n            sign_minor = -1 if orientation.lower()=='x' else +1\n        elif start.upper() == 'UR':\n            sign_major = -1\n            sign_minor = -1\n        elif start.upper() == 'LR':\n            sign_major = -1 if orientation.lower()=='x' else +1\n            sign_minor = +1 if orientation.lower()=='x' else -1\n\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        for j in range(n_lines):\n            self.move(**{major_name: sign_major*major, 'color': color})\n\n            if j &lt; (n_lines-1):\n                self.move(**{minor_name: sign_minor*minor, 'color': color})\n\n            sign_major = -1*sign_major\n\n        if was_absolute:\n            self.absolute()\n\n    def clip(self, axis='z', direction='+x', height=4, linearize=False):\n        \"\"\" Move the given axis up to the given height while arcing in the\n        given direction.\n\n        Parameters\n        ----------\n        axis : str (default: 'z')\n            The axis to move, e.g. 'z'\n        direction : str (either +-x or +-y) (default: '+x')\n            The direction to arc through\n        height : float (default: 4)\n            The height to end up at\n\n        Examples\n        --------\n        &gt;&gt;&gt; # move 'z' axis up 4mm while arcing through positive x\n        &gt;&gt;&gt; g.clip()\n\n        &gt;&gt;&gt; # move 'A' axis up 10mm while arcing through negative y\n        &gt;&gt;&gt; g.clip('A', height=10, direction='-y')\n\n        \"\"\"\n        secondary_axis = direction[1]\n        if height &gt; 0:\n            orientation = 'CW' if direction[0] == '-' else 'CCW'\n        else:\n            orientation = 'CCW' if direction[0] == '-' else 'CW'\n        radius = abs(height / 2.0)\n        kwargs = {\n            secondary_axis: 0,\n            axis: height,\n            'direction': orientation,\n            'radius': radius,\n            'linearize': linearize\n        }\n        self.arc(**kwargs)\n\n    def triangular_wave(self, x, y, cycles, start='UR', orientation='x'):\n        \"\"\" Perform a triangular wave.\n\n        Parameters\n        ----------\n        x : float\n            The length to move in x in one half cycle\n        y : float\n            The length to move in y in one half cycle\n        start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'UR')\n            The start of the zigzag direction.\n            This assumes an origin in the lower left, and move toward upper\n            right.\n        orientation : str ('x' or 'y') (default: 'x')\n\n        Examples\n        --------\n        &gt;&gt;&gt; # triangular wave for one cycle going 10 in x and 10 in y per half\n        &gt;&gt;&gt; # cycle.\n        &gt;&gt;&gt; # the lower left.\n        &gt;&gt;&gt; g.zigzag(10, 10, 1)\n\n        &gt;&gt;&gt; # triangular wave 4 cycles, going 3 in x and 5 in y per half cycle,\n        &gt;&gt;&gt; # oscillating along the y axis.\n        &gt;&gt;&gt; g.zigzag(3, 5, 4, orientation='y')\n\n        &gt;&gt;&gt; # triangular wave 2 cycles, going 10 in x and 5 in y per half cycle,\n        &gt;&gt;&gt; # oscillating along the x axis making the first half cycle towards\n        &gt;&gt;&gt; # the lower left corner of the movement area.\n        &gt;&gt;&gt; g.zigzag(10, 5, 2, start='LL')\n\n        \"\"\"\n        if start.upper() == 'UL':\n            x, y = -x, y\n        elif start.upper() == 'LL':\n            x, y = -x, -y\n        elif start.upper() == 'LR':\n            x, y = x, -y\n\n        # Major axis is the parallel lines, minor axis is the jog.\n        if orientation == 'x':\n            major, major_name = x, 'x'\n            minor, minor_name = y, 'y'\n        else:\n            major, major_name = y, 'y'\n            minor, minor_name = x, 'x'\n\n        sign = 1\n\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        for _ in range(int(cycles*2)):\n            self.move(**{minor_name: (sign * minor), major_name: major})\n            sign = -1 * sign\n\n        if was_absolute:\n            self.absolute()\n\n    def rect_spiral(self, n_turns, spacing, start='center', origin=(0,0), dwell=None, manual=False, **kwargs):\n        \"\"\" Performs a square spiral.\n\n        Parameters\n        ----------\n        n_turns : int\n            The number of spirals\n        spacing : float or iterable\n            The spacing between lines of the spiral. Spacing can be a tuple or list to specify (dx, dy) spacings.\n        start : str (either 'center', 'edge')\n            The location to start the spiral (default: 'center').\n        direction : str (either 'CW', 'CCW') #TODO: not being used right now\n            Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')\n        origin : tuple\n            Absolute coordinates of spiral center. Helpful when printing in absolute coordinates\n\n        Examples\n        --------\n\n        &gt;&gt;&gt; # TODO\n\n\n        \"\"\"\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        # d_F = spacing\n\n        if hasattr(spacing, '__iter__'):\n            dx = spacing[0]\n            dy = spacing[1]\n        else:\n            dx = dy = spacing\n\n        x_pts = [origin[0], dx]\n        y_pts = [origin[1], 0]\n\n        if hasattr(n_turns, '__iter__'):\n            turn_0 = n_turns[0]\n            turn_F = n_turns[1]\n        else:\n            turn_0 = 1\n            turn_F = n_turns\n\n        for j in range(1, turn_F + 1):\n            top_right = (dx*j, dy*j)\n            top_left = (-dx*j, dy*j)\n            bottom_left = (-dx*j, -dy*j)\n            bottom_right = (dx*j + dx, -dy*j)\n\n            x_pts.extend([top_right[0], top_left[0], bottom_left[0], bottom_right[0]])\n            y_pts.extend([top_right[1], top_left[1], bottom_left[1], bottom_right[1]])\n\n        x_pts = np.array(x_pts)\n        y_pts = np.array(y_pts)\n        # adjust last point to ensure spiral is a square\n        # TODO: if want adjustable spiral orientation / direction, will need to adjust this\n        x_pts[-1] -= dx\n\n        original_pts = (x_pts, y_pts)\n\n        if turn_0 &gt; 1:\n            x_pts = x_pts[4*(turn_0-1)::]\n            y_pts = y_pts[4*(turn_0-1)::]\n\n        if start == 'edge':\n            x_pts = x_pts[::-1]\n            y_pts = y_pts[::-1]\n\n        if self.is_relative:\n            x_pts = x_pts[1:] - x_pts[:-1]\n            y_pts = y_pts[1:] - y_pts[:-1]\n\n        if not manual:\n            for x_j, y_j in zip(x_pts, y_pts):\n                self.move(x_j, y_j, **kwargs)\n\n                if dwell is not None:\n                    self.dwell(dwell)\n\n        if was_absolute:\n            self.absolute()\n\n        if manual:\n            return x_pts, y_pts, original_pts\n\n    def square_spiral(self, n_turns, spacing, start='center', origin=(0,0), dwell=None, manual=False, **kwargs):\n        \"\"\" Performs a square spiral.\n\n        Parameters\n        ----------\n        n_turns : int\n            The number of spirals\n        spacing : float\n            The spacing between lines of the spiral.\n        start : str (either 'center', 'edge')\n            The location to start the spiral (default: 'center').\n        direction : str (either 'CW', 'CCW') #TODO: not being used right now\n            Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')\n        origin : tuple\n            Absolute coordinates of spiral center. Helpful when printing in absolute coordinates\n\n        Examples\n        --------\n\n        &gt;&gt;&gt; # TODO\n\n\n        \"\"\"\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        d_F = spacing\n\n        x_pts = [origin[0], d_F]\n        y_pts = [origin[1], 0]\n\n        if hasattr(n_turns, '__iter__'):\n            turn_0 = n_turns[0]\n            turn_F = n_turns[1]\n        else:\n            turn_0 = 1\n            turn_F = n_turns\n\n        for j in range(1, turn_F + 1):\n            top_right = (d_F*j, d_F*j)\n            top_left = (-d_F*j, d_F*j)\n            bottom_left = (-d_F*j, -d_F*j)\n            bottom_right = (d_F*j + d_F, -d_F*j)\n\n            x_pts.extend([top_right[0], top_left[0], bottom_left[0], bottom_right[0]])\n            y_pts.extend([top_right[1], top_left[1], bottom_left[1], bottom_right[1]])\n\n        x_pts = np.array(x_pts)\n        y_pts = np.array(y_pts)\n        # adjust last point to ensure spiral is a square\n        # TODO: if want adjustable spiral orientation / direction, will need to adjust this\n        x_pts[-1] -= d_F\n\n        original_pts = (x_pts, y_pts)\n\n        if turn_0 &gt; 1:\n            x_pts = x_pts[4*(turn_0-1)::]\n            y_pts = y_pts[4*(turn_0-1)::]\n\n        if start == 'edge':\n            x_pts = x_pts[::-1]\n            y_pts = y_pts[::-1]\n\n        if self.is_relative:\n            x_pts = x_pts[1:] - x_pts[:-1]\n            y_pts = y_pts[1:] - y_pts[:-1]\n\n        if not manual:\n            for x_j, y_j in zip(x_pts, y_pts):\n                self.move(x_j, y_j, **kwargs)\n\n                if dwell is not None:\n                    self.dwell(dwell)\n\n        if was_absolute:\n            self.absolute()\n\n        if manual:\n            return x_pts, y_pts, original_pts\n\n\n    def spiral(self, end_diameter, spacing, feedrate, start='center', direction='CW',\n                step_angle = 0.1, start_diameter = 0, center_position=None):\n        \"\"\" Performs an Archimedean spiral. Start by moving to the center of the spiral location\n        then use the 'start' argument to specify a starting location (either center or edge).\n\n        Parameters\n        ----------\n        end_diameter : float\n            The outer diameter of the spiral.\n        spacing : float\n            The spacing between lines of the spiral.\n        feedrate : float\n            Feedrate is the speed of the nozzle relative to the substrate\n        start : str (either 'center', 'edge')\n            The location to start the spiral (default: 'center').\n        direction : str (either 'CW', 'CCW')\n            Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')\n        step_angle : float\n            Resolution of the spiral in radians, smaller is higher resolution (default: 0.1).\n        start_diameter : float\n            The inner diameter of the spiral (default: 0).\n        center_position : list\n            Position of the absolute center of the spiral, useful when starting a spiral at the edge of a completed spiral\n\n        Examples\n        --------\n\n        &gt;&gt;&gt; # start first spiral, outer diameter of 20, spacing of 1, feedrate of 8\n        &gt;&gt;&gt; g.spiral(20,1,8)\n\n        &gt;&gt;&gt; # move to second spiral location and do similar spiral but start at edge\n        &gt;&gt;&gt; g.spiral(20,1,8,start='edge',center_position=[50,0])\n\n        &gt;&gt;&gt; # move to third spiral location, this time starting at edge but printing CCW\n        &gt;&gt;&gt; g.spiral(20,1,8,start='edge',direction='CCW',center_position=[50,50])\n\n        &gt;&gt;&gt; # move to fourth spiral location, starting at center again but printing CCW\n        &gt;&gt;&gt; g.spiral(20,1,8,direction='CCW',center_position=[0,50])\n\n        \"\"\"\n        start_spiral_turns = (start_diameter/2.0)/spacing\n        end_spiral_turns = (end_diameter/2.0)/spacing\n\n        #Use current position as center position if none is specified\n        if center_position is None:\n            center_position = [self._current_position['x'],self._current_position['y']]\n\n        #Keep track of whether currently in relative or absolute mode\n        was_relative = True\n        if self.is_relative:\n            self.absolute()\n        else:\n            was_relative = False\n\n        # SEE: https://www.comsol.com/blogs/how-to-build-a-parameterized-archimedean-spiral-geometry/\n        b = spacing/(2*math.pi)\n        t = np.arange(start_spiral_turns*2*math.pi, end_spiral_turns*2*math.pi, step_angle)\n\n        #Add last final point to ensure correct outer diameter\n        t = np.append(t,end_spiral_turns*2*math.pi)\n        if start == 'center':\n            pass\n        elif start == 'edge':\n            t = t[::-1]\n        else:\n            raise Exception(\"Must either choose 'center' or 'edge' for starting position.\")\n\n        #Move to starting positon\n        if (direction == 'CW' and start == 'center') or (direction == 'CCW' and start == 'edge'):\n            x_move = -t[0]*b*math.cos(t[0])+center_position[0]\n        elif (direction == 'CCW' and start == 'center') or (direction == 'CW' and start == 'edge'):\n            x_move = t[0]*b*math.cos(t[0])+center_position[0]\n        else:\n            raise Exception(\"Must either choose 'CW' or 'CCW' for spiral direction.\")\n        y_move = t[0]*b*math.sin(t[0])+center_position[1]\n        self.move(x_move, y_move)\n\n        #Start writing moves\n        self.feed(feedrate)\n\n        for step in t[1:]:\n            if (direction == 'CW' and start == 'center') or (direction == 'CCW' and start == 'edge'):\n                x_move = -step*b*math.cos(step)+center_position[0]\n            elif (direction == 'CCW' and start == 'center') or (direction == 'CW' and start == 'edge'):\n                x_move = step*b*math.cos(step)+center_position[0]\n            else:\n                raise Exception(\"Must either choose 'CW' or 'CCW' for spiral direction.\")\n            y_move = step*b*math.sin(step)+center_position[1]\n            self.move(x_move, y_move)\n\n        #Set back to relative mode if it was previsously before command was called\n        if was_relative:\n                self.relative()\n\n    def gradient_spiral(self, end_diameter, spacing, gradient, feedrate, flowrate,\n                start='center', direction='CW', step_angle = 0.1, start_diameter = 0,\n                center_position=None, dead_delay=0):\n        \"\"\" Identical motion to the regular spiral function, but with the control of two syringe pumps to enable control over\n            dielectric properties over the course of the spiral. Starting with simply hitting certain dielectric constants at\n            different values along the radius of the spiral.\n\n        Parameters\n        ----------\n        end_diameter : float\n            The outer diameter of the spiral.\n        spacing : float\n            The spacing between lines of the spiral.\n        gradient : str\n            Functioning defining the ink concentration along the radius of the spiral\n        feedrate : float\n            Feedrate is the speed of the nozzle relative to the substrate\n        flowrate : float\n            Flowrate is a measure of the amount of ink dispensed per second by the syringe pump\n        start : str (either 'center', 'edge')\n            The location to start the spiral (default: 'center').\n        direction : str (either 'CW', 'CCW')\n            Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')\n        step_angle : float\n            Resolution of the spiral in radians, smaller is higher resolution (default: 0.1).\n        start_diameter : float\n            The inner diameter of the spiral (default: 0).\n        center_position : list\n            Position of the absolute center of the spiral, useful when starting a spiral at the edge of a completed spiral\n        dead_delay : float\n            Printing composition offset caused by the dead volume of the nozzle which creates a delayed\n            effect between the syringe pumps and the actual composition of the ink exiting the nozzle.\n\n        Examples\n        --------\n        &gt;&gt;&gt; g.gradient_spiral(start_diameter=7.62, #mm\n        ...     end_diameter=30.48, #mm\n        ...     spacing=1, #mm\n        ...     feedrate=8, #mm/s\n        ...     flowrate=2/60.0, #rot/s\n        ...     start='edge', #'edge' or 'center'\n        ...     direction='CW', #'CW' or 'CCW'\n        ...     gradient=\"-0.322*r**2 - 6.976*r + 131.892\") #Any function\n        \"\"\"\n\n        import sympy as sy\n\n        def calculate_extrusion_values(radius, length, feed = feedrate, flow = flowrate, formula = gradient, delay = dead_delay, spacing = spacing, start = start, outer_radius = end_diameter/2.0, inner_radius=start_diameter/2.0):\n            \"\"\"Calculates the extrusion values for syringe pumps A &amp; B during a move along the print path.\n            \"\"\"\n\n            def exact_length(r0,r1,h):\n                \"\"\"Calculates the exact length of an archimedean given the spacing, inner and outer radii.\n                SEE: http://www.giangrandi.ch/soft/spiral/spiral.shtml\n\n                Parameters\n                ----------\n                r0 : float\n                    The inner diameter of the spiral.\n                r1 : float\n                    The outer diameter of the spiral.\n                h  : float\n                    The spacing of the spiral.\n                \"\"\"\n                #t0 &amp; t1 are the respective diameters in terms of radians along the spiral.\n                t0 = 2*math.pi*r0/h\n                t1 = 2*math.pi*r1/h\n                return h/(2.0*math.pi)*(t1/2.0*math.sqrt(t1**2+1)+1/2.0*math.log(t1+math.sqrt(t1**2+1))-t0/2.0*math.sqrt(t0**2+1)-1/2.0*math.log(t0+math.sqrt(t0**2+1)))\n\n\n            def exact_radius(r_0,h,L):\n                \"\"\"Calculates the exact outer radius of an archimedean given the spacing, inner radius and the length.\n                SEE: http://www.giangrandi.ch/soft/spiral/spiral.shtml\n\n                Parameters\n                ----------\n                r0 : float\n                    The inner radius of the spiral.\n                h  : float\n                    The spacing of the spiral.\n                L  : float\n                    The length of the spiral.\n                \"\"\"\n                d_0 = r_0*2\n                if d_0 == 0:\n                    d_0 = 1e-10\n\n                def exact_length(d0,d1,h):\n                    \"\"\"Calculates the exact length of an archimedean given the spacing, inner and outer diameters.\n                    SEE: http://www.giangrandi.ch/soft/spiral/spiral.shtml\n\n                    Parameters\n                    ----------\n                    d0 : float\n                        The inner diameter of the spiral.\n                    d1 : float\n                        The outer diameter of the spiral.\n                    h  : float\n                        The spacing of the spiral.\n                    \"\"\"\n                    #t0 &amp; t1 are the respective diameters in terms of radians along the spiral.\n                    t0 = math.pi*d0/h\n                    t1 = math.pi*d1/h\n                    return h/(2.0*math.pi)*(t1/2.0*math.sqrt(t1**2+1)+1/2.0*math.log(t1+math.sqrt(t1**2+1))-t0/2.0*math.sqrt(t0**2+1)-1/2.0*math.log(t0+math.sqrt(t0**2+1)))\n\n                def exact_length_derivative(d,h):\n                    \"\"\"Calculates the derivative of the exact length of an archimedean at a given diameter and spacing.\n                    SEE: http://www.giangrandi.ch/soft/spiral/spiral.shtml\n\n                    Parameters\n                    ----------\n                    d : float\n                        The diameter point of interest in the spiral.\n                    h  : float\n                        The spacing of the spiral.\n                    \"\"\"\n                    #t is diameter of interest in terms of radians along the spiral.\n                    t = math.pi*d/h\n                    dl_dt = h/(2.0*math.pi)*((2*t**2+1)/(2*math.sqrt(t**2+1))+(t+math.sqrt(t**2+1))/(2*t*math.sqrt(t**2+1)+2*t**2+2))\n                    dl_dd = h*dl_dt/math.pi\n                    return dl_dd\n\n                #Approximate radius (for first guess)\n                N = (h-d_0+math.sqrt((d_0-h)**2+4*h*L/math.pi))/(2*h)\n                D_1 = 2*N*h + d_0\n                tol = 1e-10\n\n                #Use Newton's Method to iterate until within tolerance\n                while True:\n                    f_df_dt = (exact_length(d_0,D_1,h)-L)/1000/exact_length_derivative(D_1,h)\n                    if f_df_dt &lt; tol:\n                        break\n                    D_1 -= f_df_dt\n                return D_1/2\n\n            def rollover(val,limit,mode):\n                if val &lt; limit:\n                    if mode == 'max':\n                        return val\n                    elif mode == 'min':\n                        return limit+(limit-val)\n                    else:\n                        raise ValueError(\"'{}' is an incorrect selection for the mode\".format(mode))\n                else:\n                    if mode == 'max':\n                        return limit-(val-limit)\n                    elif mode == 'min':\n                        return val\n                    else:\n                        raise ValueError(\"'{}' is an incorrect selection for the mode\".format(mode))\n\n            def minor_fraction_calc(e,e_a=300,e_b=2.3,n=0.102,sr=0.6):\n                \"\"\"Calculates the minor fraction (fraction of part b) required to achieve the\n                specified dielectric value\n\n                Parameters\n                ----------\n                e : float\n                    Dielectric value of interest\n                e_a  : float\n                    Dielectric value of part a\n                e_b. : float\n                    Dielectric value of part b\n                n  : float\n                    Morphology factor\n                sr : float\n                    Fraction of SrTi03 in part a\n                \"\"\"\n                return 1 - ((e-e_b)*((n-1)*e_b-n*e_a))/(sr*(e_b-e_a)*(n*(e-e_b)+e_b))\n\n            \"\"\"\n            This is a key line of the extrusion values calculations.\n            It starts off by calculating the exact length along the spiral for the current\n            radius, then adds/subtracts on the dead volume delay (in effect looking into the\n            future path) to this length, then recalculates the appropriate radius at this new\n            postiion. This is value is then used in the gradient function to determine the minor\n            fraction of the mixed elements. Note that if delay is 0, then this line will have no\n            effect. If the spiral is moving outwards it must add the dead volume delay, whereas if\n            the spiral is moving inwards, it must subtract it.\n\n            \"\"\"\n            if start == 'center':\n                offset_radius = exact_radius(0,spacing,rollover(exact_length(0,radius,spacing)+delay,exact_length(0,outer_radius,spacing),'max'))\n            else:\n                offset_radius = exact_radius(0,spacing,rollover(exact_length(0,radius,spacing)-delay,exact_length(0,inner_radius,spacing),'min'))\n\n            expr = sy.sympify(formula)\n            r = sy.symbols('r')\n            minor_fraction = np.clip(minor_fraction_calc(float(expr.subs(r,offset_radius))),0,1)\n            line_flow = length/float(feed)*flow\n            return [minor_fraction*line_flow,(1-minor_fraction)*line_flow,minor_fraction]\n\n        #End of calculate_extrusion_values() function\n\n        start_spiral_turns = (start_diameter/2.0)/spacing\n        end_spiral_turns = (end_diameter/2.0)/spacing\n\n        #Use current position as center position if none is specified\n        if center_position is None:\n            center_position = [self._current_position['x'],self._current_position['y']]\n\n        #Keep track of whether currently in relative or absolute mode\n        was_relative = True\n        if self.is_relative:\n            self.absolute()\n        else:\n            was_relative = False\n\n        #SEE: https://www.comsol.com/blogs/how-to-build-a-parameterized-archimedean-spiral-geometry/\n        b = spacing/(2*math.pi)\n        t = np.arange(start_spiral_turns*2*math.pi, end_spiral_turns*2*math.pi, step_angle)\n\n        #Add last final point to ensure correct outer diameter\n        t = np.append(t,end_spiral_turns*2*math.pi)\n        if start == 'center':\n            pass\n        elif start == 'edge':\n            t = t[::-1]\n        else:\n            raise Exception(\"Must either choose 'center' or 'edge' for starting position.\")\n\n        #Move to starting positon\n        if (direction == 'CW' and start == 'center') or (direction == 'CCW' and start == 'edge'):\n            x_move = -t[0]*b*math.cos(t[0])+center_position[0]\n        elif (direction == 'CCW' and start == 'center') or (direction == 'CW' and start == 'edge'):\n            x_move = t[0]*b*math.cos(t[0])+center_position[0]\n        else:\n            raise Exception(\"Must either choose 'CW' or 'CCW' for spiral direction.\")\n        y_move = t[0]*b*math.sin(t[0])+center_position[1]\n        self.move(x_move, y_move)\n\n        #Start writing moves\n        self.feed(feedrate)\n        syringe_extrusion = np.array([0.0,0.0])\n\n        #Zero a &amp; b axis before printing, we do this so it can easily do multiple layers without quickly jumping back to 0\n        #Would likely be useful to change this to relative coordinates at some point\n        self.write('G92 a0 b0')\n\n        for step in t[1:]:\n            if (direction == 'CW' and start == 'center') or (direction == 'CCW' and start == 'edge'):\n                x_move = -step*b*math.cos(step)+center_position[0]\n            elif (direction == 'CCW' and start == 'center') or (direction == 'CW' and start == 'edge'):\n                x_move = step*b*math.cos(step)+center_position[0]\n            else:\n                raise Exception(\"Must either choose 'CW' or 'CCW' for spiral direction.\")\n            y_move = step*b*math.sin(step)+center_position[1]\n\n            radius_pos = np.sqrt((self._current_position['x']-center_position[0])**2 + (self._current_position['y']-center_position[1])**2)\n            line_length = np.sqrt((x_move-self._current_position['x'])**2 + (y_move-self._current_position['y'])**2)\n            extrusion_values = calculate_extrusion_values(radius_pos,line_length)\n            syringe_extrusion += extrusion_values[:2]\n            self.move(x_move, y_move, a=syringe_extrusion[0],b=syringe_extrusion[1],color=extrusion_values[2])\n\n        #Set back to relative mode if it was previsously before command was called\n        if was_relative:\n                self.relative()\n\n    def purge_meander(self, x, y, spacing, volume_fraction, flowrate, start='LL', orientation='x',\n            tail=False, minor_feed=None):\n        self.write('FREERUN a {}'.format(flowrate*volume_fraction))\n        self.write('FREERUN b {}'.format(flowrate*(1-volume_fraction)))\n        self.meander(x, y, spacing, start=start, orientation=orientation,\n            tail=tail, minor_feed=minor_feed)\n        self.write('FREERUN a 0')\n        self.write('FREERUN b 0')\n\n    def log_pile(self, L, W, H, RW, D_N, print_speed, com_ports, P, print_height=None, lead_in=0, dwell=0, jog_speed=10, jog_height=5):\n        \"\"\" A solution for a 90\u00b0 log pile lattice\n\n        Parameters\n        ----------\n        L : float\n            Length of log pile base\n        W : float\n            Width of log pile base\n        H : float\n            Height of log pile base\n        RW : float\n            Road width - spacing between filament centers\n        D_N : float\n            Nozzle diameter\n        print_speed : float\n            Printing speed\n        com_ports : dict\n            Dictionary of com_ports for pressure `P` and omnicure `UV`.\n        P : float\n            Printing pressure\n        print_height : float\n            Spacing between z-layers. If not provided, the default is 80% of `D_N` to provide better adhesion\n\n        Examples\n        --------\n\n        Printing a 10 mm (L) x 15 mm (W) x 5 mm (H) log pile with a road width of 1.4 mm and nozzle size of 0.7 mm (700 um) extruding at 55 psi pressure via com_port 5\n        &gt;&gt;&gt; g.log_pile(10, 15, 1.4, 0.7, 1, {'P': 5}, 55)\n\n        !!! note\n\n            Currently, this assumes you are using a pressure-based printing method (e.g., Nordson).\n            In the next version, this will be changed so that any arbitrary extruding source can be used.\n\n        \"\"\"\n        COLORS = {\n            'pre': (1,1,1),#(1,0,0,0),\n            'post': (1,1,1),#(1,0,0,0),\n            'even': (0,0,0, 1),\n            'odd': (0,0,0, 1),\n            'offset': (1,1,1,0)\n            # 'post': (25/255,138/255,72/255,0.3)\n            # 'even': (45/255, 36/255, 66/255, 1),\n            # 'odd': (248/255, 214/255, 65/255, 1)\n        }\n\n        dz =  D_N*0.8 if print_height is None else print_height # [mm] z-layer spacing\n\n        z_layers = int(H / dz)\n        n_lines_L = int(np.floor(W/RW + 1))\n        n_lines_W = int(np.floor(L/RW + 1))\n\n        offset_L = L - (n_lines_W-1)*RW\n        offset_W = W - (n_lines_L-1)*RW\n        extra_offset = 5 # mm\n\n        print(f'n_lines_L={n_lines_L:.1f} and offset_L={offset_L:.3f}')\n        print(f'n_lines_W={n_lines_W:.1f} and offset_W={offset_W:.3f}')\n        print(f'RW = {RW:.3f} = {RW/D_N:.3f}*d_N')\n        print(f'z_layers = {z_layers:.1f}')\n        print(f'rho = {2*D_N/ RW :.3f}')\n\n        '''HELPER FUNCTIONS'''\n\n        def initial_offset(start, orientation, offset):\n            # LL\n            if start == 'LL' and orientation == 'x':\n                self.move(y=+offset/2, color=COLORS['pre'])\n            elif start == 'LL' and orientation == 'y':\n                self.move(x=+offset/2, color=COLORS['pre'])\n\n            # UL\n            elif start == 'UL' and orientation == 'x':\n                self.move(y=-offset/2, color=COLORS['pre'])\n            elif start == 'UL' and orientation == 'y':\n                self.move(x=+offset/2, color=COLORS['pre'])\n\n            # UR\n            elif start == 'UR' and orientation == 'x':\n                self.move(y=-offset/2, color=COLORS['pre'])\n            elif start == 'UR' and orientation == 'y':\n                self.move(x=-offset/2, color=COLORS['pre'])\n\n            # LR\n            elif start == 'LR' and orientation == 'x':\n                self.move(y=+offset/2, color=COLORS['pre'])\n            elif start == 'LR' and orientation == 'y':\n                self.move(x=-offset/2, color=COLORS['pre'])\n\n        def post_offset(next_start, next_orientation, offset):\n            # LL\n            if next_start == 'LL' and next_orientation == 'x':\n                self.move(y=-extra_offset, color=COLORS['post'])\n                self.move(x=-offset/2, color=COLORS['offset'])\n                self.move(y=extra_offset, color=COLORS['post'])\n            elif next_start == 'LL' and next_orientation == 'y':\n                self.move(x=-extra_offset, color=COLORS['post'])\n                self.move(y=-offset/2, color=COLORS['offset'])\n                self.move(x=-extra_offset, color=COLORS['post'])\n\n            # UL\n            elif next_start == 'UL' and next_orientation == 'x':\n                self.move(y=extra_offset, color=COLORS['post'])\n                self.move(x=+offset/2, color=COLORS['offset'])\n                self.move(y=-extra_offset, color=COLORS['post'])\n            elif next_start == 'UL' and next_orientation == 'y':\n                self.move(x=-extra_offset, color=COLORS['post'])\n                self.move(y=+offset/2, color=COLORS['offset'])\n                self.move(x=extra_offset, color=COLORS['post'])\n\n            # UR\n            elif next_start == 'UR' and next_orientation == 'x':\n                self.move(y=extra_offset, color=COLORS['post'])\n                self.move(x=+offset/2, color=COLORS['offset'])\n                self.move(y=-extra_offset, color=COLORS['post'])\n            elif next_start == 'UR' and next_orientation == 'y':\n                self.move(x=extra_offset, color=COLORS['post'])\n                self.move(y=+offset/2, color=COLORS['offset'])\n                self.move(x=-extra_offset, color=COLORS['post'])\n\n            # LR\n            elif next_start == 'LR' and next_orientation == 'x':\n                self.move(y=-extra_offset, color=COLORS['post'])\n                self.move(x=+offset/2, color=COLORS['offset'])\n                self.move(y=extra_offset, color=COLORS['post'])\n            elif next_start == 'LR' and next_orientation == 'y':\n                self.move(x=extra_offset, color=COLORS['post'])\n                self.move(y=-offset/2, color=COLORS['offset'])\n                self.move(x=-extra_offset, color=COLORS['post'])\n\n            self.write('G92 X0 Y0')\n        self.write('; &gt;&gt;&gt; CHANGE PRINT SPEED IN THE FOLLOWING LINE ([=] mm/s) &lt;&lt;&lt;')\n        self.feed(print_speed)\n        self.write('; &gt;&gt;&gt; CAN CHANGE LEAD IN LENGTH HERE &lt;&lt;&lt;')\n        self.move(x=lead_in, color=(1,0,0,0.5)) # lead in\n\n        self.write('; &gt;&gt;&gt; CHANGE PRINT PRINT PRESSURE IN FOLLOWING LINE (0 -&gt; 100, res=0.1) &lt;&lt;&lt;')\n        self.set_pressure(com_ports['P'], P)\n\n        self.toggle_pressure(com_ports['P'])   # ON\n        self.write('; &gt;&gt;&gt; CHANGE INITIAL DWELL IN THE FOLLOWING LINE ([=] seconds) &lt;&lt;&lt;')\n        self.dwell(dwell)\n\n        n_lines_list = [n_lines_L, n_lines_W]\n\n        ''' START '''\n        orientations = ['x','y']\n        for j in range(z_layers):\n            color = COLORS['even'] if j%2==0 else COLORS['odd']\n            n_lines_local = n_lines_list[j%2]\n            offset_local = offset_W if j%2==0 else offset_L\n\n            # if both even-even or odd-odd\n            if n_lines_list[0]%2 == n_lines_list[1]%2:\n                if n_lines_local % 2 == 0: # if even\n                    start_list = ['LL', 'UL', 'UR', 'LR']\n                else:\n                    # orientations = ['x','y']\n                    start_list = ['LL', 'UR']*2\n            # if even-odd\n            elif n_lines_list[0]%2 ==0 and n_lines_list[1]%2==1:\n                start_list = ['LL', 'UL', 'LR', 'UR']\n            # if odd-even\n            elif n_lines_list[0]%2 ==1 and n_lines_list[1]%2==0:\n                start_list = ['LL', 'UR', 'UL', 'LR']\n\n\n            self.write(f'; &gt;&gt;&gt;  START LAYER #{j+1} &lt;&lt;&lt;')\n            start = start_list[j%4]\n            orientation = orientations[j%2]\n\n            next_start = start_list[(j+1)%4]\n            next_orientation = orientations[(j+1)%2]\n\n            initial_offset(start, orientation, offset_local)\n\n            # print(start,orientation, ' --&gt; ', next_start, next_orientation)\n\n            if j%2==0: # runs first\n                # print(f'&gt; serpentine from {start} towards {orientation}')\n                self.serpentine(L, n_lines_local, RW, start, orientation, color=color)\n            else:\n                # print(f'&gt; serpentine from {start} towards {orientation}')\n                self.serpentine(W, n_lines_local, RW, start, orientation, color=color)\n\n            post_offset(next_start, next_orientation, offset_local)\n\n            self.move(z=+dz)\n            self.write(f'; &gt;&gt;&gt;  END LAYER #{j+1} &lt;&lt;&lt;')\n\n            ''' STOP '''\n\n            self.toggle_pressure(com_ports['P'])   # OFF\n\n            # move away from lattice\n            self.write('; MOVE AWAY FROM PRINT')\n            self.feed(jog_speed)\n            self.move(z=jog_height)\n            self.abs_move(0, 0)\n            self.move(z=-jog_height - z_layers*dz)\n\n    # AeroTech Specific Functions  ############################################\n\n    def get_axis_pos(self, axis):\n        \"\"\" Gets the current position of the specified `axis`.\n        \"\"\"\n        cmd = 'AXISSTATUS({}, DATAITEM_PositionFeedback)'.format(axis.upper())\n        pos = self.write(cmd)\n        return float(pos)\n\n    def set_cal_file(self, path):\n        \"\"\" Dynamically applies the specified calibration file at runtime.\n\n        Parameters\n        ----------\n        path : str\n            The path specifying the aerotech calibration file.\n\n        \"\"\"\n        self.write(r'LOADCALFILE \"{}\", 2D_CAL'.format(path))\n\n    def toggle_pressure(self, com_port):\n        \"\"\" Toggles (On/Off) Nordson Ultimus V Pressure Controllers.\n\n        Parameters\n        ----------\n        com_port : int\n            The com port to communicate over RS-232\n\n        Examples\n        --------\n        &gt;&gt;&gt; #Turn on pressure on com 3\n        &gt;&gt;&gt; g.toggle_pressure(3)\n\n        \"\"\"\n        self.write('Call togglePress P{}'.format(com_port))\n\n        if com_port not in self.extrusion_state.keys():\n            self.extrusion_state[com_port] = {'printing': True, 'value': 1}\n        # if extruding source HAS been specified\n        else:\n            self.extrusion_state[com_port]['printing'] = not self.extrusion_state[com_port]['printing']\n\n        # legacy code\n        if self.extruding[0] == com_port:\n            self.extruding = [com_port, not self.extruding[1], self.extruding[2] if not self.extruding[1] else 0]\n        else:\n            self.extruding = [com_port, True, self.extruding[2]]\n\n    def set_pressure(self, com_port, value):\n        \"\"\" Sets pressure on Nordson Ultimus V Pressure Controllers.\n\n        Parameters\n        ----------\n        com_port : int\n            The com port to communicate over RS-232.\n        value : float\n            The pressure value to set.\n        Examples\n        --------\n        &gt;&gt;&gt; #Set pressure on com 3 to 50.\n        &gt;&gt;&gt; g.set_pressure(com_port=3, value=50)\n\n        \"\"\"\n\n        if com_port not in self.extrusion_state.keys():\n            self.extrusion_state[com_port] = {'printing': False, 'value': round(value, 1)}\n        else:\n            self.extrusion_state[com_port] = {\n                'printing': self.extrusion_state[com_port]['printing'],\n                'value':  round(value, 1)\n            }\n\n        # legacy code\n        if self.extruding[0] == com_port:\n            self.extruding = [com_port, self.extruding[1], value if self.extruding else 0]\n        else:\n            self.extruding = [com_port, self.extruding[1], value if self.extruding else 0]\n        self.write(f'Call setPress P{com_port} Q{value:.1f}')\n\n    def linear_actuator_on(self, speed, dispenser):\n        ''' Sets Aerotech (or similar) linear actuator speed and ON.\n\n        Parameters\n        ----------\n        speed : float\n            The linear actuator speed value to set [in local units].\n        dispenser : int or str\n            The linear actuator number (int) or full custom name (str).\n        Examples\n        --------\n        &gt;&gt;&gt; # Set extrusion speed to 3 mm/s on dispenser 2\n        &gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser=2)\n\n        &gt;&gt;&gt; # Set custom dispenser name to `PDISP22`\n        &gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser='PDISP22')\n        '''\n\n        if str(dispenser).isdigit():\n            self.write(f'FREERUN PDISP{dispenser:d} {speed:.6f}')\n        else:\n            self.write(f'FREERUN {dispenser} {speed:.6f}')\n\n        if dispenser not in self.extrusion_state.keys():\n            self.extrusion_state[dispenser] = {'printing': True, 'value': f'{speed:.6f}'}\n        # if extruding source HAS been specified\n        else:\n            self.extrusion_state[dispenser] = {'printing': True, 'value': f'{speed:.6f}'}\n\n        # legacy code\n        self.extruding = [dispenser, True]\n\n    def linear_actuator_off(self, dispenser):\n        ''' Turn Aerotech (or similar) linear actuator OFF.\n\n        Parameters\n        ----------\n        dispenser : int or str\n            The linear actuator number (int) or full custom name (str).\n        Examples\n        --------\n        &gt;&gt;&gt; # Turn linear actuator `PDISP2` off\n        &gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser='PDISP2')\n        '''\n        if str(dispenser).isdigit():\n            self.write(f'FREERUN PDISP{dispenser:d} STOP')\n        else:\n            self.write(f'FREERUN {dispenser} STOP')\n\n        if dispenser not in self.extrusion_state.keys():\n            self.extrusion_state[dispenser] = {'printing': False, 'value': 0}\n        # if extruding source HAS been specified\n        else:\n            self.extrusion_state[dispenser] = {'printing': False, 'value': 0}\n\n        # legacy code\n\n        self.extruding = [dispenser, False]\n\n    def set_vac(self, com_port, value):\n        \"\"\" Same as [set_pressure][mecode.main.G.set_pressure] method, but for vacuum.\n        \"\"\"\n        self.write('Call setVac P{} Q{}'.format(com_port, value))\n\n    def set_valve(self, num, value):\n        \"\"\" Sets a digital output state (typically for valve).\n\n        Parameters\n        ----------\n        num : int\n            The com port to communicate over RS-232.\n        value : bool\n            On or off (1 or 0).\n        Examples\n        --------\n        &gt;&gt;&gt; #Turn on valve 2\n        &gt;&gt;&gt; g.set_valve(num=2, value=1)\n\n        \"\"\"\n        self.write('$DO{}.0={}'.format(num, value))\n\n    def omni_on(self, com_port):\n        \"\"\" Opens the iris for the omnicure.\n\n        Parameters\n        ----------\n        com_port : int\n            The com port to communicate over RS-232\n\n        Examples\n        --------\n        &gt;&gt;&gt; #Turn on omnicure on com 3.\n        &gt;&gt;&gt; g.omni_on(3)\n\n        \"\"\"\n        self.write('Call omniOn P{}'.format(com_port))\n\n    def omni_off(self, com_port):\n        \"\"\" Opposite to omni_on.\n        \"\"\"\n        self.write('Call omniOff P{}'.format(com_port))\n\n    def omni_intensity(self, com_port, value, cal=False):\n        \"\"\" Sets the intensity of the omnicure.\n\n        Parameters\n        ----------\n        com_port : int\n            The com port to communicate over RS-232.\n        value : float\n            The intensity value to set.\n        cal : bool\n            Whether the omnicure is calibrated or not.\n        Examples\n        --------\n        &gt;&gt;&gt; #Set omnicure intensity on com 3 to 50%.\n        &gt;&gt;&gt; g.omni_intensity(com_port=3, value=50)\n\n        \"\"\"\n\n        if cal:\n            command = 'SIR{:.2f}'.format(value)\n            data = self.calc_CRC8(command)\n            self.write('$strtask4=\"{}\"'.format(data))\n        else:\n            command = 'SIL{:.0f}'.format(value)\n            data = self.calc_CRC8(command)\n            self.write('$strtask4=\"{}\"'.format(data))\n        self.write('Call omniSetInt P{}'.format(com_port))\n\n    def set_alicat_pressure(self, com_port, value):\n        \"\"\" Same as [set_pressure][mecode.main.G.set_pressure] method, but for Alicat controller.\n        \"\"\"\n        extruder_id = f'alicat_com_port{com_port}'\n        if extruder_id not in self.extrusion_state.keys():\n            self.extrusion_state[extruder_id] = {'printing': True, 'value': f'{value:.6f}'}\n        # if extruding source HAS been specified\n        else:\n            self.extrusion_state[extruder_id] = {'printing': True, 'value': f'{value:.6f}'}\n\n        self.write('Call setAlicatPress P{} Q{}'.format(com_port, value))\n\n    def run_pump(self, com_port):\n        '''Run pump with internally stored settings.\n            Note: to run a pump, first call `set_rate` then call `run`'''\n\n        extruder_id = f'HApump_com_port{com_port}'\n        if extruder_id not in self.extrusion_state.keys():\n            self.extrusion_state[extruder_id] = {'printing': True, 'value': 1}\n        # if extruding source HAS been specified\n        else:\n            self.extrusion_state[extruder_id] = {'printing': True, 'value': 1}\n\n        self.write(f'Call runPump P{com_port}')\n\n        self.extruding = [com_port, True, 1]\n\n    def stop_pump(self, com_port):\n        '''Stops the pump'''\n\n        extruder_id = f'HApump_com_port{com_port}'\n        if extruder_id not in self.extrusion_state.keys():\n            self.extrusion_state[extruder_id] = {'printing': False}#, 'value': 0}\n        # if extruding source HAS been specified\n        else:\n            self.extrusion_state[extruder_id] = {'printing': False}#, 'value': 0}\n\n        self.write(f'Call stopPump P{com_port}')\n\n        self.extruding = [com_port, False, 0]\n\n\n    def calc_CRC8(self,data):\n        CRC8 = 0\n        for letter in list(bytearray(data, encoding='utf-8')):\n            for i in range(8):\n                if (letter^CRC8)&amp;0x01:\n                    CRC8 ^= 0x18\n                    CRC8 &gt;&gt;= 1\n                    CRC8 |= 0x80\n                else:\n                    CRC8 &gt;&gt;= 1\n                letter &gt;&gt;= 1\n        return data +'{:02X}'.format(CRC8)\n\n\n    def calc_print_time(self):\n        print(f'''\\n; Approximate print time:\n; \\t{self.print_time:.3f} seconds\n; \\t{self.print_time/60:.1f} min\n; \\t{self.print_time/60/60:.1f} hrs\n''')\n\n    # ROS3DA Functions  #######################################################\n\n\n    def line_frequency(self,freq,padding,length,com_port,pressure,travel_feed):\n        \"\"\" Prints a line with varying on/off frequency.\n\n        Parameters\n        ----------\n        frequency : float\n            The length to move in x in one half cycle\n        \"\"\"\n\n        # Switch to relative if in absolute, but keep track of state\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        # Use velocity on, required for switching like this\n        self.write(\"VELOCITY ON\")\n\n        print_height = np.copy(self._current_position['z'])\n        print_feed = np.copy(self.speed)\n\n        self.set_pressure(com_port,pressure)\n        for f in freq:\n            # freq is in hz, ie 1/s. Thus dist = (m/s)/(1/s) = m\n            dist = print_feed/f\n            switch_points = np.arange(length+dist,step=dist)\n            if len(switch_points)%2:\n                switch_points = switch_points[:-1]\n            for point in switch_points:\n                self.toggle_pressure(com_port)\n                self.move(x=dist)\n\n            #Move to push into substrate\n            self.move(z=-print_height)\n            self.feed(travel_feed)\n            self.move(z=print_height+5)\n\n            if f != freq[-1]:\n                self.move(x=-len(switch_points)*dist,y=padding)\n                self.move(z=-5)\n                self.feed(print_feed)\n\n        # Switch back to velocity off\n        self.write(\"VELOCITY OFF\")\n        # Switch back to absolute if it was in absolute\n        if was_absolute:\n            self.absolute()\n\n        return [length,padding*(len(freq)-1)]\n\n    def line_width(self,padding,width,com_port,pressures,spacing,travel_feed):\n        \"\"\" Prints meanders of varying spacing with different pressures.\n\n        Parameters\n        ----------\n        frequency : float\n            The length to move in x in one half cycle\n        \"\"\"\n        # Switch to relative if in absolute, but keep track of state\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        print_height = np.copy(self._current_position['z'])\n        print_feed = np.copy(self.speed)\n\n        for pressure in pressures:\n            direction = 1\n            self.set_pressure(com_port,pressure)\n            self.toggle_pressure(com_port)\n            for space in spacing:\n                #self.toggle_pressure(com_port)\n                self.move(y=direction*width)\n                self.move(space)\n                if space == spacing[-1]:\n                    self.move(y=-direction*width)\n                #self.toggle_pressure(com_port)\n                direction *= -1\n            self.toggle_pressure(com_port)\n            self.feed(travel_feed)\n            self.move(z=5)\n            if pressure != pressures[-1]:\n                self.move(x=-np.sum(spacing),y=width+padding)\n                self.move(z=-5)\n                self.feed(print_feed)\n\n        # Switch back to absolute if it was in absolute\n        if was_absolute:\n            self.absolute()\n\n        return [np.sum(spacing)*2-spacing[-1],len(pressures)*width + (len(pressures)-1)*padding]\n\n    def line_span(self,padding,dwell,distances,com_port,pressure,travel_feed):\n        \"\"\" Prints meanders of varying spacing with different pressures.\n\n        Parameters\n        ----------\n        frequency : float\n            The length to move in x in one half cycle\n        \"\"\"\n        # Switch to relative if in absolute, but keep track of state\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        print_height = np.copy(self._current_position['z'])\n        print_feed = np.copy(self.speed)\n\n        for dist in distances:\n            self.toggle_pressure(com_port)\n            self.dwell(dwell)\n            self.feed(print_feed*dist/distances[0])\n            self.move(y=dist)\n            self.dwell(dwell)\n            self.toggle_pressure(com_port)\n\n            self.move(z=-print_height)\n            self.feed(travel_feed)\n            self.move(z=print_height+5)\n            if dist != distances[-1]:\n                self.move(x=padding,y=-dist)\n                self.move(z=-5)\n                self.feed(print_feed)\n\n        # Switch back to absolute if it was in absolute\n        if was_absolute:\n            self.absolute()\n\n        return [padding*(len(distances)-1),np.max(distances)]\n\n\n    def line_crossing(self,dwell,feeds,length,com_port,pressure,travel_feed):\n        \"\"\" Prints meanders of varying spacing with different pressures.\n\n        Parameters\n        ----------\n        frequency : float\n            The length to move in x in one half cycle\n        \"\"\"\n        # Switch to relative if in absolute, but keep track of state\n        was_absolute = True\n        if not self.is_relative:\n            self.relative()\n        else:\n            was_absolute = False\n\n        print_height = np.copy(self._current_position['z'])\n\n        self.set_pressure(com_port,pressure)\n        self.toggle_pressure(com_port)\n        self.dwell(dwell)\n        self.move(x=length)\n        self.dwell(dwell)\n        self.toggle_pressure(com_port)\n        self.move(z=-print_height)\n        self.feed(travel_feed)\n        self.move(z=print_height+5)\n\n        spacing = length/(len(feeds)+1)\n        self.move(x=-spacing,y=8)\n        for feed in feeds:\n            self.move(z=-(print_height+5))\n            self.feed(feed)\n            self.move(y=-16)\n            if feed != feeds[-1]:\n                self.feed(travel_feed)\n                self.move(z=print_height+5)\n                self.move(x=-spacing,y=16)\n\n        self.feed(travel_feed)\n        self.move(z=print_height+5)\n\n        # Switch back to absolute if it was in absolute\n        if was_absolute:\n            self.absolute()\n\n        return length\n\n    # EXPORT Functions  #######################################################\n    def export_points(self, filename):\n        ''' Exports a CSV file of the x, y, z coordinates with optional color column for multimaterial support\n\n            Parameters\n            ----------\n            filename : str\n                The name of the exported CSV file.\n\n        '''\n        _, file_extension = os.path.splitext(filename)\n        if file_extension is False:\n            file_extension = f'{file_extension}.csv'\n\n        extruding_history = []\n        color_history = []\n        printing_history = []\n\n        for h in self.history:\n            any_on = any([entry['printing'] is True and entry['value'] != 0 for entry in h['PRINTING'].values()])\n\n            extruding_history.append([h['CURRENT_POSITION']['X'],\n                                      h['CURRENT_POSITION']['Y'],\n                                      h['CURRENT_POSITION']['Z']])\n            color_history.append(h['COLOR'] if h['COLOR'] is not None else DEFAULT_FILAMENT_COLOR)\n            printing_history.append(1 if any_on else 0)\n\n\n        extruding_history = np.array(extruding_history).reshape(-1,3)\n        color_history = np.array(color_history).reshape(-1, 3)\n        printing_history = np.array(printing_history).reshape(-1,1)\n\n        np.savetxt(filename,\n                    np.hstack([extruding_history, color_history, printing_history]),\n                   delimiter=',',\n                   header='x,y,z,R,G,B,ON',\n                   comments='',\n                   fmt=['%.6f']*3+['%.3f']*3 + ['%d']\n                   )\n\n\n\n\n    def gen_geometry(self,outfile,filament_diameter=0.8,cut_point=None,preview=False,color_incl=None):\n        \"\"\" Creates an openscad file to create a CAD model from the print path.\n\n        Parameters\n        ----------\n        outfile : str\n            Location to save the generated .scad file\n        filament_diameter : float (default: 0.8)\n            The com port to communicate over RS-232.\n        cut_point : int (default: None)\n            Stop generating cad model part way through the path\n        preview : bool (default: False)\n            Show matplotlib preview of the part to be generated.\n            Note that cut_point will affect the preview.\n        color_incl : str (default: None)\n            Used to export a single color when it is included in the code\n            design. Useful for exporting mutlimaterial parts as different\n            cad models.\n        Examples\n        --------\n        &gt;&gt;&gt; #Write geometry to 'test.scad'\n        &gt;&gt;&gt; g.gen_geometry('test.scad')\n\n        \"\"\"\n        import solid as sld\n        from solid import utils as sldutils\n        import matplotlib.pyplot as plt\n\n        # Matplotlib setup for preview\n        fig = plt.figure(dpi=150)\n        ax = plt.axes(projection='3d')\n\n        def circle(radius,num_points=10):\n            circle_pts = []\n            for i in range(2 * num_points):\n                angle = math.radians(360 / (2 * num_points) * i)\n                circle_pts.append(sldutils.Point3(radius * math.cos(angle), radius * math.sin(angle), 0))\n            return circle_pts\n\n        # SolidPython setup for geometry creation\n        extruded = 0\n        filament_cross = circle(radius=filament_diameter/2)\n\n        extruding_hist = dict(self.extruding_history)\n        position_hist = np.array(self.position_history)\n\n        #Stepping through all moves after initial position\n        extruding_state = False\n        for index, (pos, color) in enumerate(zip(self.position_history[1:cut_point],self.color_history[1:cut_point]),1):\n            sys.stdout.write('\\r')\n            sys.stdout.write(\"Exporting model: {:.0f}%\".format(index/len(self.position_history[1:])*100))\n            sys.stdout.flush()\n            #print(\"{}/{}\".format(index,len(self.position_history[1:])))\n            if index in extruding_hist:\n                extruding_state =  extruding_hist[index][1]\n\n            if extruding_state and ((color == color_incl) or (color_incl is None)):\n                X, Y, Z = position_hist[index-1:index+1, 0], position_hist[index-1:index+1, 1], position_hist[index-1:index+1, 2]\n                # Plot to matplotlb\n                if color_incl is not None:\n                    ax.plot(X, Y, Z,color_incl)\n                else:\n                    ax.plot(X, Y, Z,'b')\n                # Add geometry to part\n                extruded += sldutils.extrude_along_path(shape_pts=filament_cross, path_pts=[sldutils.Point3(*position_hist[index-1]),sldutils.Point3(*position_hist[index])])\n                extruded += sld.translate(position_hist[index-1])(sld.sphere(r=filament_diameter/2,segments=20))\n                extruded += sld.translate(position_hist[index])(sld.sphere(r=filament_diameter/2,segments=20))\n\n        # Export geometry to file\n        file_out = os.path.join(os.curdir, '{}.scad'.format(outfile))\n        print(\"\\nSCAD file written to: \\n%(file_out)s\" % vars())\n        sld.scad_render_to_file(extruded, file_out, include_orig_code=False)\n\n        if preview:\n            # Display Geometry for matplotlib\n            X, Y, Z = position_hist[:, 0], position_hist[:, 1], position_hist[:, 2]\n\n            # Hack to keep 3D plot's aspect ratio square. See SO answer:\n            # http://stackoverflow.com/questions/13685386\n            max_range = np.array([X.max()-X.min(),\n                                  Y.max()-Y.min(),\n                                  Z.max()-Z.min()]).max() / 2.0\n\n            mean_x = X.mean()\n            mean_y = Y.mean()\n            mean_z = Z.mean()\n            ax.set_xlim(mean_x - max_range, mean_x + max_range)\n            ax.set_ylim(mean_y - max_range, mean_y + max_range)\n            ax.set_zlim(mean_z - max_range, mean_z + max_range)\n            scaling = np.array([getattr(ax, 'get_{}lim'.format(dim))() for dim in 'xyz']); ax.auto_scale_xyz(*[[np.min(scaling), np.max(scaling)]]*3)\n            plt.show()\n\n    def export_APE(self):\n        \"\"\" Exports a list of dictionaries describing extrusion moves in a\n        format compatible with APE.\n\n        Examples\n        --------\n        &gt;&gt;&gt; #Write print geometry\n        &gt;&gt;&gt; geometry_def = g.meander()\n\n        \"\"\"\n        extruding_hist = dict(self.extruding_history)\n        position_hist = self.position_history\n        cut_ranges=[*extruding_hist][1:]\n        final_coords = []\n        for i in range(0,len(cut_ranges),2):\n            final_coords.append(position_hist[cut_ranges[i]-1:cut_ranges[i+1]])\n        final_coords_dict = []\n        for i in final_coords:\n            keys = ['X','Y','Z']\n            final_coords_dict.append([dict(zip(keys, l)) for l in i ])\n        return final_coords_dict\n\n    # Public Interface  #######################################################\n\n    def view(self,\n                backend='matplotlib',\n                outfile=None,\n                hide_travel=False,\n                color_on=True,\n                nozzle_cam=False,\n                fast_forward = 3,\n                framerate = 60,\n                nozzle_dims=[1.0,20.0],\n                substrate_dims=[0.0,0.0,-1.0,300,1,300],\n                scene_dims = [720,720],\n                ax=None,\n                **kwargs):\n        \"\"\" View the generated Gcode.\n\n        Parameters\n        ----------\n        backend : str (default: '3d')\n            The plotting backend to use. Must be one of {'2d', '3d', 'animated'}. For backward compatibility, backend could also be one of {'matplotlib', 'vpython'}\n        outfile : str (default: 'None')\n            When using the 'matplotlib' backend,\n            an image of the output will be save to the location specified\n            here.\n        color_on : bool (default: 'True')\n            If True, will display image with the color associated with the g.move command. This is helpful for multi-material printing or debugging.\n        nozzle_cam : bool (default: 'False')\n            When using the 'animated' or 'vpython' backend and nozzle_cam is set to\n            True, the camera will remained centered on the tip of the\n            nozzle during the animation.\n        fast_forward : int (default: 1)\n            When using the 'animated' or 'vpython' backend, the animation can be\n            sped up by the factor specified in the fast_forward\n            parameter.\n        nozzle_dims : list (default: [1.0,20.0])\n            When using the 'animated' or 'vpython' backend, the dimensions of the\n            nozzle can be specified using a list in the format:\n            [nozzle_diameter, nozzle_length].\n        substrate_dims: list (default: [0.0,0.0,-0.5,100,1,100])\n            When using the 'animated' or 'vpython' backend, the dimensions of the\n            planar substrate can be specified using a list in the\n            format: [x, y, z, length, height, width].\n        scene_dims: list (default: [720,720])\n            When using the 'animated' or 'vpython' backened, the dimensions of the\n            viewing window can be specified using a list in the\n            format: [width, height]\n        ax : matplotlib axes object\n            Useful for adding additional functionailities to plot when debugging.\n        cross_section : str (default: 'xy')\n            Determines what cross section / plane to display when When using the '2d' or '3d' backend.\n        shape : str (default : 'filament')\n            Determines what shape to display when using the '3d' or 'animated' backend. Helpful for visualizing non-filament based printing (e.g., droplet-based).\n            Must be one of {'filament', 'droplet'}.\n\n\n        \"\"\"\n        from mecode_viewer import plot2d, plot3d, animation\n\n        if backend == '2d':\n           ax = plot2d(self.history, ax=ax, hide_travel=hide_travel, **kwargs)\n        elif backend == 'matplotlib' or backend == '3d':\n            ax = plot3d(self.history, ax=ax, hide_travel=hide_travel, **kwargs)\n        elif backend == 'mayavi':\n            # from mayavi import mlab\n            # mlab.plot3d(history[:, 0], history[:, 1], history[:, 2])\n            raise ValueError(f'The {backend} backend is not currently supported.')\n        elif backend == 'vpython' or backend == 'animated':\n            animation(self.history,\n                        outfile,\n                        hide_travel,\n                        color_on,\n                        nozzle_cam,\n                        fast_forward,\n                        framerate,\n                        nozzle_dims,\n                        substrate_dims,\n                        scene_dims,\n                        **kwargs)\n\n        else:\n            raise Exception(\"Invalid plotting backend! Choose one of {'2d', '3d', 'animated'}.\")\n\n    def write(self, statement_in, resp_needed=False):\n        if self.print_lines:\n            print(statement_in)\n        self._write_out(statement_in)\n        statement = encode2To3(statement_in + self.lineend)\n        if self.direct_write is True:\n            if self.direct_write_mode == 'socket':\n                if self._socket is None:\n                    import socket\n                    self._socket = socket.socket(socket.AF_INET,\n                                                socket.SOCK_STREAM)\n                    self._socket.connect((self.printer_host, self.printer_port))\n                self._socket.send(statement)\n                if self.two_way_comm is True:\n                    response = self._socket.recv(8192)\n                    response = decode2To3(response)\n                    if response[0] != '%':\n                        raise RuntimeError(response)\n                    return response[1:-1]\n            elif self.direct_write_mode == 'serial':\n                if self._p is None:\n                    from .printer import Printer\n                    self._p = Printer(self.printer_port, self.baudrate)\n                    self._p.connect()\n                    self._p.start()\n                if resp_needed:\n                    return self._p.get_response(statement_in)\n                else:\n                    self._p.sendline(statement_in)\n\n    def rename_axis(self, x=None, y=None, z=None):\n        \"\"\" Replaces the x, y, or z axis with the given name.\n\n        Examples\n        --------\n        &gt;&gt;&gt; g.rename_axis(z='A')\n\n        \"\"\"\n        if x is not None:\n            self.x_axis = x\n        elif y is not None:\n            self.y_axis = y\n        elif z is not None:\n            self.z_axis = z\n        else:\n            msg = 'Must specify new name for x, y, or z only'\n            raise RuntimeError(msg)\n\n    # Private Interface  ######################################################\n\n    def _write_out(self, line=None, lines=None):\n        \"\"\" Writes given `line` or `lines` to the output file.\n        \"\"\"\n        # Only write if user requested an output file.\n        if self.out_fd is None:\n            return\n\n        if lines is not None:\n            for line in lines:\n                self._write_out(line)\n\n        line = line.rstrip() + self.lineend  # add lineend character\n        if 'b' in self.out_fd.mode:  # encode the string to binary if needed\n            line = encode2To3(line)\n        self.out_fd.write(line)\n\n\n    def _meander_passes(self, minor, spacing):\n        if minor &gt; 0:\n            passes = math.ceil(minor / spacing)\n        else:\n            passes = abs(math.floor(minor / spacing))\n        return passes\n\n    def _meander_spacing(self, minor, spacing):\n        return minor / self._meander_passes(minor, spacing)\n\n    def _write_header(self):\n        if self.aerotech_include is True:\n            with open(os.path.join(HERE, 'header.txt')) as fd:\n                self._write_out(lines=fd.readlines())\n        if self.header is not None:\n            with open(self.header) as fd:\n                self._write_out(lines=fd.readlines())\n\n    def _format_args(self, x=None, y=None, z=None, **kwargs):\n        d = self.output_digits\n        epsilon = np.finfo(float).eps  # Machine epsilon for float\n        args = []\n\n        def format_value(axis, value):\n            # ensure values like -0.0000 are actually set to zero\n            value = 0 if value == 0 else value\n\n            # Replace values effectively close to zero with 0.0 to avoid negative zero\n            return '{0}{1:.{digits}f}'.format(axis, 0 if abs(value) &lt; epsilon else value, digits=d)\n\n        if x is not None:\n            args.append(format_value(self.x_axis, x))\n        if y is not None:\n            args.append(format_value(self.y_axis, y))\n        if z is not None:\n            args.append(format_value(self.z_axis, z))\n\n        # Format additional arguments\n        args += [format_value(k, kwargs[k]) for k in sorted(kwargs)]\n\n        args = ' '.join(args)\n        return args\n\n\n    def _update_current_position(self, mode='auto', x=None, y=None, z=None, color = (0,0,0),\n                                 **kwargs):\n\n        new_state = copy.deepcopy(self.history[-1])\n        new_state['COORDS'] = (x, y, z)\n\n        if mode == 'auto':\n            mode = 'relative' if self.is_relative else 'absolute'\n            new_state['REL_MODE'] = self.is_relative\n\n        if self.x_axis != 'X' and x is not None:\n            kwargs[self.x_axis] = x\n        if self.y_axis != 'Y' and y is not None:\n            kwargs[self.y_axis] = y\n        if self.z_axis != 'Z' and z is not None:\n            kwargs[self.z_axis] = z\n\n        if mode == 'relative':\n            if x is not None:\n                self._current_position['x'] += x\n            if y is not None:\n                self._current_position['y'] += y\n            if z is not None:\n                self._current_position['z'] += z\n            for dimention, delta in kwargs.items():\n                self._current_position[dimention] += delta\n        else:\n            if x is not None:\n                self._current_position['x'] = x\n            if y is not None:\n                self._current_position['y'] = y\n            if z is not None:\n                self._current_position['z'] = z\n            for dimention, delta in kwargs.items():\n                self._current_position[dimention] = delta\n\n        x = self._current_position['x']\n        y = self._current_position['y']\n        z = self._current_position['z']\n\n        new_state['CURRENT_POSITION'] = {'X': x, 'Y': y, 'Z': z}\n        new_state['COLOR'] = color\n\n        # if self.extruding[0] is not None:\n        #     new_state['PRINTING'][self.extruding[0]] = {'printing': self.extruding[1], 'value': self.extruding[2]}\n        # for k, v in self.extrusion_state.items():\n        #     new_state['PRINTING'][k] = v\n        new_state['PRINTING'] = copy.deepcopy(self.extrusion_state)\n\n        self.position_history.append((x, y, z))\n\n        try:\n            color = mcolors.to_rgb(color)\n        except ValueError as e:\n            raise ValueError(f'Invalid color value provided and could not convert to RGB: {e}')\n\n        self.color_history.append(color)\n        new_state['COLOR'] = color\n        new_state['PRINT_SPEED'] = self.speed\n\n\n        len_history = len(self.position_history)\n        if (len(self.speed_history) == 0\n            or self.speed_history[-1][1] != self.speed):\n            self.speed_history.append((len_history - 1, self.speed))\n        if (len(self.extruding_history) == 0\n            or self.extruding_history[-1][1] != self.extruding):\n            self.extruding_history.append((len_history - 1, self.extruding))\n\n        self.history.append(new_state)\n        # print('updating state', self.history[-1]['COLOR'], self.history[-1]['PRINTING'] )\n\n    def _update_print_time(self, x,y,z):\n        if x is None:\n            x = self.current_position['x']\n        if y is None:\n            y = self.current_position['y']\n        if z is None:\n            z = self.current_position['z']\n        self.print_time += np.linalg.norm([x,y,z]) / self.speed\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry Can use like:</p> <p>with mecode.G(  outfile=self.outfile,                 print_lines=False,                 aerotech_include=False) as g:</p> Source code in <code>mecode/main.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Context manager entry\n    Can use like:\n\n    with mecode.G(  outfile=self.outfile,\n                    print_lines=False,\n                    aerotech_include=False) as g:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Context manager exit</p> Source code in <code>mecode/main.py</code> <pre><code>def __exit__(self, exc_type, exc_value, traceback):\n    \"\"\"\n    Context manager exit\n    \"\"\"\n    self.teardown()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.__init__","title":"<code>__init__(outfile=None, print_lines=True, header=None, footer=None, aerotech_include=True, output_digits=6, direct_write=False, direct_write_mode='socket', printer_host='localhost', printer_port=8000, baudrate=250000, two_way_comm=True, x_axis='X', y_axis='Y', z_axis='Z', extrude=False, filament_diameter=1.75, layer_height=0.19, extrusion_width=0.35, extrusion_multiplier=1, setup=True, lineend='os')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>path or None (default: None)</code> <p>If a path is specified, the compiled gcode will be writen to that file.</p> <code>None</code> <code>print_lines</code> <code>bool (default: True)</code> <p>Whether or not to print the compiled GCode to stdout</p> <code>True</code> <p>Other Parameters:</p> Name Type Description <code>header</code> <code>path or None (default: None)</code> <p>Optional path to a file containing lines to be written at the beginning of the output file</p> <code>footer</code> <code>path or None (default: None)</code> <p>Optional path to a file containing lines to be written at the end of the output file.</p> <code>aerotech_include</code> <code>bool (default: True)</code> <p>If true, add aerotech specific functions and var defs to outfile.</p> <code>output_digits</code> <code>int (default: 6)</code> <p>How many digits to include after the decimal in the output gcode.</p> <code>direct_write</code> <code>bool (default: False)</code> <p>If True a socket or serial port is opened to the printer and the GCode is sent directly over.</p> <code>direct_write_mode</code> <code>str (either 'socket' or 'serial') (default: socket)</code> <p>Specify the channel your printer communicates over, only used if <code>direct_write</code> is True.</p> <code>printer_host</code> <code>str (default: 'localhost')</code> <p>Hostname of the printer, only used if <code>direct_write</code> is True.</p> <code>printer_port</code> <code>int (default: 8000)</code> <p>Port of the printer, only used if <code>direct_write</code> is True.</p> <code>baudrate</code> <p>The baudrate to connect to the printer with.</p> <code>two_way_comm</code> <code>bool (default: True)</code> <p>If True, mecode waits for a response after every line of GCode is sent over the socket. The response is returned by the <code>write</code> method. Only applies if <code>direct_write</code> is True.</p> <code>x_axis</code> <code>str (default 'X')</code> <p>The name of the x axis (used in the exported gcode)</p> <code>y_axis</code> <code>str (default 'Y')</code> <p>The name of the z axis (used in the exported gcode)</p> <code>z_axis</code> <code>str (default 'Z')</code> <p>The name of the z axis (used in the exported gcode)</p> <code>extrude</code> <code>True or False (default: False)</code> <p>If True, a flow calculation will be done in the move command. The neccesary length of filament to be pushed through on a move command will be tagged on as a kwarg. ex. X5 Y5 E3</p> <code>filament_diameter</code> <p>the diameter of FDM filament you are using</p> <code>layer_height</code> <code>float</code> <p>Layer height for FDM printing. Only relavent when extrude = True.</p> <code>extrusion</code> <p>total width of the capsule shaped cross section of a squashed filament.</p> <code>extrusion_multiplier</code> <p>The length of extrusion filament to be pushed through on a move command will be multiplied by this number before being applied.</p> <code>setup</code> <code>Bool (default: True)</code> <p>Whether or not to automatically call the setup function.</p> <code>lineend</code> <code>str (default: 'os')</code> <p>Line ending to use when writing to a file or printer. The special value 'os' can be passed to fall back on python's automatic lineending insertion.</p> Source code in <code>mecode/main.py</code> <pre><code>def __init__(self,\n                outfile=None,\n                print_lines=True,\n                header=None,\n                footer=None,\n                aerotech_include=True,\n                output_digits=6,\n                direct_write=False,\n                direct_write_mode='socket',\n                printer_host='localhost',\n                printer_port=8000,\n                baudrate=250000,\n                two_way_comm=True,\n                x_axis='X',\n                y_axis='Y',\n                z_axis='Z',\n                extrude=False,\n                filament_diameter=1.75,\n                layer_height=0.19,\n                extrusion_width=0.35,\n                extrusion_multiplier=1,\n                setup=True,\n                lineend='os'):\n    \"\"\"\n    Parameters\n    ----------\n    outfile : path or None (default: None)\n        If a path is specified, the compiled gcode will be writen to that\n        file.\n    print_lines : bool (default: True)\n        Whether or not to print the compiled GCode to stdout\n\n    Other Parameters\n    ----------------\n    header : path or None (default: None)\n        Optional path to a file containing lines to be written at the\n        beginning of the output file\n    footer : path or None (default: None)\n        Optional path to a file containing lines to be written at the end\n        of the output file.\n    aerotech_include : bool (default: True)\n        If true, add aerotech specific functions and var defs to outfile.\n    output_digits : int (default: 6)\n        How many digits to include after the decimal in the output gcode.\n    direct_write : bool (default: False)\n        If True a socket or serial port is opened to the printer and the\n        GCode is sent directly over.\n    direct_write_mode : str (either 'socket' or 'serial') (default: socket)\n        Specify the channel your printer communicates over, only used if\n        `direct_write` is True.\n    printer_host : str (default: 'localhost')\n        Hostname of the printer, only used if `direct_write` is True.\n    printer_port : int (default: 8000)\n        Port of the printer, only used if `direct_write` is True.\n    baudrate: int (default: 250000)\n        The baudrate to connect to the printer with.\n    two_way_comm : bool (default: True)\n        If True, mecode waits for a response after every line of GCode is\n        sent over the socket. The response is returned by the `write`\n        method. Only applies if `direct_write` is True.\n    x_axis : str (default 'X')\n        The name of the x axis (used in the exported gcode)\n    y_axis : str (default 'Y')\n        The name of the z axis (used in the exported gcode)\n    z_axis : str (default 'Z')\n        The name of the z axis (used in the exported gcode)\n    extrude : True or False (default: False)\n        If True, a flow calculation will be done in the move command. The\n        neccesary length of filament to be pushed through on a move command\n        will be tagged on as a kwarg. ex. X5 Y5 E3\n    filament_diameter: float (default 1.75)\n        the diameter of FDM filament you are using\n    layer_height : float\n        Layer height for FDM printing. Only relavent when extrude = True.\n    extrusion width: float\n        total width of the capsule shaped cross section of a squashed filament.\n    extrusion_multiplier: float (default = 1)\n        The length of extrusion filament to be pushed through on a move\n        command will be multiplied by this number before being applied.\n    setup : Bool (default: True)\n        Whether or not to automatically call the setup function.\n    lineend : str (default: 'os')\n        Line ending to use when writing to a file or printer. The special\n        value 'os' can be passed to fall back on python's automatic\n        lineending insertion.\n\n    \"\"\"\n    self.outfile = outfile\n    self.print_lines = print_lines\n    self.header = header\n    self.footer = footer\n    self.aerotech_include = aerotech_include\n    self.output_digits = output_digits\n    self.direct_write = direct_write\n    self.direct_write_mode = direct_write_mode\n    self.printer_host = printer_host\n    self.printer_port = printer_port\n    self.baudrate = baudrate\n    self.two_way_comm = two_way_comm\n    self.x_axis = x_axis\n    self.y_axis = y_axis\n    self.z_axis = z_axis\n\n    self.extrude = extrude\n    self.filament_diameter = filament_diameter\n    self.layer_height = layer_height\n    self.extrusion_width = extrusion_width\n    self.extrusion_multiplier = extrusion_multiplier\n\n    self.history = [{\n        'REL_MODE': True,\n        'ACCEL' : 2500,\n        'DECEL' : 2500,\n        # 'P' : PRESSURE,\n        # 'P_COM_PORT': P_COM_PORT,\n        'PRINTING': {}, #{'Call togglePress': {'printing': False, 'value': 0}},\n        'PRINT_SPEED': 0,\n        'COORDS': (0,0,0),\n        'ORIGIN': (0,0,0),\n        'CURRENT_POSITION': {'X': 0, 'Y': 0, 'Z': 0},\n        # 'VARIABLES': VARIABLES\n        'COLOR': None\n    }]\n\n    self._current_position = defaultdict(float)\n    self.is_relative = True\n    self.position_history = [(0, 0, 0)]\n    self.color_history = [DEFAULT_FILAMENT_COLOR]\n    self.speed = 0\n    self.speed_history = []\n    self.extruding = [None, False, 0] # source, if_printing, printing_value\n    self.extruding_history = []\n    self.extrusion_state = {}#defaultdict()\n\n    self.print_time = 0\n    self.version = None\n\n    self._socket = None\n    self._p = None\n\n    # If the user passes in a line ending then we need to open the output\n    # file in binary mode, otherwise python will try to be smart and\n    # convert line endings in a platform dependent way.\n    if lineend == 'os':\n        mode = 'w+'\n        self.lineend = '\\n'\n    else:\n        mode = 'wb+'\n        self.lineend = lineend\n\n    if is_str(outfile):\n        self.out_fd = open(outfile, mode)\n    elif outfile is not None:  # if outfile not str assume it is an open file\n        self.out_fd = outfile\n    else:\n        self.out_fd = None\n\n    if setup:\n        self.setup()\n\n    self._check_latest_version()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.abs_arc","title":"<code>abs_arc(direction='CW', radius='auto', **kwargs)</code>","text":"<p>Same as arc method, but positions are interpreted as absolute.</p> Source code in <code>mecode/main.py</code> <pre><code>def abs_arc(self, direction='CW', radius='auto', **kwargs):\n    \"\"\" Same as [arc][mecode.main.G.arc] method, but positions are interpreted as absolute.\n    \"\"\"\n    if self.is_relative:\n        self.absolute()\n        self.arc(direction=direction, radius=radius, **kwargs)\n        self.relative()\n    else:\n        self.arc(direction=direction, radius=radius, **kwargs)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.abs_move","title":"<code>abs_move(x=None, y=None, z=None, rapid=False, **kwargs)</code>","text":"<p>Same as move method, but positions are interpreted as absolute.</p> Source code in <code>mecode/main.py</code> <pre><code>def abs_move(self, x=None, y=None, z=None, rapid=False, **kwargs):\n    \"\"\" Same as [move][mecode.main.G.move] method, but positions are interpreted as absolute.\n    \"\"\"\n    if self.is_relative:\n        self.absolute()\n        self.move(x=x, y=y, z=z, rapid=rapid, **kwargs)\n        self.relative()\n    else:\n        self.move(x=x, y=y, z=z, rapid=rapid, **kwargs)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.abs_rapid","title":"<code>abs_rapid(x=None, y=None, z=None, **kwargs)</code>","text":"<p>Executes an uncoordinated abs move to the specified location.</p> Source code in <code>mecode/main.py</code> <pre><code>def abs_rapid(self, x=None, y=None, z=None, **kwargs):\n    \"\"\" Executes an uncoordinated abs move to the specified location.\n    \"\"\"\n    self.abs_move(x, y, z, rapid=True, **kwargs)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.absolute","title":"<code>absolute()</code>","text":"<p>Enter absolute movement mode, in general this method should not be used, most methods handle it automatically.</p> Source code in <code>mecode/main.py</code> <pre><code>def absolute(self):\n    \"\"\" Enter absolute movement mode, in general this method should not be\n    used, most methods handle it automatically.\n\n    \"\"\"\n    if self.is_relative:\n        self.write('G90')\n        self.is_relative = False\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.arc","title":"<code>arc(x=None, y=None, z=None, direction='CW', radius='auto', helix_dim=None, helix_len=0, linearize=True, color=(0, 1, 0, 0.5), **kwargs)</code>","text":"<p>Arc to the given point with the given radius and in the given direction. If helix_dim and helix_len are specified then the tool head will also perform a linear movement through the given dimension while completing the arc. Note: Helix and flow calculation do not currently work with linearize.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str (either 'CW' or 'CCW') (default: 'CW')</code> <p>The direction to execute the arc in.</p> <code>'CW'</code> <code>radius</code> <code>'auto' or float (default: 'auto')</code> <p>The radius of the arc. A negative value will select the longer of the two possible arc segments. If auto is selected the radius will be set to half the linear distance to desired point.</p> <code>'auto'</code> <code>helix_dim</code> <code>str or None (default: None)</code> <p>The linear dimension to complete the helix through</p> <code>None</code> <code>helix_len</code> <code>float</code> <p>The length to move in the linear helix dimension.</p> <code>0</code> <code>linearize</code> <code>Bool (default: True)</code> <p>Represent the arc as a series of straight lines.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # arc 10 mm up in y and 10 mm over in x with a radius of 20.\n&gt;&gt;&gt; g.arc(x=10, y=10, radius=20)\n</code></pre> <pre><code>&gt;&gt;&gt; # move 10 mm up on the A axis, arcing through y with a radius of 20\n&gt;&gt;&gt; g.arc(A=10, y=0, radius=20)\n</code></pre> <pre><code>&gt;&gt;&gt; # arc through x and y while moving linearly on axis A\n&gt;&gt;&gt; g.arc(x=10, y=10, radius=50, helix_dim='A', helix_len=5)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def arc(self, x=None, y=None, z=None, direction='CW', radius='auto',\n        helix_dim=None, helix_len=0, linearize=True, color=(0,1,0,0.5), **kwargs):\n    \"\"\" Arc to the given point with the given radius and in the given\n    direction. If helix_dim and helix_len are specified then the tool head\n    will also perform a linear movement through the given dimension while\n    completing the arc. Note: Helix and flow calculation do not currently\n    work with linearize.\n\n    Parameters\n    ----------\n    direction : str (either 'CW' or 'CCW') (default: 'CW')\n        The direction to execute the arc in.\n    radius : 'auto' or float (default: 'auto')\n        The radius of the arc. A negative value will select the longer of\n        the two possible arc segments. If auto is selected the radius will\n        be set to half the linear distance to desired point.\n    helix_dim : str or None (default: None)\n        The linear dimension to complete the helix through\n    helix_len : float\n        The length to move in the linear helix dimension.\n    linearize : Bool (default: True)\n        Represent the arc as a series of straight lines.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # arc 10 mm up in y and 10 mm over in x with a radius of 20.\n    &gt;&gt;&gt; g.arc(x=10, y=10, radius=20)\n\n    &gt;&gt;&gt; # move 10 mm up on the A axis, arcing through y with a radius of 20\n    &gt;&gt;&gt; g.arc(A=10, y=0, radius=20)\n\n    &gt;&gt;&gt; # arc through x and y while moving linearly on axis A\n    &gt;&gt;&gt; g.arc(x=10, y=10, radius=50, helix_dim='A', helix_len=5)\n\n    \"\"\"\n    dims = dict(kwargs)\n    if x is not None:\n        dims['x'] = x\n    if y is not None:\n        dims['y'] = y\n    if z is not None:\n        dims['z'] = z\n    msg = 'Must specify two of x, y, or z.'\n    if len(dims) != 2:\n        raise RuntimeError(msg)\n    dimensions = [k.lower() for k in dims.keys()]\n    if 'x' in dimensions and 'y' in dimensions:\n        plane_selector = 'G17'  # XY plane\n        axis = helix_dim\n    elif 'x' in dimensions:\n        plane_selector = 'G18'  # XZ plane\n        dimensions.remove('x')\n        axis = dimensions[0].upper()\n    elif 'y' in dimensions:\n        plane_selector = 'G19'  # YZ plane\n        dimensions.remove('y')\n        axis = dimensions[0].upper()\n    else:\n        raise RuntimeError(msg)\n    if self.z_axis != 'Z':\n        axis = self.z_axis\n\n    if direction == 'CW':\n        command = 'G2'\n    elif direction == 'CCW':\n        command = 'G3'\n\n    values = [v for v in dims.values()]\n    if self.is_relative:\n        dist = math.sqrt(values[0] ** 2 + values[1] ** 2)\n        if radius == 'auto':\n            radius = dist / 2.0\n        elif abs(radius) &lt; dist / 2.0:\n            msg = 'Radius {} to small for distance {}'.format(radius, dist)\n            raise RuntimeError(msg)\n        vect_dir= [values[0]/dist,values[1]/dist]\n        if direction == 'CW':\n            arc_rotation_matrix = np.array([[0, -1],[1, 0]])\n        elif direction =='CCW':\n            arc_rotation_matrix = np.array([[0, 1],[-1, 0]])\n        perp_vect_dir = np.array(vect_dir)*arc_rotation_matrix\n        a_vect= np.array([values[0]/2,values[1]/2])\n        b_length = math.sqrt(radius**2-(dist/2)**2)\n        b_vect = b_length*perp_vect_dir\n        c_vect = a_vect+b_vect\n        # center_coords = c_vect\n        final_pos = a_vect*2-c_vect\n        initial_pos = -c_vect\n    else:\n        k = [ky for ky in dims.keys()]\n        cp = self._current_position\n        dist = math.sqrt(\n            (cp[k[0]] - values[0]) ** 2 + (cp[k[1]] - values[1]) ** 2\n        )\n\n        if radius == 'auto':\n            radius = dist / 2.0\n        elif abs(radius) &lt; dist / 2.0:\n            msg = 'Radius {} to small for distance {}'.format(radius, dist)\n            raise RuntimeError(msg)\n\n        vect_dir= [(values[0]-cp[k[0]])/dist,(values[1]-cp[k[1]])/dist]\n        if direction == 'CW':\n            arc_rotation_matrix = np.array([[0, -1],[1, 0]])\n        elif direction =='CCW':\n            arc_rotation_matrix = np.array([[0, 1],[-1, 0]])\n        perp_vect_dir = np.array(vect_dir)*arc_rotation_matrix\n        a_vect = np.array([(values[0]-cp[k[0]])/2.0,(values[1]-cp[k[1]])/2.0])\n        b_length = math.sqrt(radius**2-(dist/2)**2)\n        b_vect = b_length*perp_vect_dir\n        c_vect = a_vect+b_vect\n        # center_coords = np.array(cp[k[:2]])+c_vect\n\n        final_pos = np.array([cp[k] for k in k[:2]])+a_vect*2-c_vect\n        initial_pos = np.array([cp[k] for k in k[:2]])\n\n        # final_pos = np.array(cp[k[:2]])+a_vect*2-c_vect\n        # initial_pos = np.array(cp[k[:2]])\n\n    #extrude feature implementation\n    # only designed for flow calculations in x-y plane\n    if self.extrude is True:\n        area = self.layer_height*(self.extrusion_width-self.layer_height) + 3.14159*(self.layer_height/2)**2\n        if self.is_relative is not True:\n            current_extruder_position = self.current_position['E']\n        else:\n            current_extruder_position = 0\n\n        circle_circumference = 2*3.14159*abs(radius)\n\n        arc_angle = ((2*math.asin(dist/(2*abs(radius))))/(2*3.14159))*360\n        shortest_arc_length = (arc_angle/180)*3.14159*abs(radius)\n        if radius &gt; 0:\n            arc_length = shortest_arc_length\n        else:\n            arc_length = circle_circumference - shortest_arc_length\n        volume = arc_length*area\n        filament_length = ((4*volume)/(3.14149*self.filament_diameter**2))*self.extrusion_multiplier\n        dims['E'] = filament_length + current_extruder_position\n\n    if linearize:\n        #Curved formed from straight lines\n        final_pos = np.array(final_pos.tolist()).flatten()\n        initial_pos = np.array(initial_pos.tolist()).flatten()\n        final_angle = np.arctan2(final_pos[1],final_pos[0])\n        initial_angle = np.arctan2(initial_pos[1],initial_pos[0])\n\n        if direction == 'CW':\n            angle_difference = 2*np.pi-(final_angle-initial_angle)%(2*np.pi)\n        elif direction == 'CCW':\n            angle_difference = (initial_angle-final_angle)%(-2*np.pi)\n\n        step_range = [0, angle_difference]\n        step_size = np.pi/16\n        angle_step = np.arange(step_range[0],step_range[1]+np.sign(angle_difference)*step_size,np.sign(angle_difference)*step_size)\n\n        segments = []\n        for angle in angle_step:\n            radius_vect = -c_vect\n            radius_rotation_matrix = np.array([[math.cos(angle), -math.sin(angle)],\n                             [math.sin(angle), math.cos(angle)]])\n            int_point = radius_vect*radius_rotation_matrix\n            segments.append(int_point)\n\n        for i in range(len(segments)-1):\n            move_line = segments[i+1]-segments[i]\n            self.move(*move_line.tolist()[0], color=color)\n    else:\n        #Standard output\n        if axis is not None:\n            self.write('G16 X Y {}'.format(axis))  # coordinate axis assignment\n        self.write(plane_selector)\n        args = self._format_args(**dims)\n        if helix_dim is None:\n            self.write('{0} {1} R{2:.{digits}f}'.format(command, args, radius,\n                                                        digits=self.output_digits))\n        else:\n            self.write('{0} {1} R{2:.{digits}f} G1 {3}{4}'.format(\n                command, args, radius, helix_dim.upper(), helix_len, digits=self.output_digits))\n            dims[helix_dim] = helix_len\n\n        self._update_current_position(**dims)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.auto_home","title":"<code>auto_home(X=True, Y=True, Z=True, restore_leveling_after=None, skip_if_trusted=None, nozzle_raise_distance=None)</code>","text":"<p>Automatically calibrate the axis positions.</p> <p>Parameters:</p> Name Type Description Default <code>home_x</code> <code>bool (default: True)</code> <p>Home the X axis.</p> required <code>home_y</code> <code>bool (default: True)</code> <p>Home the Y axis.</p> required <code>home_z</code> <code>bool (default: True)</code> <p>Home the Z axis.</p> required <code>restore_leveling_after</code> <code>bool (default: True)</code> <p>Restore bed leveling state after homing.</p> <code>None</code> <code>skip_if_trusted</code> <code>bool (default: False)</code> <p>Skip homing if the position is already trusted.</p> <code>None</code> <code>nozzle_raise_distance</code> <code>float (default: 0.0)</code> <p>The distance to raise the nozzle before homing.</p> <code>None</code> Source code in <code>mecode/main.py</code> <pre><code>def auto_home(self,\n        X = True,\n        Y = True,\n        Z = True,\n        restore_leveling_after = None,\n        skip_if_trusted = None,\n        nozzle_raise_distance = None,\n        ):\n    \"\"\" Automatically calibrate the axis positions.\n\n    Parameters\n    ----------\n    home_x : bool (default: True)\n        Home the X axis.\n    home_y : bool (default: True)\n        Home the Y axis.\n    home_z : bool (default: True)\n        Home the Z axis.\n    restore_leveling_after : bool (default: True)\n        Restore bed leveling state after homing.\n    skip_if_trusted : bool (default: False)\n        Skip homing if the position is already trusted.\n    nozzle_raise_distance : float (default: 0.0)\n        The distance to raise the nozzle before homing.\n    \"\"\"\n    fields = dict(\n            G28 = True,\n            L = restore_leveling_after,\n            O = skip_if_trusted,\n            R = nozzle_raise_distance,\n            X = X,\n            Y = Y,\n            Z = Z)\n    fields = [key for key, val in fields.items() if val]\n    self.write(\" \".join(fields))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.break_and_continue","title":"<code>break_and_continue()</code>","text":"<p>Stop waiting and continue processing G-code.</p> Source code in <code>mecode/main.py</code> <pre><code>def break_and_continue(self):\n    \"\"\" Stop waiting and continue processing G-code.\n    \"\"\"\n    self.write(\"M108\")\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.circle","title":"<code>circle(radius, center=None, direction='CW', linearize=True, **kwargs)</code>","text":"<p>Generates a circle starting from the current position if center is None, otherwise from center.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str (either 'CW' or 'CCW') (default: 'CW')</code> <p>The direction to execute the arc in.</p> <code>'CW'</code> <code>radius</code> <code>float</code> <p>The radius of the circle.</p> required <code>center</code> <code>(float, float)</code> <p>The center coordinates of the circle</p> <code>None</code> <code>linearize</code> <code>Bool (default: True)</code> <p>Represent the arc of the circle as a series of straight lines.</p> <code>True</code> <p>Examples:</p> <p>TODO: updates these</p> <pre><code>&gt;&gt;&gt; # arc 10 mm up in y and 10 mm over in x with a radius of 20.\n&gt;&gt;&gt; g.arc(x=10, y=10, radius=20)\n</code></pre> <pre><code>&gt;&gt;&gt; # move 10 mm up on the A axis, arcing through y with a radius of 20\n&gt;&gt;&gt; g.arc(A=10, y=0, radius=20)\n</code></pre> <pre><code>&gt;&gt;&gt; # arc through x and y while moving linearly on axis A\n&gt;&gt;&gt; g.arc(x=10, y=10, radius=50, helix_dim='A', helix_len=5)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def circle(self, radius, center=None,  direction='CW', linearize=True, **kwargs):\n    \"\"\" Generates a circle starting from the current position if center is None,\n    otherwise from center.\n\n    Parameters\n    ----------\n    direction : str (either 'CW' or 'CCW') (default: 'CW')\n        The direction to execute the arc in.\n    radius : float\n        The radius of the circle.\n    center : (float, float)\n        The center coordinates of the circle\n    linearize : Bool (default: True)\n        Represent the arc of the circle as a series of straight lines.\n\n    Examples\n    --------\n    TODO: updates these\n    &gt;&gt;&gt; # arc 10 mm up in y and 10 mm over in x with a radius of 20.\n    &gt;&gt;&gt; g.arc(x=10, y=10, radius=20)\n\n    &gt;&gt;&gt; # move 10 mm up on the A axis, arcing through y with a radius of 20\n    &gt;&gt;&gt; g.arc(A=10, y=0, radius=20)\n\n    &gt;&gt;&gt; # arc through x and y while moving linearly on axis A\n    &gt;&gt;&gt; g.arc(x=10, y=10, radius=50, helix_dim='A', helix_len=5)\n\n    \"\"\"\n    if direction == 'CW':\n        self.arc(x=radius, y=radius, radius=radius, direction='CW', linearize=linearize, **kwargs)\n        self.arc(x=radius, y=-radius, radius=radius, direction='CW', linearize=linearize, **kwargs)\n        self.arc(x=-radius, y=-radius, radius=radius, direction='CW', linearize=linearize, **kwargs)\n        self.arc(x=-radius, y=radius, radius=radius, direction='CW', linearize=linearize, **kwargs)\n    elif direction == 'CCW':\n        self.arc(x=-radius, y=radius, radius=radius, direction='CCW', linearize=linearize, **kwargs)\n        self.arc(x=-radius, y=-radius, radius=radius, direction='CCW', linearize=linearize, **kwargs)\n        self.arc(x=radius, y=-radius, radius=radius, direction='CCW', linearize=linearize, **kwargs)\n        self.arc(x=radius, y=radius, radius=radius, direction='CCW', linearize=linearize, **kwargs)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.clip","title":"<code>clip(axis='z', direction='+x', height=4, linearize=False)</code>","text":"<p>Move the given axis up to the given height while arcing in the given direction.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str (default: 'z')</code> <p>The axis to move, e.g. 'z'</p> <code>'z'</code> <code>direction</code> <code>str (either +-x or +-y) (default: '+x')</code> <p>The direction to arc through</p> <code>'+x'</code> <code>height</code> <code>float (default: 4)</code> <p>The height to end up at</p> <code>4</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # move 'z' axis up 4mm while arcing through positive x\n&gt;&gt;&gt; g.clip()\n</code></pre> <pre><code>&gt;&gt;&gt; # move 'A' axis up 10mm while arcing through negative y\n&gt;&gt;&gt; g.clip('A', height=10, direction='-y')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def clip(self, axis='z', direction='+x', height=4, linearize=False):\n    \"\"\" Move the given axis up to the given height while arcing in the\n    given direction.\n\n    Parameters\n    ----------\n    axis : str (default: 'z')\n        The axis to move, e.g. 'z'\n    direction : str (either +-x or +-y) (default: '+x')\n        The direction to arc through\n    height : float (default: 4)\n        The height to end up at\n\n    Examples\n    --------\n    &gt;&gt;&gt; # move 'z' axis up 4mm while arcing through positive x\n    &gt;&gt;&gt; g.clip()\n\n    &gt;&gt;&gt; # move 'A' axis up 10mm while arcing through negative y\n    &gt;&gt;&gt; g.clip('A', height=10, direction='-y')\n\n    \"\"\"\n    secondary_axis = direction[1]\n    if height &gt; 0:\n        orientation = 'CW' if direction[0] == '-' else 'CCW'\n    else:\n        orientation = 'CCW' if direction[0] == '-' else 'CW'\n    radius = abs(height / 2.0)\n    kwargs = {\n        secondary_axis: 0,\n        axis: height,\n        'direction': orientation,\n        'radius': radius,\n        'linearize': linearize\n    }\n    self.arc(**kwargs)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.dwell","title":"<code>dwell(time)</code>","text":"<p>Pause code executions for the given amount of time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Time in milliseconds to pause code execution.</p> required Source code in <code>mecode/main.py</code> <pre><code>def dwell(self, time):\n    \"\"\" Pause code executions for the given amount of time.\n\n    Parameters\n    ----------\n    time : float\n        Time in milliseconds to pause code execution.\n\n    \"\"\"\n    self.write('G4 P{}'.format(time))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.export_APE","title":"<code>export_APE()</code>","text":"<p>Exports a list of dictionaries describing extrusion moves in a format compatible with APE.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Write print geometry\n&gt;&gt;&gt; geometry_def = g.meander()\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def export_APE(self):\n    \"\"\" Exports a list of dictionaries describing extrusion moves in a\n    format compatible with APE.\n\n    Examples\n    --------\n    &gt;&gt;&gt; #Write print geometry\n    &gt;&gt;&gt; geometry_def = g.meander()\n\n    \"\"\"\n    extruding_hist = dict(self.extruding_history)\n    position_hist = self.position_history\n    cut_ranges=[*extruding_hist][1:]\n    final_coords = []\n    for i in range(0,len(cut_ranges),2):\n        final_coords.append(position_hist[cut_ranges[i]-1:cut_ranges[i+1]])\n    final_coords_dict = []\n    for i in final_coords:\n        keys = ['X','Y','Z']\n        final_coords_dict.append([dict(zip(keys, l)) for l in i ])\n    return final_coords_dict\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.export_points","title":"<code>export_points(filename)</code>","text":"<p>Exports a CSV file of the x, y, z coordinates with optional color column for multimaterial support</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the exported CSV file.</p> required Source code in <code>mecode/main.py</code> <pre><code>def export_points(self, filename):\n    ''' Exports a CSV file of the x, y, z coordinates with optional color column for multimaterial support\n\n        Parameters\n        ----------\n        filename : str\n            The name of the exported CSV file.\n\n    '''\n    _, file_extension = os.path.splitext(filename)\n    if file_extension is False:\n        file_extension = f'{file_extension}.csv'\n\n    extruding_history = []\n    color_history = []\n    printing_history = []\n\n    for h in self.history:\n        any_on = any([entry['printing'] is True and entry['value'] != 0 for entry in h['PRINTING'].values()])\n\n        extruding_history.append([h['CURRENT_POSITION']['X'],\n                                  h['CURRENT_POSITION']['Y'],\n                                  h['CURRENT_POSITION']['Z']])\n        color_history.append(h['COLOR'] if h['COLOR'] is not None else DEFAULT_FILAMENT_COLOR)\n        printing_history.append(1 if any_on else 0)\n\n\n    extruding_history = np.array(extruding_history).reshape(-1,3)\n    color_history = np.array(color_history).reshape(-1, 3)\n    printing_history = np.array(printing_history).reshape(-1,1)\n\n    np.savetxt(filename,\n                np.hstack([extruding_history, color_history, printing_history]),\n               delimiter=',',\n               header='x,y,z,R,G,B,ON',\n               comments='',\n               fmt=['%.6f']*3+['%.3f']*3 + ['%d']\n               )\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.feed","title":"<code>feed(rate)</code>","text":"<p>Set the feed rate (tool head speed) in mm/s</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>float</code> <p>The speed to move the tool head in mm/s.</p> required Source code in <code>mecode/main.py</code> <pre><code>def feed(self, rate):\n    \"\"\" Set the feed rate (tool head speed) in mm/s\n\n    Parameters\n    ----------\n    rate : float\n        The speed to move the tool head in mm/s.\n\n    \"\"\"\n    self.write('G1 F{}'.format(rate))\n    self.speed = rate\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.finish_moves","title":"<code>finish_moves(wait=True)</code>","text":"<p>Halts the processing of G-code until moves are completed.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>bool (default: True)</code> <p>Whether to pause python execution as well.</p> <code>True</code> Source code in <code>mecode/main.py</code> <pre><code>def finish_moves(self, wait=True):\n    \"\"\" Halts the processing of G-code until moves are completed.\n\n    Parameters\n    ----------\n    wait : bool (default: True)\n        Whether to pause python execution as well.\n    \"\"\"\n    self.write(\"M400\", resp_needed=wait)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.gen_geometry","title":"<code>gen_geometry(outfile, filament_diameter=0.8, cut_point=None, preview=False, color_incl=None)</code>","text":"<p>Creates an openscad file to create a CAD model from the print path.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>Location to save the generated .scad file</p> required <code>filament_diameter</code> <code>float (default: 0.8)</code> <p>The com port to communicate over RS-232.</p> <code>0.8</code> <code>cut_point</code> <code>int (default: None)</code> <p>Stop generating cad model part way through the path</p> <code>None</code> <code>preview</code> <code>bool (default: False)</code> <p>Show matplotlib preview of the part to be generated. Note that cut_point will affect the preview.</p> <code>False</code> <code>color_incl</code> <code>str (default: None)</code> <p>Used to export a single color when it is included in the code design. Useful for exporting mutlimaterial parts as different cad models.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Write geometry to 'test.scad'\n&gt;&gt;&gt; g.gen_geometry('test.scad')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def gen_geometry(self,outfile,filament_diameter=0.8,cut_point=None,preview=False,color_incl=None):\n    \"\"\" Creates an openscad file to create a CAD model from the print path.\n\n    Parameters\n    ----------\n    outfile : str\n        Location to save the generated .scad file\n    filament_diameter : float (default: 0.8)\n        The com port to communicate over RS-232.\n    cut_point : int (default: None)\n        Stop generating cad model part way through the path\n    preview : bool (default: False)\n        Show matplotlib preview of the part to be generated.\n        Note that cut_point will affect the preview.\n    color_incl : str (default: None)\n        Used to export a single color when it is included in the code\n        design. Useful for exporting mutlimaterial parts as different\n        cad models.\n    Examples\n    --------\n    &gt;&gt;&gt; #Write geometry to 'test.scad'\n    &gt;&gt;&gt; g.gen_geometry('test.scad')\n\n    \"\"\"\n    import solid as sld\n    from solid import utils as sldutils\n    import matplotlib.pyplot as plt\n\n    # Matplotlib setup for preview\n    fig = plt.figure(dpi=150)\n    ax = plt.axes(projection='3d')\n\n    def circle(radius,num_points=10):\n        circle_pts = []\n        for i in range(2 * num_points):\n            angle = math.radians(360 / (2 * num_points) * i)\n            circle_pts.append(sldutils.Point3(radius * math.cos(angle), radius * math.sin(angle), 0))\n        return circle_pts\n\n    # SolidPython setup for geometry creation\n    extruded = 0\n    filament_cross = circle(radius=filament_diameter/2)\n\n    extruding_hist = dict(self.extruding_history)\n    position_hist = np.array(self.position_history)\n\n    #Stepping through all moves after initial position\n    extruding_state = False\n    for index, (pos, color) in enumerate(zip(self.position_history[1:cut_point],self.color_history[1:cut_point]),1):\n        sys.stdout.write('\\r')\n        sys.stdout.write(\"Exporting model: {:.0f}%\".format(index/len(self.position_history[1:])*100))\n        sys.stdout.flush()\n        #print(\"{}/{}\".format(index,len(self.position_history[1:])))\n        if index in extruding_hist:\n            extruding_state =  extruding_hist[index][1]\n\n        if extruding_state and ((color == color_incl) or (color_incl is None)):\n            X, Y, Z = position_hist[index-1:index+1, 0], position_hist[index-1:index+1, 1], position_hist[index-1:index+1, 2]\n            # Plot to matplotlb\n            if color_incl is not None:\n                ax.plot(X, Y, Z,color_incl)\n            else:\n                ax.plot(X, Y, Z,'b')\n            # Add geometry to part\n            extruded += sldutils.extrude_along_path(shape_pts=filament_cross, path_pts=[sldutils.Point3(*position_hist[index-1]),sldutils.Point3(*position_hist[index])])\n            extruded += sld.translate(position_hist[index-1])(sld.sphere(r=filament_diameter/2,segments=20))\n            extruded += sld.translate(position_hist[index])(sld.sphere(r=filament_diameter/2,segments=20))\n\n    # Export geometry to file\n    file_out = os.path.join(os.curdir, '{}.scad'.format(outfile))\n    print(\"\\nSCAD file written to: \\n%(file_out)s\" % vars())\n    sld.scad_render_to_file(extruded, file_out, include_orig_code=False)\n\n    if preview:\n        # Display Geometry for matplotlib\n        X, Y, Z = position_hist[:, 0], position_hist[:, 1], position_hist[:, 2]\n\n        # Hack to keep 3D plot's aspect ratio square. See SO answer:\n        # http://stackoverflow.com/questions/13685386\n        max_range = np.array([X.max()-X.min(),\n                              Y.max()-Y.min(),\n                              Z.max()-Z.min()]).max() / 2.0\n\n        mean_x = X.mean()\n        mean_y = Y.mean()\n        mean_z = Z.mean()\n        ax.set_xlim(mean_x - max_range, mean_x + max_range)\n        ax.set_ylim(mean_y - max_range, mean_y + max_range)\n        ax.set_zlim(mean_z - max_range, mean_z + max_range)\n        scaling = np.array([getattr(ax, 'get_{}lim'.format(dim))() for dim in 'xyz']); ax.auto_scale_xyz(*[[np.min(scaling), np.max(scaling)]]*3)\n        plt.show()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.get_axis_pos","title":"<code>get_axis_pos(axis)</code>","text":"<p>Gets the current position of the specified <code>axis</code>.</p> Source code in <code>mecode/main.py</code> <pre><code>def get_axis_pos(self, axis):\n    \"\"\" Gets the current position of the specified `axis`.\n    \"\"\"\n    cmd = 'AXISSTATUS({}, DATAITEM_PositionFeedback)'.format(axis.upper())\n    pos = self.write(cmd)\n    return float(pos)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.gradient_spiral","title":"<code>gradient_spiral(end_diameter, spacing, gradient, feedrate, flowrate, start='center', direction='CW', step_angle=0.1, start_diameter=0, center_position=None, dead_delay=0)</code>","text":"<p>Identical motion to the regular spiral function, but with the control of two syringe pumps to enable control over     dielectric properties over the course of the spiral. Starting with simply hitting certain dielectric constants at     different values along the radius of the spiral.</p> <p>Parameters:</p> Name Type Description Default <code>end_diameter</code> <code>float</code> <p>The outer diameter of the spiral.</p> required <code>spacing</code> <code>float</code> <p>The spacing between lines of the spiral.</p> required <code>gradient</code> <code>str</code> <p>Functioning defining the ink concentration along the radius of the spiral</p> required <code>feedrate</code> <code>float</code> <p>Feedrate is the speed of the nozzle relative to the substrate</p> required <code>flowrate</code> <code>float</code> <p>Flowrate is a measure of the amount of ink dispensed per second by the syringe pump</p> required <code>start</code> <code>str (either 'center', 'edge')</code> <p>The location to start the spiral (default: 'center').</p> <code>'center'</code> <code>direction</code> <code>str (either 'CW', 'CCW')</code> <p>Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')</p> <code>'CW'</code> <code>step_angle</code> <code>float</code> <p>Resolution of the spiral in radians, smaller is higher resolution (default: 0.1).</p> <code>0.1</code> <code>start_diameter</code> <code>float</code> <p>The inner diameter of the spiral (default: 0).</p> <code>0</code> <code>center_position</code> <code>list</code> <p>Position of the absolute center of the spiral, useful when starting a spiral at the edge of a completed spiral</p> <code>None</code> <code>dead_delay</code> <code>float</code> <p>Printing composition offset caused by the dead volume of the nozzle which creates a delayed effect between the syringe pumps and the actual composition of the ink exiting the nozzle.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g.gradient_spiral(start_diameter=7.62, #mm\n...     end_diameter=30.48, #mm\n...     spacing=1, #mm\n...     feedrate=8, #mm/s\n...     flowrate=2/60.0, #rot/s\n...     start='edge', #'edge' or 'center'\n...     direction='CW', #'CW' or 'CCW'\n...     gradient=\"-0.322*r**2 - 6.976*r + 131.892\") #Any function\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def gradient_spiral(self, end_diameter, spacing, gradient, feedrate, flowrate,\n            start='center', direction='CW', step_angle = 0.1, start_diameter = 0,\n            center_position=None, dead_delay=0):\n    \"\"\" Identical motion to the regular spiral function, but with the control of two syringe pumps to enable control over\n        dielectric properties over the course of the spiral. Starting with simply hitting certain dielectric constants at\n        different values along the radius of the spiral.\n\n    Parameters\n    ----------\n    end_diameter : float\n        The outer diameter of the spiral.\n    spacing : float\n        The spacing between lines of the spiral.\n    gradient : str\n        Functioning defining the ink concentration along the radius of the spiral\n    feedrate : float\n        Feedrate is the speed of the nozzle relative to the substrate\n    flowrate : float\n        Flowrate is a measure of the amount of ink dispensed per second by the syringe pump\n    start : str (either 'center', 'edge')\n        The location to start the spiral (default: 'center').\n    direction : str (either 'CW', 'CCW')\n        Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')\n    step_angle : float\n        Resolution of the spiral in radians, smaller is higher resolution (default: 0.1).\n    start_diameter : float\n        The inner diameter of the spiral (default: 0).\n    center_position : list\n        Position of the absolute center of the spiral, useful when starting a spiral at the edge of a completed spiral\n    dead_delay : float\n        Printing composition offset caused by the dead volume of the nozzle which creates a delayed\n        effect between the syringe pumps and the actual composition of the ink exiting the nozzle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; g.gradient_spiral(start_diameter=7.62, #mm\n    ...     end_diameter=30.48, #mm\n    ...     spacing=1, #mm\n    ...     feedrate=8, #mm/s\n    ...     flowrate=2/60.0, #rot/s\n    ...     start='edge', #'edge' or 'center'\n    ...     direction='CW', #'CW' or 'CCW'\n    ...     gradient=\"-0.322*r**2 - 6.976*r + 131.892\") #Any function\n    \"\"\"\n\n    import sympy as sy\n\n    def calculate_extrusion_values(radius, length, feed = feedrate, flow = flowrate, formula = gradient, delay = dead_delay, spacing = spacing, start = start, outer_radius = end_diameter/2.0, inner_radius=start_diameter/2.0):\n        \"\"\"Calculates the extrusion values for syringe pumps A &amp; B during a move along the print path.\n        \"\"\"\n\n        def exact_length(r0,r1,h):\n            \"\"\"Calculates the exact length of an archimedean given the spacing, inner and outer radii.\n            SEE: http://www.giangrandi.ch/soft/spiral/spiral.shtml\n\n            Parameters\n            ----------\n            r0 : float\n                The inner diameter of the spiral.\n            r1 : float\n                The outer diameter of the spiral.\n            h  : float\n                The spacing of the spiral.\n            \"\"\"\n            #t0 &amp; t1 are the respective diameters in terms of radians along the spiral.\n            t0 = 2*math.pi*r0/h\n            t1 = 2*math.pi*r1/h\n            return h/(2.0*math.pi)*(t1/2.0*math.sqrt(t1**2+1)+1/2.0*math.log(t1+math.sqrt(t1**2+1))-t0/2.0*math.sqrt(t0**2+1)-1/2.0*math.log(t0+math.sqrt(t0**2+1)))\n\n\n        def exact_radius(r_0,h,L):\n            \"\"\"Calculates the exact outer radius of an archimedean given the spacing, inner radius and the length.\n            SEE: http://www.giangrandi.ch/soft/spiral/spiral.shtml\n\n            Parameters\n            ----------\n            r0 : float\n                The inner radius of the spiral.\n            h  : float\n                The spacing of the spiral.\n            L  : float\n                The length of the spiral.\n            \"\"\"\n            d_0 = r_0*2\n            if d_0 == 0:\n                d_0 = 1e-10\n\n            def exact_length(d0,d1,h):\n                \"\"\"Calculates the exact length of an archimedean given the spacing, inner and outer diameters.\n                SEE: http://www.giangrandi.ch/soft/spiral/spiral.shtml\n\n                Parameters\n                ----------\n                d0 : float\n                    The inner diameter of the spiral.\n                d1 : float\n                    The outer diameter of the spiral.\n                h  : float\n                    The spacing of the spiral.\n                \"\"\"\n                #t0 &amp; t1 are the respective diameters in terms of radians along the spiral.\n                t0 = math.pi*d0/h\n                t1 = math.pi*d1/h\n                return h/(2.0*math.pi)*(t1/2.0*math.sqrt(t1**2+1)+1/2.0*math.log(t1+math.sqrt(t1**2+1))-t0/2.0*math.sqrt(t0**2+1)-1/2.0*math.log(t0+math.sqrt(t0**2+1)))\n\n            def exact_length_derivative(d,h):\n                \"\"\"Calculates the derivative of the exact length of an archimedean at a given diameter and spacing.\n                SEE: http://www.giangrandi.ch/soft/spiral/spiral.shtml\n\n                Parameters\n                ----------\n                d : float\n                    The diameter point of interest in the spiral.\n                h  : float\n                    The spacing of the spiral.\n                \"\"\"\n                #t is diameter of interest in terms of radians along the spiral.\n                t = math.pi*d/h\n                dl_dt = h/(2.0*math.pi)*((2*t**2+1)/(2*math.sqrt(t**2+1))+(t+math.sqrt(t**2+1))/(2*t*math.sqrt(t**2+1)+2*t**2+2))\n                dl_dd = h*dl_dt/math.pi\n                return dl_dd\n\n            #Approximate radius (for first guess)\n            N = (h-d_0+math.sqrt((d_0-h)**2+4*h*L/math.pi))/(2*h)\n            D_1 = 2*N*h + d_0\n            tol = 1e-10\n\n            #Use Newton's Method to iterate until within tolerance\n            while True:\n                f_df_dt = (exact_length(d_0,D_1,h)-L)/1000/exact_length_derivative(D_1,h)\n                if f_df_dt &lt; tol:\n                    break\n                D_1 -= f_df_dt\n            return D_1/2\n\n        def rollover(val,limit,mode):\n            if val &lt; limit:\n                if mode == 'max':\n                    return val\n                elif mode == 'min':\n                    return limit+(limit-val)\n                else:\n                    raise ValueError(\"'{}' is an incorrect selection for the mode\".format(mode))\n            else:\n                if mode == 'max':\n                    return limit-(val-limit)\n                elif mode == 'min':\n                    return val\n                else:\n                    raise ValueError(\"'{}' is an incorrect selection for the mode\".format(mode))\n\n        def minor_fraction_calc(e,e_a=300,e_b=2.3,n=0.102,sr=0.6):\n            \"\"\"Calculates the minor fraction (fraction of part b) required to achieve the\n            specified dielectric value\n\n            Parameters\n            ----------\n            e : float\n                Dielectric value of interest\n            e_a  : float\n                Dielectric value of part a\n            e_b. : float\n                Dielectric value of part b\n            n  : float\n                Morphology factor\n            sr : float\n                Fraction of SrTi03 in part a\n            \"\"\"\n            return 1 - ((e-e_b)*((n-1)*e_b-n*e_a))/(sr*(e_b-e_a)*(n*(e-e_b)+e_b))\n\n        \"\"\"\n        This is a key line of the extrusion values calculations.\n        It starts off by calculating the exact length along the spiral for the current\n        radius, then adds/subtracts on the dead volume delay (in effect looking into the\n        future path) to this length, then recalculates the appropriate radius at this new\n        postiion. This is value is then used in the gradient function to determine the minor\n        fraction of the mixed elements. Note that if delay is 0, then this line will have no\n        effect. If the spiral is moving outwards it must add the dead volume delay, whereas if\n        the spiral is moving inwards, it must subtract it.\n\n        \"\"\"\n        if start == 'center':\n            offset_radius = exact_radius(0,spacing,rollover(exact_length(0,radius,spacing)+delay,exact_length(0,outer_radius,spacing),'max'))\n        else:\n            offset_radius = exact_radius(0,spacing,rollover(exact_length(0,radius,spacing)-delay,exact_length(0,inner_radius,spacing),'min'))\n\n        expr = sy.sympify(formula)\n        r = sy.symbols('r')\n        minor_fraction = np.clip(minor_fraction_calc(float(expr.subs(r,offset_radius))),0,1)\n        line_flow = length/float(feed)*flow\n        return [minor_fraction*line_flow,(1-minor_fraction)*line_flow,minor_fraction]\n\n    #End of calculate_extrusion_values() function\n\n    start_spiral_turns = (start_diameter/2.0)/spacing\n    end_spiral_turns = (end_diameter/2.0)/spacing\n\n    #Use current position as center position if none is specified\n    if center_position is None:\n        center_position = [self._current_position['x'],self._current_position['y']]\n\n    #Keep track of whether currently in relative or absolute mode\n    was_relative = True\n    if self.is_relative:\n        self.absolute()\n    else:\n        was_relative = False\n\n    #SEE: https://www.comsol.com/blogs/how-to-build-a-parameterized-archimedean-spiral-geometry/\n    b = spacing/(2*math.pi)\n    t = np.arange(start_spiral_turns*2*math.pi, end_spiral_turns*2*math.pi, step_angle)\n\n    #Add last final point to ensure correct outer diameter\n    t = np.append(t,end_spiral_turns*2*math.pi)\n    if start == 'center':\n        pass\n    elif start == 'edge':\n        t = t[::-1]\n    else:\n        raise Exception(\"Must either choose 'center' or 'edge' for starting position.\")\n\n    #Move to starting positon\n    if (direction == 'CW' and start == 'center') or (direction == 'CCW' and start == 'edge'):\n        x_move = -t[0]*b*math.cos(t[0])+center_position[0]\n    elif (direction == 'CCW' and start == 'center') or (direction == 'CW' and start == 'edge'):\n        x_move = t[0]*b*math.cos(t[0])+center_position[0]\n    else:\n        raise Exception(\"Must either choose 'CW' or 'CCW' for spiral direction.\")\n    y_move = t[0]*b*math.sin(t[0])+center_position[1]\n    self.move(x_move, y_move)\n\n    #Start writing moves\n    self.feed(feedrate)\n    syringe_extrusion = np.array([0.0,0.0])\n\n    #Zero a &amp; b axis before printing, we do this so it can easily do multiple layers without quickly jumping back to 0\n    #Would likely be useful to change this to relative coordinates at some point\n    self.write('G92 a0 b0')\n\n    for step in t[1:]:\n        if (direction == 'CW' and start == 'center') or (direction == 'CCW' and start == 'edge'):\n            x_move = -step*b*math.cos(step)+center_position[0]\n        elif (direction == 'CCW' and start == 'center') or (direction == 'CW' and start == 'edge'):\n            x_move = step*b*math.cos(step)+center_position[0]\n        else:\n            raise Exception(\"Must either choose 'CW' or 'CCW' for spiral direction.\")\n        y_move = step*b*math.sin(step)+center_position[1]\n\n        radius_pos = np.sqrt((self._current_position['x']-center_position[0])**2 + (self._current_position['y']-center_position[1])**2)\n        line_length = np.sqrt((x_move-self._current_position['x'])**2 + (y_move-self._current_position['y'])**2)\n        extrusion_values = calculate_extrusion_values(radius_pos,line_length)\n        syringe_extrusion += extrusion_values[:2]\n        self.move(x_move, y_move, a=syringe_extrusion[0],b=syringe_extrusion[1],color=extrusion_values[2])\n\n    #Set back to relative mode if it was previsously before command was called\n    if was_relative:\n            self.relative()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.home","title":"<code>home()</code>","text":"<p>Move the tool head to the home position (X=0, Y=0).</p> Source code in <code>mecode/main.py</code> <pre><code>def home(self):\n    \"\"\" Move the tool head to the home position (X=0, Y=0).\n    \"\"\"\n    self.abs_move(x=0, y=0)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.line_crossing","title":"<code>line_crossing(dwell, feeds, length, com_port, pressure, travel_feed)</code>","text":"<p>Prints meanders of varying spacing with different pressures.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>The length to move in x in one half cycle</p> required Source code in <code>mecode/main.py</code> <pre><code>def line_crossing(self,dwell,feeds,length,com_port,pressure,travel_feed):\n    \"\"\" Prints meanders of varying spacing with different pressures.\n\n    Parameters\n    ----------\n    frequency : float\n        The length to move in x in one half cycle\n    \"\"\"\n    # Switch to relative if in absolute, but keep track of state\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    print_height = np.copy(self._current_position['z'])\n\n    self.set_pressure(com_port,pressure)\n    self.toggle_pressure(com_port)\n    self.dwell(dwell)\n    self.move(x=length)\n    self.dwell(dwell)\n    self.toggle_pressure(com_port)\n    self.move(z=-print_height)\n    self.feed(travel_feed)\n    self.move(z=print_height+5)\n\n    spacing = length/(len(feeds)+1)\n    self.move(x=-spacing,y=8)\n    for feed in feeds:\n        self.move(z=-(print_height+5))\n        self.feed(feed)\n        self.move(y=-16)\n        if feed != feeds[-1]:\n            self.feed(travel_feed)\n            self.move(z=print_height+5)\n            self.move(x=-spacing,y=16)\n\n    self.feed(travel_feed)\n    self.move(z=print_height+5)\n\n    # Switch back to absolute if it was in absolute\n    if was_absolute:\n        self.absolute()\n\n    return length\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.line_frequency","title":"<code>line_frequency(freq, padding, length, com_port, pressure, travel_feed)</code>","text":"<p>Prints a line with varying on/off frequency.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>The length to move in x in one half cycle</p> required Source code in <code>mecode/main.py</code> <pre><code>def line_frequency(self,freq,padding,length,com_port,pressure,travel_feed):\n    \"\"\" Prints a line with varying on/off frequency.\n\n    Parameters\n    ----------\n    frequency : float\n        The length to move in x in one half cycle\n    \"\"\"\n\n    # Switch to relative if in absolute, but keep track of state\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    # Use velocity on, required for switching like this\n    self.write(\"VELOCITY ON\")\n\n    print_height = np.copy(self._current_position['z'])\n    print_feed = np.copy(self.speed)\n\n    self.set_pressure(com_port,pressure)\n    for f in freq:\n        # freq is in hz, ie 1/s. Thus dist = (m/s)/(1/s) = m\n        dist = print_feed/f\n        switch_points = np.arange(length+dist,step=dist)\n        if len(switch_points)%2:\n            switch_points = switch_points[:-1]\n        for point in switch_points:\n            self.toggle_pressure(com_port)\n            self.move(x=dist)\n\n        #Move to push into substrate\n        self.move(z=-print_height)\n        self.feed(travel_feed)\n        self.move(z=print_height+5)\n\n        if f != freq[-1]:\n            self.move(x=-len(switch_points)*dist,y=padding)\n            self.move(z=-5)\n            self.feed(print_feed)\n\n    # Switch back to velocity off\n    self.write(\"VELOCITY OFF\")\n    # Switch back to absolute if it was in absolute\n    if was_absolute:\n        self.absolute()\n\n    return [length,padding*(len(freq)-1)]\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.line_span","title":"<code>line_span(padding, dwell, distances, com_port, pressure, travel_feed)</code>","text":"<p>Prints meanders of varying spacing with different pressures.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>The length to move in x in one half cycle</p> required Source code in <code>mecode/main.py</code> <pre><code>def line_span(self,padding,dwell,distances,com_port,pressure,travel_feed):\n    \"\"\" Prints meanders of varying spacing with different pressures.\n\n    Parameters\n    ----------\n    frequency : float\n        The length to move in x in one half cycle\n    \"\"\"\n    # Switch to relative if in absolute, but keep track of state\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    print_height = np.copy(self._current_position['z'])\n    print_feed = np.copy(self.speed)\n\n    for dist in distances:\n        self.toggle_pressure(com_port)\n        self.dwell(dwell)\n        self.feed(print_feed*dist/distances[0])\n        self.move(y=dist)\n        self.dwell(dwell)\n        self.toggle_pressure(com_port)\n\n        self.move(z=-print_height)\n        self.feed(travel_feed)\n        self.move(z=print_height+5)\n        if dist != distances[-1]:\n            self.move(x=padding,y=-dist)\n            self.move(z=-5)\n            self.feed(print_feed)\n\n    # Switch back to absolute if it was in absolute\n    if was_absolute:\n        self.absolute()\n\n    return [padding*(len(distances)-1),np.max(distances)]\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.line_width","title":"<code>line_width(padding, width, com_port, pressures, spacing, travel_feed)</code>","text":"<p>Prints meanders of varying spacing with different pressures.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>The length to move in x in one half cycle</p> required Source code in <code>mecode/main.py</code> <pre><code>def line_width(self,padding,width,com_port,pressures,spacing,travel_feed):\n    \"\"\" Prints meanders of varying spacing with different pressures.\n\n    Parameters\n    ----------\n    frequency : float\n        The length to move in x in one half cycle\n    \"\"\"\n    # Switch to relative if in absolute, but keep track of state\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    print_height = np.copy(self._current_position['z'])\n    print_feed = np.copy(self.speed)\n\n    for pressure in pressures:\n        direction = 1\n        self.set_pressure(com_port,pressure)\n        self.toggle_pressure(com_port)\n        for space in spacing:\n            #self.toggle_pressure(com_port)\n            self.move(y=direction*width)\n            self.move(space)\n            if space == spacing[-1]:\n                self.move(y=-direction*width)\n            #self.toggle_pressure(com_port)\n            direction *= -1\n        self.toggle_pressure(com_port)\n        self.feed(travel_feed)\n        self.move(z=5)\n        if pressure != pressures[-1]:\n            self.move(x=-np.sum(spacing),y=width+padding)\n            self.move(z=-5)\n            self.feed(print_feed)\n\n    # Switch back to absolute if it was in absolute\n    if was_absolute:\n        self.absolute()\n\n    return [np.sum(spacing)*2-spacing[-1],len(pressures)*width + (len(pressures)-1)*padding]\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.linear_actuator_off","title":"<code>linear_actuator_off(dispenser)</code>","text":"<p>Turn Aerotech (or similar) linear actuator OFF.</p> <p>Parameters:</p> Name Type Description Default <code>dispenser</code> <code>int or str</code> <p>The linear actuator number (int) or full custom name (str).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Turn linear actuator `PDISP2` off\n&gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser='PDISP2')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def linear_actuator_off(self, dispenser):\n    ''' Turn Aerotech (or similar) linear actuator OFF.\n\n    Parameters\n    ----------\n    dispenser : int or str\n        The linear actuator number (int) or full custom name (str).\n    Examples\n    --------\n    &gt;&gt;&gt; # Turn linear actuator `PDISP2` off\n    &gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser='PDISP2')\n    '''\n    if str(dispenser).isdigit():\n        self.write(f'FREERUN PDISP{dispenser:d} STOP')\n    else:\n        self.write(f'FREERUN {dispenser} STOP')\n\n    if dispenser not in self.extrusion_state.keys():\n        self.extrusion_state[dispenser] = {'printing': False, 'value': 0}\n    # if extruding source HAS been specified\n    else:\n        self.extrusion_state[dispenser] = {'printing': False, 'value': 0}\n\n    # legacy code\n\n    self.extruding = [dispenser, False]\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.linear_actuator_on","title":"<code>linear_actuator_on(speed, dispenser)</code>","text":"<p>Sets Aerotech (or similar) linear actuator speed and ON.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>The linear actuator speed value to set [in local units].</p> required <code>dispenser</code> <code>int or str</code> <p>The linear actuator number (int) or full custom name (str).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Set extrusion speed to 3 mm/s on dispenser 2\n&gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser=2)\n</code></pre> <pre><code>&gt;&gt;&gt; # Set custom dispenser name to `PDISP22`\n&gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser='PDISP22')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def linear_actuator_on(self, speed, dispenser):\n    ''' Sets Aerotech (or similar) linear actuator speed and ON.\n\n    Parameters\n    ----------\n    speed : float\n        The linear actuator speed value to set [in local units].\n    dispenser : int or str\n        The linear actuator number (int) or full custom name (str).\n    Examples\n    --------\n    &gt;&gt;&gt; # Set extrusion speed to 3 mm/s on dispenser 2\n    &gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser=2)\n\n    &gt;&gt;&gt; # Set custom dispenser name to `PDISP22`\n    &gt;&gt;&gt; g.linear_actuator_on(speed=3, dispenser='PDISP22')\n    '''\n\n    if str(dispenser).isdigit():\n        self.write(f'FREERUN PDISP{dispenser:d} {speed:.6f}')\n    else:\n        self.write(f'FREERUN {dispenser} {speed:.6f}')\n\n    if dispenser not in self.extrusion_state.keys():\n        self.extrusion_state[dispenser] = {'printing': True, 'value': f'{speed:.6f}'}\n    # if extruding source HAS been specified\n    else:\n        self.extrusion_state[dispenser] = {'printing': True, 'value': f'{speed:.6f}'}\n\n    # legacy code\n    self.extruding = [dispenser, True]\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.log_pile","title":"<code>log_pile(L, W, H, RW, D_N, print_speed, com_ports, P, print_height=None, lead_in=0, dwell=0, jog_speed=10, jog_height=5)</code>","text":"<p>A solution for a 90\u00b0 log pile lattice</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>float</code> <p>Length of log pile base</p> required <code>W</code> <code>float</code> <p>Width of log pile base</p> required <code>H</code> <code>float</code> <p>Height of log pile base</p> required <code>RW</code> <code>float</code> <p>Road width - spacing between filament centers</p> required <code>D_N</code> <code>float</code> <p>Nozzle diameter</p> required <code>print_speed</code> <code>float</code> <p>Printing speed</p> required <code>com_ports</code> <code>dict</code> <p>Dictionary of com_ports for pressure <code>P</code> and omnicure <code>UV</code>.</p> required <code>P</code> <code>float</code> <p>Printing pressure</p> required <code>print_height</code> <code>float</code> <p>Spacing between z-layers. If not provided, the default is 80% of <code>D_N</code> to provide better adhesion</p> <code>None</code> <p>Examples:</p> <p>Printing a 10 mm (L) x 15 mm (W) x 5 mm (H) log pile with a road width of 1.4 mm and nozzle size of 0.7 mm (700 um) extruding at 55 psi pressure via com_port 5</p> <pre><code>&gt;&gt;&gt; g.log_pile(10, 15, 1.4, 0.7, 1, {'P': 5}, 55)\n</code></pre> <p>Note</p> <p>Currently, this assumes you are using a pressure-based printing method (e.g., Nordson). In the next version, this will be changed so that any arbitrary extruding source can be used.</p> Source code in <code>mecode/main.py</code> <pre><code>def log_pile(self, L, W, H, RW, D_N, print_speed, com_ports, P, print_height=None, lead_in=0, dwell=0, jog_speed=10, jog_height=5):\n    \"\"\" A solution for a 90\u00b0 log pile lattice\n\n    Parameters\n    ----------\n    L : float\n        Length of log pile base\n    W : float\n        Width of log pile base\n    H : float\n        Height of log pile base\n    RW : float\n        Road width - spacing between filament centers\n    D_N : float\n        Nozzle diameter\n    print_speed : float\n        Printing speed\n    com_ports : dict\n        Dictionary of com_ports for pressure `P` and omnicure `UV`.\n    P : float\n        Printing pressure\n    print_height : float\n        Spacing between z-layers. If not provided, the default is 80% of `D_N` to provide better adhesion\n\n    Examples\n    --------\n\n    Printing a 10 mm (L) x 15 mm (W) x 5 mm (H) log pile with a road width of 1.4 mm and nozzle size of 0.7 mm (700 um) extruding at 55 psi pressure via com_port 5\n    &gt;&gt;&gt; g.log_pile(10, 15, 1.4, 0.7, 1, {'P': 5}, 55)\n\n    !!! note\n\n        Currently, this assumes you are using a pressure-based printing method (e.g., Nordson).\n        In the next version, this will be changed so that any arbitrary extruding source can be used.\n\n    \"\"\"\n    COLORS = {\n        'pre': (1,1,1),#(1,0,0,0),\n        'post': (1,1,1),#(1,0,0,0),\n        'even': (0,0,0, 1),\n        'odd': (0,0,0, 1),\n        'offset': (1,1,1,0)\n        # 'post': (25/255,138/255,72/255,0.3)\n        # 'even': (45/255, 36/255, 66/255, 1),\n        # 'odd': (248/255, 214/255, 65/255, 1)\n    }\n\n    dz =  D_N*0.8 if print_height is None else print_height # [mm] z-layer spacing\n\n    z_layers = int(H / dz)\n    n_lines_L = int(np.floor(W/RW + 1))\n    n_lines_W = int(np.floor(L/RW + 1))\n\n    offset_L = L - (n_lines_W-1)*RW\n    offset_W = W - (n_lines_L-1)*RW\n    extra_offset = 5 # mm\n\n    print(f'n_lines_L={n_lines_L:.1f} and offset_L={offset_L:.3f}')\n    print(f'n_lines_W={n_lines_W:.1f} and offset_W={offset_W:.3f}')\n    print(f'RW = {RW:.3f} = {RW/D_N:.3f}*d_N')\n    print(f'z_layers = {z_layers:.1f}')\n    print(f'rho = {2*D_N/ RW :.3f}')\n\n    '''HELPER FUNCTIONS'''\n\n    def initial_offset(start, orientation, offset):\n        # LL\n        if start == 'LL' and orientation == 'x':\n            self.move(y=+offset/2, color=COLORS['pre'])\n        elif start == 'LL' and orientation == 'y':\n            self.move(x=+offset/2, color=COLORS['pre'])\n\n        # UL\n        elif start == 'UL' and orientation == 'x':\n            self.move(y=-offset/2, color=COLORS['pre'])\n        elif start == 'UL' and orientation == 'y':\n            self.move(x=+offset/2, color=COLORS['pre'])\n\n        # UR\n        elif start == 'UR' and orientation == 'x':\n            self.move(y=-offset/2, color=COLORS['pre'])\n        elif start == 'UR' and orientation == 'y':\n            self.move(x=-offset/2, color=COLORS['pre'])\n\n        # LR\n        elif start == 'LR' and orientation == 'x':\n            self.move(y=+offset/2, color=COLORS['pre'])\n        elif start == 'LR' and orientation == 'y':\n            self.move(x=-offset/2, color=COLORS['pre'])\n\n    def post_offset(next_start, next_orientation, offset):\n        # LL\n        if next_start == 'LL' and next_orientation == 'x':\n            self.move(y=-extra_offset, color=COLORS['post'])\n            self.move(x=-offset/2, color=COLORS['offset'])\n            self.move(y=extra_offset, color=COLORS['post'])\n        elif next_start == 'LL' and next_orientation == 'y':\n            self.move(x=-extra_offset, color=COLORS['post'])\n            self.move(y=-offset/2, color=COLORS['offset'])\n            self.move(x=-extra_offset, color=COLORS['post'])\n\n        # UL\n        elif next_start == 'UL' and next_orientation == 'x':\n            self.move(y=extra_offset, color=COLORS['post'])\n            self.move(x=+offset/2, color=COLORS['offset'])\n            self.move(y=-extra_offset, color=COLORS['post'])\n        elif next_start == 'UL' and next_orientation == 'y':\n            self.move(x=-extra_offset, color=COLORS['post'])\n            self.move(y=+offset/2, color=COLORS['offset'])\n            self.move(x=extra_offset, color=COLORS['post'])\n\n        # UR\n        elif next_start == 'UR' and next_orientation == 'x':\n            self.move(y=extra_offset, color=COLORS['post'])\n            self.move(x=+offset/2, color=COLORS['offset'])\n            self.move(y=-extra_offset, color=COLORS['post'])\n        elif next_start == 'UR' and next_orientation == 'y':\n            self.move(x=extra_offset, color=COLORS['post'])\n            self.move(y=+offset/2, color=COLORS['offset'])\n            self.move(x=-extra_offset, color=COLORS['post'])\n\n        # LR\n        elif next_start == 'LR' and next_orientation == 'x':\n            self.move(y=-extra_offset, color=COLORS['post'])\n            self.move(x=+offset/2, color=COLORS['offset'])\n            self.move(y=extra_offset, color=COLORS['post'])\n        elif next_start == 'LR' and next_orientation == 'y':\n            self.move(x=extra_offset, color=COLORS['post'])\n            self.move(y=-offset/2, color=COLORS['offset'])\n            self.move(x=-extra_offset, color=COLORS['post'])\n\n        self.write('G92 X0 Y0')\n    self.write('; &gt;&gt;&gt; CHANGE PRINT SPEED IN THE FOLLOWING LINE ([=] mm/s) &lt;&lt;&lt;')\n    self.feed(print_speed)\n    self.write('; &gt;&gt;&gt; CAN CHANGE LEAD IN LENGTH HERE &lt;&lt;&lt;')\n    self.move(x=lead_in, color=(1,0,0,0.5)) # lead in\n\n    self.write('; &gt;&gt;&gt; CHANGE PRINT PRINT PRESSURE IN FOLLOWING LINE (0 -&gt; 100, res=0.1) &lt;&lt;&lt;')\n    self.set_pressure(com_ports['P'], P)\n\n    self.toggle_pressure(com_ports['P'])   # ON\n    self.write('; &gt;&gt;&gt; CHANGE INITIAL DWELL IN THE FOLLOWING LINE ([=] seconds) &lt;&lt;&lt;')\n    self.dwell(dwell)\n\n    n_lines_list = [n_lines_L, n_lines_W]\n\n    ''' START '''\n    orientations = ['x','y']\n    for j in range(z_layers):\n        color = COLORS['even'] if j%2==0 else COLORS['odd']\n        n_lines_local = n_lines_list[j%2]\n        offset_local = offset_W if j%2==0 else offset_L\n\n        # if both even-even or odd-odd\n        if n_lines_list[0]%2 == n_lines_list[1]%2:\n            if n_lines_local % 2 == 0: # if even\n                start_list = ['LL', 'UL', 'UR', 'LR']\n            else:\n                # orientations = ['x','y']\n                start_list = ['LL', 'UR']*2\n        # if even-odd\n        elif n_lines_list[0]%2 ==0 and n_lines_list[1]%2==1:\n            start_list = ['LL', 'UL', 'LR', 'UR']\n        # if odd-even\n        elif n_lines_list[0]%2 ==1 and n_lines_list[1]%2==0:\n            start_list = ['LL', 'UR', 'UL', 'LR']\n\n\n        self.write(f'; &gt;&gt;&gt;  START LAYER #{j+1} &lt;&lt;&lt;')\n        start = start_list[j%4]\n        orientation = orientations[j%2]\n\n        next_start = start_list[(j+1)%4]\n        next_orientation = orientations[(j+1)%2]\n\n        initial_offset(start, orientation, offset_local)\n\n        # print(start,orientation, ' --&gt; ', next_start, next_orientation)\n\n        if j%2==0: # runs first\n            # print(f'&gt; serpentine from {start} towards {orientation}')\n            self.serpentine(L, n_lines_local, RW, start, orientation, color=color)\n        else:\n            # print(f'&gt; serpentine from {start} towards {orientation}')\n            self.serpentine(W, n_lines_local, RW, start, orientation, color=color)\n\n        post_offset(next_start, next_orientation, offset_local)\n\n        self.move(z=+dz)\n        self.write(f'; &gt;&gt;&gt;  END LAYER #{j+1} &lt;&lt;&lt;')\n\n        ''' STOP '''\n\n        self.toggle_pressure(com_ports['P'])   # OFF\n\n        # move away from lattice\n        self.write('; MOVE AWAY FROM PRINT')\n        self.feed(jog_speed)\n        self.move(z=jog_height)\n        self.abs_move(0, 0)\n        self.move(z=-jog_height - z_layers*dz)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.meander","title":"<code>meander(x, y, spacing, start='LL', orientation='x', tail=False, minor_feed=None, color=(0, 0, 0, 0.5), mode='auto')</code>","text":"<p>Infill a rectangle with a square wave meandering pattern. If the relevant dimension is not a multiple of the spacing, the spacing will be tweaked to ensure the dimensions work out.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The width of the rectangle in the x dimension.</p> required <code>y</code> <code>float</code> <p>The height of the rectangle in the y dimension.</p> required <code>spacing</code> <code>float</code> <p>The space between parallel meander lines.</p> required <code>start</code> <code>str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')</code> <p>The start of the meander -  L/U = lower/upper, L/R = left/right This assumes an origin in the lower left.</p> <code>'LL'</code> <code>orientation</code> <code>str ('x' or 'y') (default: 'x')</code> <code>'x'</code> <code>tail</code> <code>Bool (default: False)</code> <p>Whether or not to terminate the meander in the minor axis</p> <code>False</code> <code>minor_feed</code> <code>float or None (default: None)</code> <p>Feed rate to use in the minor axis</p> <code>None</code> <code>color</code> <code>hex string or rgb(a) string</code> <p>Specifies a color to be added to color history for viewing.</p> <code>(0, 0, 0, 0.5)</code> <code>mode</code> <code>str (either 'auto' or 'manual')</code> <p>If set to auto (default value) will auto correct spacing to fit within x and y dimensions.</p> <code>'auto'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # meander through a 10x10 square with a spacing of 1mm starting in\n&gt;&gt;&gt; # the lower left.\n&gt;&gt;&gt; g.meander(10, 10, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; # 3x5 meander with a spacing of 1 and with parallel lines through y\n&gt;&gt;&gt; g.meander(3, 5, spacing=1, orientation='y')\n</code></pre> <pre><code>&gt;&gt;&gt; # 10x5 meander with a spacing of 2 starting in the upper right.\n&gt;&gt;&gt; g.meander(10, 5, 2, start='UR')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def meander(self, x, y, spacing, start='LL', orientation='x', tail=False,\n            minor_feed=None, color=(0,0,0,0.5), mode='auto'):\n    \"\"\" Infill a rectangle with a square wave meandering pattern. If the\n    relevant dimension is not a multiple of the spacing, the spacing will\n    be tweaked to ensure the dimensions work out.\n\n    Parameters\n    ----------\n    x : float\n        The width of the rectangle in the x dimension.\n    y : float\n        The height of the rectangle in the y dimension.\n    spacing : float\n        The space between parallel meander lines.\n    start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')\n        The start of the meander -  L/U = lower/upper, L/R = left/right\n        This assumes an origin in the lower left.\n    orientation : str ('x' or 'y') (default: 'x')\n    tail : Bool (default: False)\n        Whether or not to terminate the meander in the minor axis\n    minor_feed : float or None (default: None)\n        Feed rate to use in the minor axis\n    color : hex string or rgb(a) string\n        Specifies a color to be added to color history for viewing.\n    mode : str (either 'auto' or 'manual')\n        If set to auto (default value) will auto correct spacing to fit within x and y dimensions.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # meander through a 10x10 square with a spacing of 1mm starting in\n    &gt;&gt;&gt; # the lower left.\n    &gt;&gt;&gt; g.meander(10, 10, 1)\n\n    &gt;&gt;&gt; # 3x5 meander with a spacing of 1 and with parallel lines through y\n    &gt;&gt;&gt; g.meander(3, 5, spacing=1, orientation='y')\n\n    &gt;&gt;&gt; # 10x5 meander with a spacing of 2 starting in the upper right.\n    &gt;&gt;&gt; g.meander(10, 5, 2, start='UR')\n\n    \"\"\"\n    if start.upper() == 'UL':\n        x, y = x, -y\n    elif start.upper() == 'UR':\n        x, y = -x, -y\n    elif start.upper() == 'LR':\n        x, y = -x, y\n\n    # Major axis is the parallel lines, minor axis is the jog.\n    if orientation == 'x':\n        major, major_name = x, 'x'\n        minor, minor_name = y, 'y'\n    else:\n        major, major_name = y, 'y'\n        minor, minor_name = x, 'x'\n\n    if mode.lower() == 'auto':\n        actual_spacing = self._meander_spacing(minor, spacing)\n        if abs(actual_spacing) != spacing:\n            msg = ';WARNING! meander spacing updated from {} to {}'\n            self.write(msg.format(spacing, actual_spacing))\n            self.write(f\";\\t IF YOU INTENDED TO USE A SPACING OF {spacing:.4f} USE mode='manual'\")\n        spacing = actual_spacing\n    sign = 1\n\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    major_feed = self.speed\n    if not minor_feed:\n        minor_feed = self.speed\n\n    n_passes = int(self._meander_passes(minor, spacing))\n\n    for j in range(n_passes):\n        self.move(**{major_name: (sign * major), 'color': color})\n        if minor_feed != major_feed:\n            self.feed(minor_feed)\n        if (j &lt; n_passes-1):\n            self.move(**{minor_name: spacing, 'color': color})\n        if (j==n_passes-1) and ( tail==True ):\n            self.move(**{minor_name: spacing, 'color': color})\n\n        if minor_feed != major_feed:\n            self.feed(major_feed)\n        sign = -1 * sign\n\n    if was_absolute:\n        self.absolute()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.move","title":"<code>move(x=None, y=None, z=None, k=None, theta=None, rapid=False, color=DEFAULT_FILAMENT_COLOR, comment='', **kwargs)</code>","text":"<p>Move the tool head to the given position. This method operates in relative mode unless a manual call to absolute was given previously. If an absolute movement is desired, the abs_move method is recommended instead.</p> <p>points : floats     Must specify endpoint as kwargs, e.g. x=5, y=5 k : Vector (default: None)     If supplied, will rotate points (x,y,z) about the axis given by k in accordance with      the Rodrigues' formula: v'=vcos(\u03b8)+(k x v)sin(\u03b8)+k(k\u22c5v)(1 - cos(\u03b8)) theta : float (default: None)     Used together with k for Rodrigues' formula rapid : Bool (default: False)     Executes an uncoordinated move to the specified location. color : hex string or rgb(a) string     Specifies a color to be added to color history for viewing. comment : str (default: '')     Adds a comment to the end of the line.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # move the tool head 10 mm in x and 10 mm in y\n&gt;&gt;&gt; g.move(x=10, y=10)\n</code></pre> <pre><code>&gt;&gt;&gt; # the x, y, and z keywords may be omitted:\n&gt;&gt;&gt; g.move(10, 10, 10)\n</code></pre> <pre><code>&gt;&gt;&gt; # move the A axis up 20 mm\n&gt;&gt;&gt; g.move(A=20)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def move(self, x=None, y=None, z=None, k=None, theta=None, rapid=False, color=DEFAULT_FILAMENT_COLOR, comment='', **kwargs):\n    \"\"\" Move the tool head to the given position. This method operates in\n    relative mode unless a manual call to [absolute][mecode.main.G.absolute] was given previously.\n    If an absolute movement is desired, the [abs_move][mecode.main.G.abs_move] method is\n    recommended instead.\n\n    points : floats\n        Must specify endpoint as kwargs, e.g. x=5, y=5\n    k : Vector (default: None)\n        If supplied, will rotate points (x,y,z) about the axis given by k in accordance with \n        the Rodrigues' formula: v'=vcos(\u03b8)+(k x v)sin(\u03b8)+k(k\u22c5v)(1 - cos(\u03b8))\n    theta : float (default: None)\n        Used together with k for Rodrigues' formula\n    rapid : Bool (default: False)\n        Executes an uncoordinated move to the specified location.\n    color : hex string or rgb(a) string\n        Specifies a color to be added to color history for viewing.\n    comment : str (default: '')\n        Adds a comment to the end of the line.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # move the tool head 10 mm in x and 10 mm in y\n    &gt;&gt;&gt; g.move(x=10, y=10)\n\n    &gt;&gt;&gt; # the x, y, and z keywords may be omitted:\n    &gt;&gt;&gt; g.move(10, 10, 10)\n\n    &gt;&gt;&gt; # move the A axis up 20 mm\n    &gt;&gt;&gt; g.move(A=20)\n\n    \"\"\"\n\n    if self.speed == 0:\n        msg = 'WARNING! no print speed has been set. Will default to previously used print speed.'\n        self.write('; ' + msg)\n\n        warnings.warn('''\n                        &gt;&gt;&gt; No print speed has been specified\n                        e.g., to set print speed to 15 mm/s use:\n                        \\t\\t g.feed(15)\n\n                        If this is not the intended behavior please set a print speed. You can ignore this if your testing out features such as testing serial communication etc.\n                        ''')\n\n    if self.extrude is True and 'E' not in kwargs.keys():\n        if self.is_relative is not True:\n            x_move = self.current_position['x'] if x is None else x\n            y_move = self.current_position['y'] if y is None else y\n            x_distance = abs(x_move - self.current_position['x'])\n            y_distance = abs(y_move - self.current_position['y'])\n            current_extruder_position = self.current_position['E']\n        else:\n            x_distance = 0 if x is None else x\n            y_distance = 0 if y is None else y\n            current_extruder_position = 0\n        line_length = math.sqrt(x_distance**2 + y_distance**2)\n        area = self.layer_height*(self.extrusion_width-self.layer_height) + \\\n            3.14159*(self.layer_height/2)**2\n        volume = line_length*area\n        filament_length = ((4*volume)/(3.14149*self.filament_diameter**2))*self.extrusion_multiplier\n        kwargs['E'] = filament_length + current_extruder_position\n\n    if k is None:\n        self._update_current_position(x=x, y=y, z=z, color=color, **kwargs)\n    else:\n        if theta is None:\n            raise ValueError(f'Both k and theta need to be supplied but got k={k} and theta={theta}')\n        v = np.array([x, y, z])\n        k = k / np.linalg.norm(k)  # Ensure k is a unit vector\n        v_rot = (v * np.cos(theta) +\n                np.cross(k, v) * np.sin(theta) +\n                k * np.dot(k, v) * (1 - np.cos(theta)))\n\n        x,y,z = v_rot\n\n    self._update_print_time(x,y,z)\n    # new_state = self.history[-1].copy()\n    # new_state['COORDS'] = (x, y, z)\n    # new_state['CURRENT_POSITION'] = {'X': self._current_position['x'], 'Y': self._current_position['y'], 'Z': self._current_position['z']}\n    # self.history.append(new_state)\n    args = self._format_args(x, y, z, **kwargs)\n    cmd = 'G0 ' if rapid else 'G1 '\n    self.write(cmd + args + f'; {comment}')\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.move_inc","title":"<code>move_inc(disp=None, speed=None, axis=None, accel=None, decel=None)</code>","text":"<p>Typically used to move linear actuator incrementally. Operates in relative mode.</p> <p>disp : float     amount to displace <code>axis</code>. Negative values can be used for retraction speed : float     Speed to move <code>axis</code> at accel : float     If provided, will set the acceleration of <code>axis</code>     TODO: NOT CURRENTLY SUPPORTED decel : float     If provided, will set the deceleration of <code>axis</code>     TODO: NOT CURRENTLY SUPPORTED</p> Source code in <code>mecode/main.py</code> <pre><code>def move_inc(self, disp=None, speed=None, axis=None, accel=None, decel=None):\n    ''' Typically used to move linear actuator incrementally. Operates in\n    relative mode.\n\n    disp : float\n        amount to displace `axis`. Negative values can be used for retraction\n    speed : float\n        Speed to move `axis` at\n    accel : float\n        If provided, will set the acceleration of `axis`\n        TODO: NOT CURRENTLY SUPPORTED\n    decel : float\n        If provided, will set the deceleration of `axis`\n        TODO: NOT CURRENTLY SUPPORTED\n    '''\n    # self.extrude = True\n    # if accel is not None:\n\n    self.write(f'MOVEINC {axis} {disp:.6f} {speed:.6f}')\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.omni_intensity","title":"<code>omni_intensity(com_port, value, cal=False)</code>","text":"<p>Sets the intensity of the omnicure.</p> <p>Parameters:</p> Name Type Description Default <code>com_port</code> <code>int</code> <p>The com port to communicate over RS-232.</p> required <code>value</code> <code>float</code> <p>The intensity value to set.</p> required <code>cal</code> <code>bool</code> <p>Whether the omnicure is calibrated or not.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Set omnicure intensity on com 3 to 50%.\n&gt;&gt;&gt; g.omni_intensity(com_port=3, value=50)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def omni_intensity(self, com_port, value, cal=False):\n    \"\"\" Sets the intensity of the omnicure.\n\n    Parameters\n    ----------\n    com_port : int\n        The com port to communicate over RS-232.\n    value : float\n        The intensity value to set.\n    cal : bool\n        Whether the omnicure is calibrated or not.\n    Examples\n    --------\n    &gt;&gt;&gt; #Set omnicure intensity on com 3 to 50%.\n    &gt;&gt;&gt; g.omni_intensity(com_port=3, value=50)\n\n    \"\"\"\n\n    if cal:\n        command = 'SIR{:.2f}'.format(value)\n        data = self.calc_CRC8(command)\n        self.write('$strtask4=\"{}\"'.format(data))\n    else:\n        command = 'SIL{:.0f}'.format(value)\n        data = self.calc_CRC8(command)\n        self.write('$strtask4=\"{}\"'.format(data))\n    self.write('Call omniSetInt P{}'.format(com_port))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.omni_off","title":"<code>omni_off(com_port)</code>","text":"<p>Opposite to omni_on.</p> Source code in <code>mecode/main.py</code> <pre><code>def omni_off(self, com_port):\n    \"\"\" Opposite to omni_on.\n    \"\"\"\n    self.write('Call omniOff P{}'.format(com_port))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.omni_on","title":"<code>omni_on(com_port)</code>","text":"<p>Opens the iris for the omnicure.</p> <p>Parameters:</p> Name Type Description Default <code>com_port</code> <code>int</code> <p>The com port to communicate over RS-232</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Turn on omnicure on com 3.\n&gt;&gt;&gt; g.omni_on(3)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def omni_on(self, com_port):\n    \"\"\" Opens the iris for the omnicure.\n\n    Parameters\n    ----------\n    com_port : int\n        The com port to communicate over RS-232\n\n    Examples\n    --------\n    &gt;&gt;&gt; #Turn on omnicure on com 3.\n    &gt;&gt;&gt; g.omni_on(3)\n\n    \"\"\"\n    self.write('Call omniOn P{}'.format(com_port))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.park_toolhead","title":"<code>park_toolhead(z_mode=None)</code>","text":"<p>Park the toolhead if supported.</p> <p>Parameters:</p> Name Type Description Default <code>z_mode</code> <code>int</code> <p>0: Raise the nozzle to the Z-park height 1: Raise or lower the nozzle to the Z-park height 2: Raise the nozzle by the Z-park amount</p> <code>None</code> Source code in <code>mecode/main.py</code> <pre><code>def park_toolhead(self, z_mode = None):\n    \"\"\" Park the toolhead if supported.\n\n    Parameters\n    ----------\n    z_mode : int\n        0: Raise the nozzle to the Z-park height\n        1: Raise or lower the nozzle to the Z-park height\n        2: Raise the nozzle by the Z-park amount\n    \"\"\"\n    if z_mode is not None:\n        self.write(\"G27 P{}\".format(z_mode))\n    else:\n        self.write(\"G27\")\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.rapid","title":"<code>rapid(x=None, y=None, z=None, **kwargs)</code>","text":"<p>Executes an uncoordinated move to the specified location.</p> Source code in <code>mecode/main.py</code> <pre><code>def rapid(self, x=None, y=None, z=None, **kwargs):\n    \"\"\" Executes an uncoordinated move to the specified location.\n    \"\"\"\n    self.move(x, y, z, rapid=True, **kwargs)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.rect","title":"<code>rect(x, y, direction='CW', start='LL')</code>","text":"<p>Trace a rectangle with the given width and height.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The width of the rectangle in the x dimension.</p> required <code>y</code> <code>float</code> <p>The height of the rectangle in the y dimension.</p> required <code>direction</code> <code>str (either 'CW' or 'CCW') (default: 'CW')</code> <p>Which direction to complete the rectangle in.</p> <code>'CW'</code> <code>start</code> <code>str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')</code> <p>The start of the rectangle -  L/U = lower/upper, L/R = left/right This assumes an origin in the lower left.</p> <code>'LL'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # trace a 10x10 clockwise square, starting in the lower left corner\n&gt;&gt;&gt; g.rect(10, 10)\n</code></pre> <pre><code>&gt;&gt;&gt; # 1x5 counterclockwise rect starting in the upper right corner\n&gt;&gt;&gt; g.rect(1, 5, direction='CCW', start='UR')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def rect(self, x, y, direction='CW', start='LL'):\n    \"\"\" Trace a rectangle with the given width and height.\n\n    Parameters\n    ----------\n    x : float\n        The width of the rectangle in the x dimension.\n    y : float\n        The height of the rectangle in the y dimension.\n    direction : str (either 'CW' or 'CCW') (default: 'CW')\n        Which direction to complete the rectangle in.\n    start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')\n        The start of the rectangle -  L/U = lower/upper, L/R = left/right\n        This assumes an origin in the lower left.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # trace a 10x10 clockwise square, starting in the lower left corner\n    &gt;&gt;&gt; g.rect(10, 10)\n\n    &gt;&gt;&gt; # 1x5 counterclockwise rect starting in the upper right corner\n    &gt;&gt;&gt; g.rect(1, 5, direction='CCW', start='UR')\n\n    \"\"\"\n    if direction == 'CW':\n        if start.upper() == 'LL':\n            self.move(y=y)\n            self.move(x=x)\n            self.move(y=-y)\n            self.move(x=-x)\n        elif start.upper() == 'UL':\n            self.move(x=x)\n            self.move(y=-y)\n            self.move(x=-x)\n            self.move(y=y)\n        elif start.upper() == 'UR':\n            self.move(y=-y)\n            self.move(x=-x)\n            self.move(y=y)\n            self.move(x=x)\n        elif start.upper() == 'LR':\n            self.move(x=-x)\n            self.move(y=y)\n            self.move(x=x)\n            self.move(y=-y)\n    elif direction == 'CCW':\n        if start.upper() == 'LL':\n            self.move(x=x)\n            self.move(y=y)\n            self.move(x=-x)\n            self.move(y=-y)\n        elif start.upper() == 'UL':\n            self.move(y=-y)\n            self.move(x=x)\n            self.move(y=y)\n            self.move(x=-x)\n        elif start.upper() == 'UR':\n            self.move(x=-x)\n            self.move(y=-y)\n            self.move(x=x)\n            self.move(y=y)\n        elif start.upper() == 'LR':\n            self.move(y=y)\n            self.move(x=-x)\n            self.move(y=-y)\n            self.move(x=x)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.rect_spiral","title":"<code>rect_spiral(n_turns, spacing, start='center', origin=(0, 0), dwell=None, manual=False, **kwargs)</code>","text":"<p>Performs a square spiral.</p> <p>Parameters:</p> Name Type Description Default <code>n_turns</code> <code>int</code> <p>The number of spirals</p> required <code>spacing</code> <code>float or iterable</code> <p>The spacing between lines of the spiral. Spacing can be a tuple or list to specify (dx, dy) spacings.</p> required <code>start</code> <code>str (either 'center', 'edge')</code> <p>The location to start the spiral (default: 'center').</p> <code>'center'</code> <code>direction</code> <code>str (either 'CW', 'CCW') #TODO: not being used right now</code> <p>Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')</p> required <code>origin</code> <code>tuple</code> <p>Absolute coordinates of spiral center. Helpful when printing in absolute coordinates</p> <code>(0, 0)</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # TODO\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def rect_spiral(self, n_turns, spacing, start='center', origin=(0,0), dwell=None, manual=False, **kwargs):\n    \"\"\" Performs a square spiral.\n\n    Parameters\n    ----------\n    n_turns : int\n        The number of spirals\n    spacing : float or iterable\n        The spacing between lines of the spiral. Spacing can be a tuple or list to specify (dx, dy) spacings.\n    start : str (either 'center', 'edge')\n        The location to start the spiral (default: 'center').\n    direction : str (either 'CW', 'CCW') #TODO: not being used right now\n        Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')\n    origin : tuple\n        Absolute coordinates of spiral center. Helpful when printing in absolute coordinates\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; # TODO\n\n\n    \"\"\"\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    # d_F = spacing\n\n    if hasattr(spacing, '__iter__'):\n        dx = spacing[0]\n        dy = spacing[1]\n    else:\n        dx = dy = spacing\n\n    x_pts = [origin[0], dx]\n    y_pts = [origin[1], 0]\n\n    if hasattr(n_turns, '__iter__'):\n        turn_0 = n_turns[0]\n        turn_F = n_turns[1]\n    else:\n        turn_0 = 1\n        turn_F = n_turns\n\n    for j in range(1, turn_F + 1):\n        top_right = (dx*j, dy*j)\n        top_left = (-dx*j, dy*j)\n        bottom_left = (-dx*j, -dy*j)\n        bottom_right = (dx*j + dx, -dy*j)\n\n        x_pts.extend([top_right[0], top_left[0], bottom_left[0], bottom_right[0]])\n        y_pts.extend([top_right[1], top_left[1], bottom_left[1], bottom_right[1]])\n\n    x_pts = np.array(x_pts)\n    y_pts = np.array(y_pts)\n    # adjust last point to ensure spiral is a square\n    # TODO: if want adjustable spiral orientation / direction, will need to adjust this\n    x_pts[-1] -= dx\n\n    original_pts = (x_pts, y_pts)\n\n    if turn_0 &gt; 1:\n        x_pts = x_pts[4*(turn_0-1)::]\n        y_pts = y_pts[4*(turn_0-1)::]\n\n    if start == 'edge':\n        x_pts = x_pts[::-1]\n        y_pts = y_pts[::-1]\n\n    if self.is_relative:\n        x_pts = x_pts[1:] - x_pts[:-1]\n        y_pts = y_pts[1:] - y_pts[:-1]\n\n    if not manual:\n        for x_j, y_j in zip(x_pts, y_pts):\n            self.move(x_j, y_j, **kwargs)\n\n            if dwell is not None:\n                self.dwell(dwell)\n\n    if was_absolute:\n        self.absolute()\n\n    if manual:\n        return x_pts, y_pts, original_pts\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.relative","title":"<code>relative()</code>","text":"<p>Enter relative movement mode, in general this method should not be used, most methods handle it automatically.</p> Source code in <code>mecode/main.py</code> <pre><code>def relative(self):\n    \"\"\" Enter relative movement mode, in general this method should not be\n    used, most methods handle it automatically.\n\n    \"\"\"\n    if not self.is_relative:\n        self.write('G91')\n        self.is_relative = True\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.rename_axis","title":"<code>rename_axis(x=None, y=None, z=None)</code>","text":"<p>Replaces the x, y, or z axis with the given name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g.rename_axis(z='A')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def rename_axis(self, x=None, y=None, z=None):\n    \"\"\" Replaces the x, y, or z axis with the given name.\n\n    Examples\n    --------\n    &gt;&gt;&gt; g.rename_axis(z='A')\n\n    \"\"\"\n    if x is not None:\n        self.x_axis = x\n    elif y is not None:\n        self.y_axis = y\n    elif z is not None:\n        self.z_axis = z\n    else:\n        msg = 'Must specify new name for x, y, or z only'\n        raise RuntimeError(msg)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.reset_home","title":"<code>reset_home()</code>","text":"<p>Reset the position back to machine coordinates without moving.</p> Source code in <code>mecode/main.py</code> <pre><code>def reset_home(self):\n    \"\"\" Reset the position back to machine coordinates without moving.\n    \"\"\"\n    # FIXME This does not work with internal current_position\n    # FIXME You must call an abs_move after this to re-sync\n    # current_position\n    self.write('G92.1')\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.round_rect","title":"<code>round_rect(x, y, direction='CW', start='LL', radius=0, linearize=True)</code>","text":"<p>Trace a rectangle with the given width and height with rounded corners,     note that starting point is not actually in corner of rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The width of the rectangle in the x dimension.</p> required <code>y</code> <code>float</code> <p>The height of the rectangle in the y dimension.</p> required <code>direction</code> <code>str (either 'CW' or 'CCW') (default: 'CW')</code> <p>Which direction to complete the rectangle in.</p> <code>'CW'</code> <code>start</code> <code>str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')</code> <p>The start of the rectangle -  L/U = lower/upper, L/R = left/right This assumes an origin in the lower left.</p> <code>'LL'</code> <code>radius</code> <code>radius of the corners of the rectangle</code> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # trace a 10x10 clockwise square with radius of 3, starting in the lower left corner\n&gt;&gt;&gt; g.round_rect(10, 10, radius=3)\n</code></pre> <pre><code>&gt;&gt;&gt; # 1x5 counterclockwise rect with radius of 2 starting in the upper right corner\n&gt;&gt;&gt; g.round_rect(1, 5, direction='CCW', start='UR', radius=2)\n</code></pre> <pre><code>                        ______________\n                       /              \\\n                      /                \\\n</code></pre> starts here for 'UL' - &gt; &lt;- starts here for 'UR' starts here for 'LL' - &gt; &lt;- starts here for 'LR'                 / ________/ Source code in <code>mecode/main.py</code> <pre><code>def round_rect(self, x, y, direction='CW', start='LL', radius=0, linearize=True):\n    r\"\"\" Trace a rectangle with the given width and height with rounded corners,\n        note that starting point is not actually in corner of rectangle.\n\n    Parameters\n    ----------\n    x : float\n        The width of the rectangle in the x dimension.\n    y : float\n        The height of the rectangle in the y dimension.\n    direction : str (either 'CW' or 'CCW') (default: 'CW')\n        Which direction to complete the rectangle in.\n    start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')\n        The start of the rectangle -  L/U = lower/upper, L/R = left/right\n        This assumes an origin in the lower left.\n    radius : radius of the corners of the rectangle\n\n    Examples\n    --------\n    &gt;&gt;&gt; # trace a 10x10 clockwise square with radius of 3, starting in the lower left corner\n    &gt;&gt;&gt; g.round_rect(10, 10, radius=3)\n\n    &gt;&gt;&gt; # 1x5 counterclockwise rect with radius of 2 starting in the upper right corner\n    &gt;&gt;&gt; g.round_rect(1, 5, direction='CCW', start='UR', radius=2)\n\n                                ______________\n                               /              \\\n                              /                \\\n    starts here for 'UL' - &gt; |                  | &lt;- starts here for 'UR'\n                             |                  |\n    starts here for 'LL' - &gt; |                  | &lt;- starts here for 'LR'\n                              \\                /\n                               \\______________/\n\n    \"\"\"\n    if direction == 'CW':\n        if start.upper() == 'LL':\n            self.move(y=y-2*radius)\n            self.arc(x=radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(x=x-2*radius)\n            self.arc(x=radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(y=-(y-2*radius))\n            self.arc(x=-radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(x=-(x-2*radius))\n            self.arc(x=-radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n        elif start.upper() == 'UL':\n            self.arc(x=radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(x=x-2*radius)\n            self.arc(x=radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(y=-(y-2*radius))\n            self.arc(x=-radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(x=-(x-2*radius))\n            self.arc(x=-radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(y=y-2*radius)\n        elif start.upper() == 'UR':\n            self.move(y=-(y-2*radius))\n            self.arc(x=-radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(x=-(x-2*radius))\n            self.arc(x=-radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(y=y-2*radius)\n            self.arc(x=radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(x=x-2*radius)\n            self.arc(x=radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n        elif start.upper() == 'LR':\n            self.arc(x=-radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(x=-(x-2*radius))\n            self.arc(x=-radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(y=y-2*radius)\n            self.arc(x=radius,y=radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(x=x-2*radius)\n            self.arc(x=radius,y=-radius,direction='CW',radius=radius, linearize=linearize)\n            self.move(y=-(y-2*radius))\n    elif direction == 'CCW':\n        if start.upper() == 'LL':\n            self.arc(x=radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(x=x-2*radius)\n            self.arc(x=radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(y=y-2*radius)\n            self.arc(x=-radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(x=-(x-2*radius))\n            self.arc(x=-radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(y=-(y-2*radius))\n        elif start.upper() == 'UL':\n            self.move(y=-(y-2*radius))\n            self.arc(x=radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(x=x-2*radius)\n            self.arc(x=radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(y=y-2*radius)\n            self.arc(x=-radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(x=-(x-2*radius))\n            self.arc(x=-radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n        elif start.upper() == 'UR':\n            self.arc(x=-radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(x=-(x-2*radius))\n            self.arc(x=-radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(y=-(y-2*radius))\n            self.arc(x=radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(x=x-2*radius)\n            self.arc(x=radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(y=y-2*radius)\n        elif start.upper() == 'LR':\n            self.move(y=y-2*radius)\n            self.arc(x=-radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(x=-(x-2*radius))\n            self.arc(x=-radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(y=-(y-2*radius))\n            self.arc(x=radius,y=-radius,direction='CCW',radius=radius, linearize=linearize)\n            self.move(x=x-2*radius)\n            self.arc(x=radius,y=radius,direction='CCW',radius=radius, linearize=linearize)\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.run_pump","title":"<code>run_pump(com_port)</code>","text":"<p>Run pump with internally stored settings. Note: to run a pump, first call <code>set_rate</code> then call <code>run</code></p> Source code in <code>mecode/main.py</code> <pre><code>def run_pump(self, com_port):\n    '''Run pump with internally stored settings.\n        Note: to run a pump, first call `set_rate` then call `run`'''\n\n    extruder_id = f'HApump_com_port{com_port}'\n    if extruder_id not in self.extrusion_state.keys():\n        self.extrusion_state[extruder_id] = {'printing': True, 'value': 1}\n    # if extruding source HAS been specified\n    else:\n        self.extrusion_state[extruder_id] = {'printing': True, 'value': 1}\n\n    self.write(f'Call runPump P{com_port}')\n\n    self.extruding = [com_port, True, 1]\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.serpentine","title":"<code>serpentine(L, n_lines, spacing, start='LL', orientation='x', color=(0, 0, 0, 0.5))</code>","text":"<p>Generate a square wave meandering/serpentine pattern. Unlike meander,  will not tweak spacing dimension.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>float</code> <p>Major axis dimension.</p> required <code>n_lines</code> <code>int</code> <p>The number of lines to generate</p> required <code>spacing</code> <code>float</code> <p>The space between parallel serpentine paths.</p> required <code>start</code> <code>str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')</code> <p>The start of the meander -  L/U = lower/upper, L/R = left/right This assumes an origin in the lower left.</p> <code>'LL'</code> <code>orientation</code> <code>str ('x' or 'y') (default: 'x')</code> <code>'x'</code> <code>color</code> <code>hex string or rgb(a) string</code> <p>Specifies a color to be added to color history for viewing.</p> <code>(0, 0, 0, 0.5)</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # meander through a 10x10 square with a spacing of 1mm starting in\n&gt;&gt;&gt; # the lower left.\n&gt;&gt;&gt; g.meander(10, 10, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; # 3x5 meander with a spacing of 1 and with parallel lines through y\n&gt;&gt;&gt; g.meander(3, 5, spacing=1, orientation='y')\n</code></pre> <pre><code>&gt;&gt;&gt; # 10x5 meander with a spacing of 2 starting in the upper right.\n&gt;&gt;&gt; g.meander(10, 5, 2, start='UR')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def serpentine(self, L, n_lines, spacing, start='LL', orientation='x', color=(0,0,0,0.5)):\n    \"\"\" Generate a square wave meandering/serpentine pattern. Unlike [meander][mecode.main.G.meander],\n     will not tweak spacing dimension.\n\n    Parameters\n    ----------\n    L : float\n        Major axis dimension.\n    n_lines : int\n        The number of lines to generate\n    spacing : float\n        The space between parallel serpentine paths.\n    start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'LL')\n        The start of the meander -  L/U = lower/upper, L/R = left/right\n        This assumes an origin in the lower left.\n    orientation : str ('x' or 'y') (default: 'x')\n    color : hex string or rgb(a) string\n        Specifies a color to be added to color history for viewing.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # meander through a 10x10 square with a spacing of 1mm starting in\n    &gt;&gt;&gt; # the lower left.\n    &gt;&gt;&gt; g.meander(10, 10, 1)\n\n    &gt;&gt;&gt; # 3x5 meander with a spacing of 1 and with parallel lines through y\n    &gt;&gt;&gt; g.meander(3, 5, spacing=1, orientation='y')\n\n    &gt;&gt;&gt; # 10x5 meander with a spacing of 2 starting in the upper right.\n    &gt;&gt;&gt; g.meander(10, 5, 2, start='UR')\n\n    \"\"\"\n    if orientation.lower() == 'x':\n        major, major_name = L, 'x'\n        minor, minor_name = spacing, 'y'\n    else:\n        major, major_name = L, 'y'\n        minor, minor_name = spacing, 'x'\n\n    sign_minor = +1\n    sign_major = +1\n    if start.upper() == 'UL':\n        sign_major = +1 if orientation.lower()=='x' else -1\n        sign_minor = -1 if orientation.lower()=='x' else +1\n    elif start.upper() == 'UR':\n        sign_major = -1\n        sign_minor = -1\n    elif start.upper() == 'LR':\n        sign_major = -1 if orientation.lower()=='x' else +1\n        sign_minor = +1 if orientation.lower()=='x' else -1\n\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    for j in range(n_lines):\n        self.move(**{major_name: sign_major*major, 'color': color})\n\n        if j &lt; (n_lines-1):\n            self.move(**{minor_name: sign_minor*minor, 'color': color})\n\n        sign_major = -1*sign_major\n\n    if was_absolute:\n        self.absolute()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.set_alicat_pressure","title":"<code>set_alicat_pressure(com_port, value)</code>","text":"<p>Same as set_pressure method, but for Alicat controller.</p> Source code in <code>mecode/main.py</code> <pre><code>def set_alicat_pressure(self, com_port, value):\n    \"\"\" Same as [set_pressure][mecode.main.G.set_pressure] method, but for Alicat controller.\n    \"\"\"\n    extruder_id = f'alicat_com_port{com_port}'\n    if extruder_id not in self.extrusion_state.keys():\n        self.extrusion_state[extruder_id] = {'printing': True, 'value': f'{value:.6f}'}\n    # if extruding source HAS been specified\n    else:\n        self.extrusion_state[extruder_id] = {'printing': True, 'value': f'{value:.6f}'}\n\n    self.write('Call setAlicatPress P{} Q{}'.format(com_port, value))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.set_cal_file","title":"<code>set_cal_file(path)</code>","text":"<p>Dynamically applies the specified calibration file at runtime.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path specifying the aerotech calibration file.</p> required Source code in <code>mecode/main.py</code> <pre><code>def set_cal_file(self, path):\n    \"\"\" Dynamically applies the specified calibration file at runtime.\n\n    Parameters\n    ----------\n    path : str\n        The path specifying the aerotech calibration file.\n\n    \"\"\"\n    self.write(r'LOADCALFILE \"{}\", 2D_CAL'.format(path))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.set_home","title":"<code>set_home(x=None, y=None, z=None, **kwargs)</code>","text":"<p>Set the current position to the given position without moving.</p> <p>Examples:</p> <p>set the current position to X=0, Y=0</p> <pre><code>&gt;&gt;&gt; g.set_home(0, 0)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def set_home(self, x=None, y=None, z=None, **kwargs):\n    \"\"\" Set the current position to the given position without moving.\n\n    Examples\n    --------\n\n    set the current position to X=0, Y=0\n    &gt;&gt;&gt; g.set_home(0, 0)\n\n    \"\"\"\n    args = self._format_args(x, y, z, **kwargs)\n    self.write('G92 ' + args)\n\n    self._update_current_position(x=x, y=y, z=z, mode='absolute', **kwargs)\n\n\n    # Handle None values and default to zero if None\n    x = 0 if x is None else x\n    y = 0 if y is None else y\n    z = 0 if z is None else z\n\n    new_origin = (self.history[-1]['CURRENT_POSITION']['X'] + x,\n                  self.history[-1]['CURRENT_POSITION']['Y'] + y,\n                  self.history[-1]['CURRENT_POSITION']['Z'] + z)\n\n    self.history[-1]['ORIGIN'] = new_origin\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.set_pressure","title":"<code>set_pressure(com_port, value)</code>","text":"<p>Sets pressure on Nordson Ultimus V Pressure Controllers.</p> <p>Parameters:</p> Name Type Description Default <code>com_port</code> <code>int</code> <p>The com port to communicate over RS-232.</p> required <code>value</code> <code>float</code> <p>The pressure value to set.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Set pressure on com 3 to 50.\n&gt;&gt;&gt; g.set_pressure(com_port=3, value=50)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def set_pressure(self, com_port, value):\n    \"\"\" Sets pressure on Nordson Ultimus V Pressure Controllers.\n\n    Parameters\n    ----------\n    com_port : int\n        The com port to communicate over RS-232.\n    value : float\n        The pressure value to set.\n    Examples\n    --------\n    &gt;&gt;&gt; #Set pressure on com 3 to 50.\n    &gt;&gt;&gt; g.set_pressure(com_port=3, value=50)\n\n    \"\"\"\n\n    if com_port not in self.extrusion_state.keys():\n        self.extrusion_state[com_port] = {'printing': False, 'value': round(value, 1)}\n    else:\n        self.extrusion_state[com_port] = {\n            'printing': self.extrusion_state[com_port]['printing'],\n            'value':  round(value, 1)\n        }\n\n    # legacy code\n    if self.extruding[0] == com_port:\n        self.extruding = [com_port, self.extruding[1], value if self.extruding else 0]\n    else:\n        self.extruding = [com_port, self.extruding[1], value if self.extruding else 0]\n    self.write(f'Call setPress P{com_port} Q{value:.1f}')\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.set_vac","title":"<code>set_vac(com_port, value)</code>","text":"<p>Same as set_pressure method, but for vacuum.</p> Source code in <code>mecode/main.py</code> <pre><code>def set_vac(self, com_port, value):\n    \"\"\" Same as [set_pressure][mecode.main.G.set_pressure] method, but for vacuum.\n    \"\"\"\n    self.write('Call setVac P{} Q{}'.format(com_port, value))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.set_valve","title":"<code>set_valve(num, value)</code>","text":"<p>Sets a digital output state (typically for valve).</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The com port to communicate over RS-232.</p> required <code>value</code> <code>bool</code> <p>On or off (1 or 0).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Turn on valve 2\n&gt;&gt;&gt; g.set_valve(num=2, value=1)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def set_valve(self, num, value):\n    \"\"\" Sets a digital output state (typically for valve).\n\n    Parameters\n    ----------\n    num : int\n        The com port to communicate over RS-232.\n    value : bool\n        On or off (1 or 0).\n    Examples\n    --------\n    &gt;&gt;&gt; #Turn on valve 2\n    &gt;&gt;&gt; g.set_valve(num=2, value=1)\n\n    \"\"\"\n    self.write('$DO{}.0={}'.format(num, value))\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.setup","title":"<code>setup()</code>","text":"<p>Set the environment into a consistent state to start off. This method must be called before any other commands.</p> Source code in <code>mecode/main.py</code> <pre><code>def setup(self):\n    \"\"\" Set the environment into a consistent state to start off. This\n    method must be called before any other commands.\n\n    \"\"\"\n    self._write_header()\n    if self.is_relative:\n        self.write('G91')\n    else:\n        self.write('G90')\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.spiral","title":"<code>spiral(end_diameter, spacing, feedrate, start='center', direction='CW', step_angle=0.1, start_diameter=0, center_position=None)</code>","text":"<p>Performs an Archimedean spiral. Start by moving to the center of the spiral location then use the 'start' argument to specify a starting location (either center or edge).</p> <p>Parameters:</p> Name Type Description Default <code>end_diameter</code> <code>float</code> <p>The outer diameter of the spiral.</p> required <code>spacing</code> <code>float</code> <p>The spacing between lines of the spiral.</p> required <code>feedrate</code> <code>float</code> <p>Feedrate is the speed of the nozzle relative to the substrate</p> required <code>start</code> <code>str (either 'center', 'edge')</code> <p>The location to start the spiral (default: 'center').</p> <code>'center'</code> <code>direction</code> <code>str (either 'CW', 'CCW')</code> <p>Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')</p> <code>'CW'</code> <code>step_angle</code> <code>float</code> <p>Resolution of the spiral in radians, smaller is higher resolution (default: 0.1).</p> <code>0.1</code> <code>start_diameter</code> <code>float</code> <p>The inner diameter of the spiral (default: 0).</p> <code>0</code> <code>center_position</code> <code>list</code> <p>Position of the absolute center of the spiral, useful when starting a spiral at the edge of a completed spiral</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # start first spiral, outer diameter of 20, spacing of 1, feedrate of 8\n&gt;&gt;&gt; g.spiral(20,1,8)\n</code></pre> <pre><code>&gt;&gt;&gt; # move to second spiral location and do similar spiral but start at edge\n&gt;&gt;&gt; g.spiral(20,1,8,start='edge',center_position=[50,0])\n</code></pre> <pre><code>&gt;&gt;&gt; # move to third spiral location, this time starting at edge but printing CCW\n&gt;&gt;&gt; g.spiral(20,1,8,start='edge',direction='CCW',center_position=[50,50])\n</code></pre> <pre><code>&gt;&gt;&gt; # move to fourth spiral location, starting at center again but printing CCW\n&gt;&gt;&gt; g.spiral(20,1,8,direction='CCW',center_position=[0,50])\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def spiral(self, end_diameter, spacing, feedrate, start='center', direction='CW',\n            step_angle = 0.1, start_diameter = 0, center_position=None):\n    \"\"\" Performs an Archimedean spiral. Start by moving to the center of the spiral location\n    then use the 'start' argument to specify a starting location (either center or edge).\n\n    Parameters\n    ----------\n    end_diameter : float\n        The outer diameter of the spiral.\n    spacing : float\n        The spacing between lines of the spiral.\n    feedrate : float\n        Feedrate is the speed of the nozzle relative to the substrate\n    start : str (either 'center', 'edge')\n        The location to start the spiral (default: 'center').\n    direction : str (either 'CW', 'CCW')\n        Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')\n    step_angle : float\n        Resolution of the spiral in radians, smaller is higher resolution (default: 0.1).\n    start_diameter : float\n        The inner diameter of the spiral (default: 0).\n    center_position : list\n        Position of the absolute center of the spiral, useful when starting a spiral at the edge of a completed spiral\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; # start first spiral, outer diameter of 20, spacing of 1, feedrate of 8\n    &gt;&gt;&gt; g.spiral(20,1,8)\n\n    &gt;&gt;&gt; # move to second spiral location and do similar spiral but start at edge\n    &gt;&gt;&gt; g.spiral(20,1,8,start='edge',center_position=[50,0])\n\n    &gt;&gt;&gt; # move to third spiral location, this time starting at edge but printing CCW\n    &gt;&gt;&gt; g.spiral(20,1,8,start='edge',direction='CCW',center_position=[50,50])\n\n    &gt;&gt;&gt; # move to fourth spiral location, starting at center again but printing CCW\n    &gt;&gt;&gt; g.spiral(20,1,8,direction='CCW',center_position=[0,50])\n\n    \"\"\"\n    start_spiral_turns = (start_diameter/2.0)/spacing\n    end_spiral_turns = (end_diameter/2.0)/spacing\n\n    #Use current position as center position if none is specified\n    if center_position is None:\n        center_position = [self._current_position['x'],self._current_position['y']]\n\n    #Keep track of whether currently in relative or absolute mode\n    was_relative = True\n    if self.is_relative:\n        self.absolute()\n    else:\n        was_relative = False\n\n    # SEE: https://www.comsol.com/blogs/how-to-build-a-parameterized-archimedean-spiral-geometry/\n    b = spacing/(2*math.pi)\n    t = np.arange(start_spiral_turns*2*math.pi, end_spiral_turns*2*math.pi, step_angle)\n\n    #Add last final point to ensure correct outer diameter\n    t = np.append(t,end_spiral_turns*2*math.pi)\n    if start == 'center':\n        pass\n    elif start == 'edge':\n        t = t[::-1]\n    else:\n        raise Exception(\"Must either choose 'center' or 'edge' for starting position.\")\n\n    #Move to starting positon\n    if (direction == 'CW' and start == 'center') or (direction == 'CCW' and start == 'edge'):\n        x_move = -t[0]*b*math.cos(t[0])+center_position[0]\n    elif (direction == 'CCW' and start == 'center') or (direction == 'CW' and start == 'edge'):\n        x_move = t[0]*b*math.cos(t[0])+center_position[0]\n    else:\n        raise Exception(\"Must either choose 'CW' or 'CCW' for spiral direction.\")\n    y_move = t[0]*b*math.sin(t[0])+center_position[1]\n    self.move(x_move, y_move)\n\n    #Start writing moves\n    self.feed(feedrate)\n\n    for step in t[1:]:\n        if (direction == 'CW' and start == 'center') or (direction == 'CCW' and start == 'edge'):\n            x_move = -step*b*math.cos(step)+center_position[0]\n        elif (direction == 'CCW' and start == 'center') or (direction == 'CW' and start == 'edge'):\n            x_move = step*b*math.cos(step)+center_position[0]\n        else:\n            raise Exception(\"Must either choose 'CW' or 'CCW' for spiral direction.\")\n        y_move = step*b*math.sin(step)+center_position[1]\n        self.move(x_move, y_move)\n\n    #Set back to relative mode if it was previsously before command was called\n    if was_relative:\n            self.relative()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.square_spiral","title":"<code>square_spiral(n_turns, spacing, start='center', origin=(0, 0), dwell=None, manual=False, **kwargs)</code>","text":"<p>Performs a square spiral.</p> <p>Parameters:</p> Name Type Description Default <code>n_turns</code> <code>int</code> <p>The number of spirals</p> required <code>spacing</code> <code>float</code> <p>The spacing between lines of the spiral.</p> required <code>start</code> <code>str (either 'center', 'edge')</code> <p>The location to start the spiral (default: 'center').</p> <code>'center'</code> <code>direction</code> <code>str (either 'CW', 'CCW') #TODO: not being used right now</code> <p>Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')</p> required <code>origin</code> <code>tuple</code> <p>Absolute coordinates of spiral center. Helpful when printing in absolute coordinates</p> <code>(0, 0)</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # TODO\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def square_spiral(self, n_turns, spacing, start='center', origin=(0,0), dwell=None, manual=False, **kwargs):\n    \"\"\" Performs a square spiral.\n\n    Parameters\n    ----------\n    n_turns : int\n        The number of spirals\n    spacing : float\n        The spacing between lines of the spiral.\n    start : str (either 'center', 'edge')\n        The location to start the spiral (default: 'center').\n    direction : str (either 'CW', 'CCW') #TODO: not being used right now\n        Direction to print the spiral, either clockwise or counterclockwise. (default: 'CW')\n    origin : tuple\n        Absolute coordinates of spiral center. Helpful when printing in absolute coordinates\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; # TODO\n\n\n    \"\"\"\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    d_F = spacing\n\n    x_pts = [origin[0], d_F]\n    y_pts = [origin[1], 0]\n\n    if hasattr(n_turns, '__iter__'):\n        turn_0 = n_turns[0]\n        turn_F = n_turns[1]\n    else:\n        turn_0 = 1\n        turn_F = n_turns\n\n    for j in range(1, turn_F + 1):\n        top_right = (d_F*j, d_F*j)\n        top_left = (-d_F*j, d_F*j)\n        bottom_left = (-d_F*j, -d_F*j)\n        bottom_right = (d_F*j + d_F, -d_F*j)\n\n        x_pts.extend([top_right[0], top_left[0], bottom_left[0], bottom_right[0]])\n        y_pts.extend([top_right[1], top_left[1], bottom_left[1], bottom_right[1]])\n\n    x_pts = np.array(x_pts)\n    y_pts = np.array(y_pts)\n    # adjust last point to ensure spiral is a square\n    # TODO: if want adjustable spiral orientation / direction, will need to adjust this\n    x_pts[-1] -= d_F\n\n    original_pts = (x_pts, y_pts)\n\n    if turn_0 &gt; 1:\n        x_pts = x_pts[4*(turn_0-1)::]\n        y_pts = y_pts[4*(turn_0-1)::]\n\n    if start == 'edge':\n        x_pts = x_pts[::-1]\n        y_pts = y_pts[::-1]\n\n    if self.is_relative:\n        x_pts = x_pts[1:] - x_pts[:-1]\n        y_pts = y_pts[1:] - y_pts[:-1]\n\n    if not manual:\n        for x_j, y_j in zip(x_pts, y_pts):\n            self.move(x_j, y_j, **kwargs)\n\n            if dwell is not None:\n                self.dwell(dwell)\n\n    if was_absolute:\n        self.absolute()\n\n    if manual:\n        return x_pts, y_pts, original_pts\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.stop_pump","title":"<code>stop_pump(com_port)</code>","text":"<p>Stops the pump</p> Source code in <code>mecode/main.py</code> <pre><code>def stop_pump(self, com_port):\n    '''Stops the pump'''\n\n    extruder_id = f'HApump_com_port{com_port}'\n    if extruder_id not in self.extrusion_state.keys():\n        self.extrusion_state[extruder_id] = {'printing': False}#, 'value': 0}\n    # if extruding source HAS been specified\n    else:\n        self.extrusion_state[extruder_id] = {'printing': False}#, 'value': 0}\n\n    self.write(f'Call stopPump P{com_port}')\n\n    self.extruding = [com_port, False, 0]\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.teardown","title":"<code>teardown(wait=True)</code>","text":"<p>Close the outfile file after writing the footer if opened. This method must be called once after all commands.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>Bool (default: True)</code> <p>Only used if direct_write_model == 'serial'. If True, this method waits to return until all buffered lines have been acknowledged.</p> <code>True</code> Source code in <code>mecode/main.py</code> <pre><code>def teardown(self, wait=True):\n    \"\"\" Close the outfile file after writing the footer if opened. This\n    method must be called once after all commands.\n\n    Parameters\n    ----------\n    wait : Bool (default: True)\n        Only used if direct_write_model == 'serial'. If True, this method\n        waits to return until all buffered lines have been acknowledged.\n\n    \"\"\"\n    if self.out_fd is not None:\n        if self.aerotech_include is True:\n            with open(os.path.join(HERE, 'footer.txt')) as fd:\n                self._write_out(lines=fd.readlines())\n        if self.footer is not None:\n            with open(self.footer) as fd:\n                self._write_out(lines=fd.readlines())\n        self.out_fd.close()\n    if self._socket is not None:\n        self._socket.close()\n    if self._p is not None:\n        self._p.disconnect(wait)\n\n    # do not calculate print time during unittests\n    if 'unittest' not in sys.modules.keys():\n        self.calc_print_time()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.toggle_pressure","title":"<code>toggle_pressure(com_port)</code>","text":"<p>Toggles (On/Off) Nordson Ultimus V Pressure Controllers.</p> <p>Parameters:</p> Name Type Description Default <code>com_port</code> <code>int</code> <p>The com port to communicate over RS-232</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Turn on pressure on com 3\n&gt;&gt;&gt; g.toggle_pressure(3)\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def toggle_pressure(self, com_port):\n    \"\"\" Toggles (On/Off) Nordson Ultimus V Pressure Controllers.\n\n    Parameters\n    ----------\n    com_port : int\n        The com port to communicate over RS-232\n\n    Examples\n    --------\n    &gt;&gt;&gt; #Turn on pressure on com 3\n    &gt;&gt;&gt; g.toggle_pressure(3)\n\n    \"\"\"\n    self.write('Call togglePress P{}'.format(com_port))\n\n    if com_port not in self.extrusion_state.keys():\n        self.extrusion_state[com_port] = {'printing': True, 'value': 1}\n    # if extruding source HAS been specified\n    else:\n        self.extrusion_state[com_port]['printing'] = not self.extrusion_state[com_port]['printing']\n\n    # legacy code\n    if self.extruding[0] == com_port:\n        self.extruding = [com_port, not self.extruding[1], self.extruding[2] if not self.extruding[1] else 0]\n    else:\n        self.extruding = [com_port, True, self.extruding[2]]\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.triangular_wave","title":"<code>triangular_wave(x, y, cycles, start='UR', orientation='x')</code>","text":"<p>Perform a triangular wave.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The length to move in x in one half cycle</p> required <code>y</code> <code>float</code> <p>The length to move in y in one half cycle</p> required <code>start</code> <code>str (either 'LL', 'UL', 'LR', 'UR') (default: 'UR')</code> <p>The start of the zigzag direction. This assumes an origin in the lower left, and move toward upper right.</p> <code>'UR'</code> <code>orientation</code> <code>str ('x' or 'y') (default: 'x')</code> <code>'x'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # triangular wave for one cycle going 10 in x and 10 in y per half\n&gt;&gt;&gt; # cycle.\n&gt;&gt;&gt; # the lower left.\n&gt;&gt;&gt; g.zigzag(10, 10, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; # triangular wave 4 cycles, going 3 in x and 5 in y per half cycle,\n&gt;&gt;&gt; # oscillating along the y axis.\n&gt;&gt;&gt; g.zigzag(3, 5, 4, orientation='y')\n</code></pre> <pre><code>&gt;&gt;&gt; # triangular wave 2 cycles, going 10 in x and 5 in y per half cycle,\n&gt;&gt;&gt; # oscillating along the x axis making the first half cycle towards\n&gt;&gt;&gt; # the lower left corner of the movement area.\n&gt;&gt;&gt; g.zigzag(10, 5, 2, start='LL')\n</code></pre> Source code in <code>mecode/main.py</code> <pre><code>def triangular_wave(self, x, y, cycles, start='UR', orientation='x'):\n    \"\"\" Perform a triangular wave.\n\n    Parameters\n    ----------\n    x : float\n        The length to move in x in one half cycle\n    y : float\n        The length to move in y in one half cycle\n    start : str (either 'LL', 'UL', 'LR', 'UR') (default: 'UR')\n        The start of the zigzag direction.\n        This assumes an origin in the lower left, and move toward upper\n        right.\n    orientation : str ('x' or 'y') (default: 'x')\n\n    Examples\n    --------\n    &gt;&gt;&gt; # triangular wave for one cycle going 10 in x and 10 in y per half\n    &gt;&gt;&gt; # cycle.\n    &gt;&gt;&gt; # the lower left.\n    &gt;&gt;&gt; g.zigzag(10, 10, 1)\n\n    &gt;&gt;&gt; # triangular wave 4 cycles, going 3 in x and 5 in y per half cycle,\n    &gt;&gt;&gt; # oscillating along the y axis.\n    &gt;&gt;&gt; g.zigzag(3, 5, 4, orientation='y')\n\n    &gt;&gt;&gt; # triangular wave 2 cycles, going 10 in x and 5 in y per half cycle,\n    &gt;&gt;&gt; # oscillating along the x axis making the first half cycle towards\n    &gt;&gt;&gt; # the lower left corner of the movement area.\n    &gt;&gt;&gt; g.zigzag(10, 5, 2, start='LL')\n\n    \"\"\"\n    if start.upper() == 'UL':\n        x, y = -x, y\n    elif start.upper() == 'LL':\n        x, y = -x, -y\n    elif start.upper() == 'LR':\n        x, y = x, -y\n\n    # Major axis is the parallel lines, minor axis is the jog.\n    if orientation == 'x':\n        major, major_name = x, 'x'\n        minor, minor_name = y, 'y'\n    else:\n        major, major_name = y, 'y'\n        minor, minor_name = x, 'x'\n\n    sign = 1\n\n    was_absolute = True\n    if not self.is_relative:\n        self.relative()\n    else:\n        was_absolute = False\n\n    for _ in range(int(cycles*2)):\n        self.move(**{minor_name: (sign * minor), major_name: major})\n        sign = -1 * sign\n\n    if was_absolute:\n        self.absolute()\n</code></pre>"},{"location":"api-reference/mecode/#mecode.main.G.view","title":"<code>view(backend='matplotlib', outfile=None, hide_travel=False, color_on=True, nozzle_cam=False, fast_forward=3, framerate=60, nozzle_dims=[1.0, 20.0], substrate_dims=[0.0, 0.0, -1.0, 300, 1, 300], scene_dims=[720, 720], ax=None, **kwargs)</code>","text":"<p>View the generated Gcode.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str (default: '3d')</code> <p>The plotting backend to use. Must be one of {'2d', '3d', 'animated'}. For backward compatibility, backend could also be one of {'matplotlib', 'vpython'}</p> <code>'matplotlib'</code> <code>outfile</code> <code>str (default: 'None')</code> <p>When using the 'matplotlib' backend, an image of the output will be save to the location specified here.</p> <code>None</code> <code>color_on</code> <code>bool (default: 'True')</code> <p>If True, will display image with the color associated with the g.move command. This is helpful for multi-material printing or debugging.</p> <code>True</code> <code>nozzle_cam</code> <code>bool (default: 'False')</code> <p>When using the 'animated' or 'vpython' backend and nozzle_cam is set to True, the camera will remained centered on the tip of the nozzle during the animation.</p> <code>False</code> <code>fast_forward</code> <code>int (default: 1)</code> <p>When using the 'animated' or 'vpython' backend, the animation can be sped up by the factor specified in the fast_forward parameter.</p> <code>3</code> <code>nozzle_dims</code> <code>list (default: [1.0,20.0])</code> <p>When using the 'animated' or 'vpython' backend, the dimensions of the nozzle can be specified using a list in the format: [nozzle_diameter, nozzle_length].</p> <code>[1.0, 20.0]</code> <code>substrate_dims</code> <p>When using the 'animated' or 'vpython' backend, the dimensions of the planar substrate can be specified using a list in the format: [x, y, z, length, height, width].</p> <code>[0.0, 0.0, -1.0, 300, 1, 300]</code> <code>scene_dims</code> <p>When using the 'animated' or 'vpython' backened, the dimensions of the viewing window can be specified using a list in the format: [width, height]</p> <code>[720, 720]</code> <code>ax</code> <code>matplotlib axes object</code> <p>Useful for adding additional functionailities to plot when debugging.</p> <code>None</code> <code>cross_section</code> <code>str (default: 'xy')</code> <p>Determines what cross section / plane to display when When using the '2d' or '3d' backend.</p> required <code>shape</code> <code>str (default : 'filament')</code> <p>Determines what shape to display when using the '3d' or 'animated' backend. Helpful for visualizing non-filament based printing (e.g., droplet-based). Must be one of {'filament', 'droplet'}.</p> required Source code in <code>mecode/main.py</code> <pre><code>def view(self,\n            backend='matplotlib',\n            outfile=None,\n            hide_travel=False,\n            color_on=True,\n            nozzle_cam=False,\n            fast_forward = 3,\n            framerate = 60,\n            nozzle_dims=[1.0,20.0],\n            substrate_dims=[0.0,0.0,-1.0,300,1,300],\n            scene_dims = [720,720],\n            ax=None,\n            **kwargs):\n    \"\"\" View the generated Gcode.\n\n    Parameters\n    ----------\n    backend : str (default: '3d')\n        The plotting backend to use. Must be one of {'2d', '3d', 'animated'}. For backward compatibility, backend could also be one of {'matplotlib', 'vpython'}\n    outfile : str (default: 'None')\n        When using the 'matplotlib' backend,\n        an image of the output will be save to the location specified\n        here.\n    color_on : bool (default: 'True')\n        If True, will display image with the color associated with the g.move command. This is helpful for multi-material printing or debugging.\n    nozzle_cam : bool (default: 'False')\n        When using the 'animated' or 'vpython' backend and nozzle_cam is set to\n        True, the camera will remained centered on the tip of the\n        nozzle during the animation.\n    fast_forward : int (default: 1)\n        When using the 'animated' or 'vpython' backend, the animation can be\n        sped up by the factor specified in the fast_forward\n        parameter.\n    nozzle_dims : list (default: [1.0,20.0])\n        When using the 'animated' or 'vpython' backend, the dimensions of the\n        nozzle can be specified using a list in the format:\n        [nozzle_diameter, nozzle_length].\n    substrate_dims: list (default: [0.0,0.0,-0.5,100,1,100])\n        When using the 'animated' or 'vpython' backend, the dimensions of the\n        planar substrate can be specified using a list in the\n        format: [x, y, z, length, height, width].\n    scene_dims: list (default: [720,720])\n        When using the 'animated' or 'vpython' backened, the dimensions of the\n        viewing window can be specified using a list in the\n        format: [width, height]\n    ax : matplotlib axes object\n        Useful for adding additional functionailities to plot when debugging.\n    cross_section : str (default: 'xy')\n        Determines what cross section / plane to display when When using the '2d' or '3d' backend.\n    shape : str (default : 'filament')\n        Determines what shape to display when using the '3d' or 'animated' backend. Helpful for visualizing non-filament based printing (e.g., droplet-based).\n        Must be one of {'filament', 'droplet'}.\n\n\n    \"\"\"\n    from mecode_viewer import plot2d, plot3d, animation\n\n    if backend == '2d':\n       ax = plot2d(self.history, ax=ax, hide_travel=hide_travel, **kwargs)\n    elif backend == 'matplotlib' or backend == '3d':\n        ax = plot3d(self.history, ax=ax, hide_travel=hide_travel, **kwargs)\n    elif backend == 'mayavi':\n        # from mayavi import mlab\n        # mlab.plot3d(history[:, 0], history[:, 1], history[:, 2])\n        raise ValueError(f'The {backend} backend is not currently supported.')\n    elif backend == 'vpython' or backend == 'animated':\n        animation(self.history,\n                    outfile,\n                    hide_travel,\n                    color_on,\n                    nozzle_cam,\n                    fast_forward,\n                    framerate,\n                    nozzle_dims,\n                    substrate_dims,\n                    scene_dims,\n                    **kwargs)\n\n    else:\n        raise Exception(\"Invalid plotting backend! Choose one of {'2d', '3d', 'animated'}.\")\n</code></pre>"},{"location":"api-reference/printer/","title":"printer","text":""},{"location":"api-reference/printer/#mecode.printer.Printer","title":"<code>Printer</code>","text":"<p>               Bases: <code>object</code></p> <p>The Printer object is responsible for serial communications with a printer. The printer is expected to be running Marlin firmware.</p> Source code in <code>mecode/printer.py</code> <pre><code>class Printer(object):\n    \"\"\" The Printer object is responsible for serial communications with a\n    printer. The printer is expected to be running Marlin firmware.\n\n    \"\"\"\n\n    def __init__(self, port='/dev/tty.usbmodem1411', baudrate=250000):\n\n        # USB port and baudrate for communication with the printer.\n        self.port = port\n        self.baudrate = baudrate\n\n        # The Serial object that the printer is communicating on.\n        self.s = None\n\n        # List of the responses from the printer.\n        self.responses = []\n\n        # List of lines that were sent to the printer.\n        self.sentlines = []\n\n        # True if the print thread is alive and sending lines.\n        self.printing = False\n\n        # Set to True to pause the print.\n        self.paused = False\n\n        # If set to True, the read_thread will be closed as soon as possible.\n        self.stop_reading = False\n\n        # If set to True, the print_thread will be closed as soon as possible.\n        self.stop_printing = False\n\n        # List of all temperature string responses from the printer.\n        self.temp_readings = []\n\n        ### Private Attributes  ################################################\n\n        # List of all lines to be sent to the printer.\n        self._buffer = []\n\n        # Index into the _buffer of the next line to send to the printer.\n        self._current_line_idx = 0\n\n        # This thread continuously sends lines as they appear in self._buffer.\n        self._print_thread = None\n\n        # This thread continuously reads lines as they appear from the printer.\n        self._read_thread = None\n\n        # Flag used to synchronize the print_thread and the read_thread. An 'ok'\n        # needs to be returned for every line sent. When the print_thread sends\n        # a line this flag is cleared, and when an 'ok' is received it is set.\n        self._ok_received = Event()\n        self._ok_received.set()\n\n        # Lock used to ensure serial send/receive events are atomic with the\n        # setting/clearing of the `_ok_received` flag.\n        self._communication_lock = Lock()\n\n        # Lock used to ensure connecting and disconnecting is atomic.\n        self._connection_lock = Lock()\n\n        # If False the Printer instacnce does not own the serial object passed\n        # in and it should not be closed when finished with.\n        self._owns_serial = True\n\n        # This is set to true when a disconnect was requested. If a sendline is\n        # called while this is true an error is raised.\n        self._disconnect_pending = False\n\n        # When we reset the line number Marlin's internal number will differ\n        # from our own _current_line_idx. This offset is used to keep those two\n        # in sync.\n        self._reset_offset = 0\n\n    ###  Printer Interface  ###################################################\n\n    def connect(self, s=None):\n        \"\"\" Instantiate a Serial object using the stored port and baudrate.\n\n        Parameters\n        ----------\n        s : serial.Serial\n            If a serial object is passed in then it will be used instead of\n            creating a new one.\n\n        \"\"\"\n        with self._connection_lock:\n            if s is None:\n                self.s = serial.Serial(self.port, self.baudrate, timeout=3)\n            else:\n                self.s = s\n                self._owns_serial = False\n            self._ok_received.set()\n            self._current_line_idx = 0\n            self._buffer = []\n            self.responses = []\n            self.sentlines = []\n            self._disconnect_pending = False\n            self._start_read_thread()\n            if s is None:\n                start_time = time()\n                while len(self.responses) == 0 and time() &lt; start_time + 0.1:\n                    sleep(0.01)  # wait until a start message is recieved\n                self.responses = []\n        logger.debug('Connected to {}'.format(self.s))\n\n    def disconnect(self, wait=False):\n        \"\"\" Disconnect from the printer by stopping threads and closing the port\n\n        Parameters\n        ----------\n        wait : Bool (default: False)\n            If true, this method waits until all lines in the buffer have been\n            sent and acknowledged before disconnecting.  Clearing the buffer\n            isn't guaranteed.  If the read thread isn't running for some reason,\n            this function may return without waiting even when wait is set to\n            True.\n\n        \"\"\"\n        with self._connection_lock:\n            self._disconnect_pending = True\n            if wait:\n                buf_len = len(self._buffer)\n                while buf_len &gt; len(self.responses) and \\\n                      self._is_read_thread_running():\n                    sleep(0.01)  # wait until all lines in the buffer are sent\n            if self._print_thread is not None:\n                self.stop_printing = True\n                if self.s is not None and self.s.writeTimeout is not None:\n                    timeout = self.s.writeTimeout + 1\n                else:\n                    timeout = 10\n                self._print_thread.join(timeout)\n            if self._read_thread is not None:\n                self.stop_reading = True\n                if self.s is not None and self.s.timeout is not None:\n                    timeout = self.s.timeout + 1\n                else:\n                    timeout = 10\n                self._read_thread.join(timeout)\n            if self.s is not None and self._owns_serial is True:\n                self.s.close()\n                self.s = None\n            self.printing = False\n            self._current_line_idx = 0\n            self._buffer = []\n            self.responses = []\n            self.sentlines = []\n        self._disconnect_pending = False\n        logger.debug('Disconnected from printer')\n\n    def load_file(self, filepath):\n        \"\"\" Load the given file into an internal _buffer. The lines will not be\n        send until `self._start_print_thread()` is called.\n\n        Parameters\n        ----------\n        filepath : str\n            The path to a text file containing lines of GCode to be printed.\n\n        \"\"\"\n        lines = []\n        with open(filepath) as f:\n            for line in f:\n                line = line.strip()\n                if ';' in line:  # clear out the comments\n                    line = line.split(';')[0]\n                if line:\n                    lines.append(line)\n        self._buffer.extend(lines)\n\n    def start(self):\n        \"\"\" Starts the read_thread and the _print_thread.\n        \"\"\"\n        self._start_read_thread()\n        self._start_print_thread()\n        self.reset_linenumber(self._current_line_idx)\n\n    def sendline(self, line):\n        \"\"\" Send the given line over serial by appending it to the send buffer\n\n        Parameters\n        ----------\n        line : str\n            A line of GCode to send to the printer.\n\n        \"\"\"\n        if self._disconnect_pending:\n            msg = 'Attempted to send line after a disconnect was requested: {}'\n            raise RuntimeError(msg.format(line))\n        if line:\n            line = str(line).strip()\n            if ';' in line:  # clear out the comments\n                line = line.split(';')[0]\n            if line:\n                self._buffer.append(line)\n\n    def get_response(self, line, timeout=0):\n        \"\"\" Send the given line and return the response from the printer.\n\n        Parameters\n        ----------\n        line : str\n            The line to send to the printer\n\n        Returns\n        -------\n        r : str\n            The response from the printer.\n\n        \"\"\"\n        buf_len = len(self._buffer) + 1\n        self.sendline(line)\n        start_time = time()\n        while len(self.responses) != buf_len:\n            if len(self.responses) &gt; buf_len:\n                msg = \"Received more responses than lines sent\"\n                raise RuntimeError(msg)\n            if timeout &gt; 0 and (time() - start_time) &gt; timeout:\n                return ''  # return blank string on timeout.\n            if not self._is_read_thread_running():\n                raise RuntimeError(\"can't get response from serial since read thread isn't running\")\n            sleep(0.01)\n        return self.responses[-1]\n\n    def current_position(self):\n        \"\"\" Get the current postion of the printer.\n\n        Returns\n        -------\n        pos : dict\n            Dict with keys of 'X', 'Y', 'Z', and 'E' and values of their\n            positions\n\n        \"\"\"\n        # example r: X:0.00 Y:0.00 Z:0.00 E:0.00 Count X: 0.00 Y:0.00 Z:0.00\n        r = self.get_response(\"M114\")\n        r = r.split(' Count')[0].strip().split()\n        r = [x.split(':') for x in r]\n        pos = dict([(k, float(v)) for k, v in r])\n        return pos\n\n    def current_temperature(self):\n        \"\"\" Get the current temperature of the printer.\n\n        Returns\n        -------\n        temp : dict\n            Dict with keys of 'T', 'B', 'T/', 'B/', '@', and 'B@'\n            and values of their temperatures and powers.\n            T = extruder temperature, can also be T0, T1 ..\n            B = bed temperature\n            */ = target temperature\n            C = chamber temperature\n            @ = hotend power\n            B@ = bed power\n        \"\"\"\n        # example r: T:149.98 /150.00 B:60.00 /60.00 @:72 B@:30\n        r = self.get_response(\"M105\")\n        r = r.replace(' /', '/').strip().split()\n        temp = {}\n        for item in r:\n            if ':' in item:\n                name, val = item.split(':', 1)\n                if '/' in val:\n                    val1, val2 = val.split('/')\n                    temp[name] = float(val1)\n                    temp[name + '/'] = float(val2)\n                else:\n                    temp[name] = float(val)\n        return temp\n\n    def reset_linenumber(self, number = 0):\n        line = \"M110 N{}\".format(number)\n        self.sendline(line)\n\n    ###  Private Methods  ######################################################\n\n    def _start_print_thread(self):\n        \"\"\" Spawns a new thread that will send all lines in the _buffer over\n        serial to the printer. This thread can be stopped by setting\n        `stop_printing` to True. If a print_thread already exists and is alive,\n        this method does nothing.\n\n        \"\"\"\n        if self._is_print_thread_running():\n            return\n        self.printing = True\n        self.stop_printing = False\n        self._print_thread = Thread(target=self._print_worker_entrypoint, name='Print')\n        self._print_thread.daemon = True\n        self._print_thread.start()\n        logger.debug('print_thread started')\n\n    def _start_read_thread(self):\n        \"\"\" Spawns a new thread that will continuously read lines from the\n        printer. This thread can be stopped by setting `stop_reading` to True.\n        If a print_thread already exists and is alive, this method does\n        nothing.\n\n        \"\"\"\n        if self._is_read_thread_running():\n            return\n        self.stop_reading = False\n        self._read_thread = Thread(target=self._read_worker_entrypoint, name='Read')\n        self._read_thread.daemon = True\n        self._read_thread.start()\n        logger.debug('read_thread started')\n\n    def _print_worker_entrypoint(self):\n        try:\n            self._print_worker()\n        except Exception as e:\n            logger.exception(\"Exception running print worker: \" + str(e))\n\n    def _read_worker_entrypoint(self):\n        try:\n            self._read_worker()\n        except Exception as e:\n            logger.exception(\"Exception running read worker: \" + str(e))\n\n    def _is_print_thread_running(self):\n        return self._print_thread is not None and self._print_thread.is_alive()\n\n    def _is_read_thread_running(self):\n        return self._read_thread is not None and self._read_thread.is_alive()\n\n    def _print_worker(self):\n        \"\"\" This method is spawned in the print thread. It loops over every line\n        in the _buffer and sends it over seriwal to the printer.\n\n        \"\"\"\n        while not self.stop_printing:\n            _paused = False\n            while self.paused is True and not self.stop_printing:\n                if _paused is False:\n                    logger.debug('Printer.paused is True, waiting...')\n                    _paused = True\n                sleep(0.01)\n            if _paused is True:\n                logger.debug('Printer.paused is now False, resuming.')\n            if self._current_line_idx &lt; len(self._buffer):\n                self.printing = True\n                while not self._ok_received.is_set() and not self.stop_printing:\n                    self._ok_received.wait(1)\n                line = self._next_line()\n                with self._communication_lock:\n                    self.s.write(line.encode('utf-8'))\n                    self._ok_received.clear()\n                    self._current_line_idx += 1\n                # Grab the just sent line without line numbers or checksum\n                plain_line = self._buffer[self._current_line_idx - 1].strip()\n                self.sentlines.append(plain_line)\n            else:  # if there aren't new lines wait 10ms and check again\n                sleep(0.01)\n                self.printing = False\n\n    def _read_worker(self):\n        \"\"\" This method is spawned in the read thread. It continuously reads\n        from the printer over serial and checks for 'ok's.\n\n        \"\"\"\n        full_resp = ''\n        while not self.stop_reading:\n            if self.s is not None:\n                line = self.s.readline()\n                if line.startswith('Resend: '):  # example line: \"Resend: 143\"\n                    self._current_line_idx = int(line.split()[1]) - 1 + self._reset_offset\n                    logger.debug('Resend Requested - {}'.format(line.strip()))\n                    with self._communication_lock:\n                        self._ok_received.set()\n                    continue\n                if line.startswith('T:'):\n                    self.temp_readings.append(line)\n                if line:\n                    full_resp += line\n                    # If there is no newline char in the response that means\n                    # serial.readline() hit the timeout before a full line. This\n                    # means communication has broken down so both threads need\n                    # to be closed down.\n                    if '\\n' not in line:\n                        self.printing = False\n                        self.stop_printing = True\n                        self.stop_reading = True\n                        with self._communication_lock:\n                            self._ok_received.set()\n                        msg = \"\"\"readline timed out mid-line.\n                            last sentline:  {}\n                            response:       {}\n                        \"\"\"\n                        raise RuntimeError(msg.format(self.sentlines[-1:],\n                                                      full_resp))\n                if 'ok' in line:\n                    with self._communication_lock:\n                        self._ok_received.set()\n                    self.responses.append(full_resp)\n                    full_resp = ''\n                if 'start' in line:\n                    self.responses.append(line)\n                if line.startswith('echo:'):\n                    logger.info(line.rstrip()[len('echo:'):])\n            else:  # if no printer is attached, wait 10ms to check again.\n                sleep(0.01)\n\n    def _next_line(self):\n        \"\"\" Prepares the next line to be sent to the printer by prepending the\n        line number and appending a checksum and newline character.\n\n        \"\"\"\n        line = self._buffer[self._current_line_idx].strip()\n        if line.startswith('M110 N'):\n            new_number = int(line[6:])\n            self._reset_offset = self._current_line_idx + 1 - new_number\n        elif line.startswith('M110'):\n            self._reset_offset = self._current_line_idx + 1\n        idx = self._current_line_idx + 1 - self._reset_offset\n        line = 'N{} {}'.format(idx, line)\n        checksum = self._checksum(line)\n        return '{}*{}\\n'.format(line, checksum)\n\n    def _checksum(self, line):\n        \"\"\" Calclate the checksum by xor'ing all characters together.\n        \"\"\"\n        if not line:\n            raise RuntimeError(\"cannot compute checksum of an empty string\")\n        return reduce(lambda a, b: a ^ b, [ord(char) for char in line])\n</code></pre>"},{"location":"api-reference/printer/#mecode.printer.Printer.connect","title":"<code>connect(s=None)</code>","text":"<p>Instantiate a Serial object using the stored port and baudrate.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>Serial</code> <p>If a serial object is passed in then it will be used instead of creating a new one.</p> <code>None</code> Source code in <code>mecode/printer.py</code> <pre><code>def connect(self, s=None):\n    \"\"\" Instantiate a Serial object using the stored port and baudrate.\n\n    Parameters\n    ----------\n    s : serial.Serial\n        If a serial object is passed in then it will be used instead of\n        creating a new one.\n\n    \"\"\"\n    with self._connection_lock:\n        if s is None:\n            self.s = serial.Serial(self.port, self.baudrate, timeout=3)\n        else:\n            self.s = s\n            self._owns_serial = False\n        self._ok_received.set()\n        self._current_line_idx = 0\n        self._buffer = []\n        self.responses = []\n        self.sentlines = []\n        self._disconnect_pending = False\n        self._start_read_thread()\n        if s is None:\n            start_time = time()\n            while len(self.responses) == 0 and time() &lt; start_time + 0.1:\n                sleep(0.01)  # wait until a start message is recieved\n            self.responses = []\n    logger.debug('Connected to {}'.format(self.s))\n</code></pre>"},{"location":"api-reference/printer/#mecode.printer.Printer.current_position","title":"<code>current_position()</code>","text":"<p>Get the current postion of the printer.</p> <p>Returns:</p> Name Type Description <code>pos</code> <code>dict</code> <p>Dict with keys of 'X', 'Y', 'Z', and 'E' and values of their positions</p> Source code in <code>mecode/printer.py</code> <pre><code>def current_position(self):\n    \"\"\" Get the current postion of the printer.\n\n    Returns\n    -------\n    pos : dict\n        Dict with keys of 'X', 'Y', 'Z', and 'E' and values of their\n        positions\n\n    \"\"\"\n    # example r: X:0.00 Y:0.00 Z:0.00 E:0.00 Count X: 0.00 Y:0.00 Z:0.00\n    r = self.get_response(\"M114\")\n    r = r.split(' Count')[0].strip().split()\n    r = [x.split(':') for x in r]\n    pos = dict([(k, float(v)) for k, v in r])\n    return pos\n</code></pre>"},{"location":"api-reference/printer/#mecode.printer.Printer.current_temperature","title":"<code>current_temperature()</code>","text":"<p>Get the current temperature of the printer.</p> <p>Returns:</p> Name Type Description <code>temp</code> <code>dict</code> <p>Dict with keys of 'T', 'B', 'T/', 'B/', '@', and 'B@' and values of their temperatures and powers. T = extruder temperature, can also be T0, T1 .. B = bed temperature */ = target temperature C = chamber temperature @ = hotend power B@ = bed power</p> Source code in <code>mecode/printer.py</code> <pre><code>def current_temperature(self):\n    \"\"\" Get the current temperature of the printer.\n\n    Returns\n    -------\n    temp : dict\n        Dict with keys of 'T', 'B', 'T/', 'B/', '@', and 'B@'\n        and values of their temperatures and powers.\n        T = extruder temperature, can also be T0, T1 ..\n        B = bed temperature\n        */ = target temperature\n        C = chamber temperature\n        @ = hotend power\n        B@ = bed power\n    \"\"\"\n    # example r: T:149.98 /150.00 B:60.00 /60.00 @:72 B@:30\n    r = self.get_response(\"M105\")\n    r = r.replace(' /', '/').strip().split()\n    temp = {}\n    for item in r:\n        if ':' in item:\n            name, val = item.split(':', 1)\n            if '/' in val:\n                val1, val2 = val.split('/')\n                temp[name] = float(val1)\n                temp[name + '/'] = float(val2)\n            else:\n                temp[name] = float(val)\n    return temp\n</code></pre>"},{"location":"api-reference/printer/#mecode.printer.Printer.disconnect","title":"<code>disconnect(wait=False)</code>","text":"<p>Disconnect from the printer by stopping threads and closing the port</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>Bool (default: False)</code> <p>If true, this method waits until all lines in the buffer have been sent and acknowledged before disconnecting.  Clearing the buffer isn't guaranteed.  If the read thread isn't running for some reason, this function may return without waiting even when wait is set to True.</p> <code>False</code> Source code in <code>mecode/printer.py</code> <pre><code>def disconnect(self, wait=False):\n    \"\"\" Disconnect from the printer by stopping threads and closing the port\n\n    Parameters\n    ----------\n    wait : Bool (default: False)\n        If true, this method waits until all lines in the buffer have been\n        sent and acknowledged before disconnecting.  Clearing the buffer\n        isn't guaranteed.  If the read thread isn't running for some reason,\n        this function may return without waiting even when wait is set to\n        True.\n\n    \"\"\"\n    with self._connection_lock:\n        self._disconnect_pending = True\n        if wait:\n            buf_len = len(self._buffer)\n            while buf_len &gt; len(self.responses) and \\\n                  self._is_read_thread_running():\n                sleep(0.01)  # wait until all lines in the buffer are sent\n        if self._print_thread is not None:\n            self.stop_printing = True\n            if self.s is not None and self.s.writeTimeout is not None:\n                timeout = self.s.writeTimeout + 1\n            else:\n                timeout = 10\n            self._print_thread.join(timeout)\n        if self._read_thread is not None:\n            self.stop_reading = True\n            if self.s is not None and self.s.timeout is not None:\n                timeout = self.s.timeout + 1\n            else:\n                timeout = 10\n            self._read_thread.join(timeout)\n        if self.s is not None and self._owns_serial is True:\n            self.s.close()\n            self.s = None\n        self.printing = False\n        self._current_line_idx = 0\n        self._buffer = []\n        self.responses = []\n        self.sentlines = []\n    self._disconnect_pending = False\n    logger.debug('Disconnected from printer')\n</code></pre>"},{"location":"api-reference/printer/#mecode.printer.Printer.get_response","title":"<code>get_response(line, timeout=0)</code>","text":"<p>Send the given line and return the response from the printer.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The line to send to the printer</p> required <p>Returns:</p> Name Type Description <code>r</code> <code>str</code> <p>The response from the printer.</p> Source code in <code>mecode/printer.py</code> <pre><code>def get_response(self, line, timeout=0):\n    \"\"\" Send the given line and return the response from the printer.\n\n    Parameters\n    ----------\n    line : str\n        The line to send to the printer\n\n    Returns\n    -------\n    r : str\n        The response from the printer.\n\n    \"\"\"\n    buf_len = len(self._buffer) + 1\n    self.sendline(line)\n    start_time = time()\n    while len(self.responses) != buf_len:\n        if len(self.responses) &gt; buf_len:\n            msg = \"Received more responses than lines sent\"\n            raise RuntimeError(msg)\n        if timeout &gt; 0 and (time() - start_time) &gt; timeout:\n            return ''  # return blank string on timeout.\n        if not self._is_read_thread_running():\n            raise RuntimeError(\"can't get response from serial since read thread isn't running\")\n        sleep(0.01)\n    return self.responses[-1]\n</code></pre>"},{"location":"api-reference/printer/#mecode.printer.Printer.load_file","title":"<code>load_file(filepath)</code>","text":"<p>Load the given file into an internal _buffer. The lines will not be send until <code>self._start_print_thread()</code> is called.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to a text file containing lines of GCode to be printed.</p> required Source code in <code>mecode/printer.py</code> <pre><code>def load_file(self, filepath):\n    \"\"\" Load the given file into an internal _buffer. The lines will not be\n    send until `self._start_print_thread()` is called.\n\n    Parameters\n    ----------\n    filepath : str\n        The path to a text file containing lines of GCode to be printed.\n\n    \"\"\"\n    lines = []\n    with open(filepath) as f:\n        for line in f:\n            line = line.strip()\n            if ';' in line:  # clear out the comments\n                line = line.split(';')[0]\n            if line:\n                lines.append(line)\n    self._buffer.extend(lines)\n</code></pre>"},{"location":"api-reference/printer/#mecode.printer.Printer.sendline","title":"<code>sendline(line)</code>","text":"<p>Send the given line over serial by appending it to the send buffer</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>A line of GCode to send to the printer.</p> required Source code in <code>mecode/printer.py</code> <pre><code>def sendline(self, line):\n    \"\"\" Send the given line over serial by appending it to the send buffer\n\n    Parameters\n    ----------\n    line : str\n        A line of GCode to send to the printer.\n\n    \"\"\"\n    if self._disconnect_pending:\n        msg = 'Attempted to send line after a disconnect was requested: {}'\n        raise RuntimeError(msg.format(line))\n    if line:\n        line = str(line).strip()\n        if ';' in line:  # clear out the comments\n            line = line.split(';')[0]\n        if line:\n            self._buffer.append(line)\n</code></pre>"},{"location":"api-reference/printer/#mecode.printer.Printer.start","title":"<code>start()</code>","text":"<p>Starts the read_thread and the _print_thread.</p> Source code in <code>mecode/printer.py</code> <pre><code>def start(self):\n    \"\"\" Starts the read_thread and the _print_thread.\n    \"\"\"\n    self._start_read_thread()\n    self._start_print_thread()\n    self.reset_linenumber(self._current_line_idx)\n</code></pre>"},{"location":"api-reference/profilometer_parse/","title":"profilometer","text":""},{"location":"api-reference/profilometer_parse/#mecode.profilometer_parse.load_and_curate","title":"<code>load_and_curate(filename, reset_start=None)</code>","text":"<p>Load and process the data from the calibration filedump.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>path</code> <p>Path to the file containing the calibration dump</p> required <code>reset_start</code> <code>len 2 tuple or None</code> <p>If not None, shift calibration data to supplied starting point.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>cal_data</code> <code>Nx3 array</code> <p>The array containing calibration deltas.</p> Source code in <code>mecode/profilometer_parse.py</code> <pre><code>def load_and_curate(filename, reset_start=None):\n    \"\"\" Load and process the data from the calibration filedump.\n\n    Parameters\n    ----------\n    filename : path\n        Path to the file containing the calibration dump\n    reset_start : len 2 tuple or None\n        If not None, shift calibration data to supplied starting point.\n\n    Returns\n    -------\n    cal_data : Nx3 array\n        The array containing calibration deltas.\n\n    \"\"\"\n    all_data, points = load_from_file(filename)\n\n    cleaned = clean_values(all_data[points[0]])\n    cleaned_again = clean_values(cleaned, window=0.02)\n    reference_mean = np.mean(cleaned_again)\n\n    total_mean = np.array([np.mean(vals) for vals in all_data.values()]).mean()\n\n    for point, values in all_data.iteritems():\n        cleaned = clean_values(values, 0.3, total_mean)\n        cleaned_again = clean_values(cleaned, 0.05)\n        cleaned_again = clean_values(cleaned_again, 0.02)\n        all_data[point] = reference_mean - np.mean(cleaned_again)\n\n    values = np.array([all_data[pt] for pt in points])\n    points = np.array(points)\n    x = points[:, 0]\n    y = points[:, 1]\n    z = values\n\n    cal_data = np.array([x, y, z]).T\n    if reset_start is not None:\n        cal_data[:, :2] -= cal_data[0, :2]\n        cal_data[:, :2] += reset_start\n    return cal_data\n</code></pre>"},{"location":"tutorials/in-situ-uv-curing/","title":"UV Curing on-the-fly","text":"<p><code>g.omni_intensity()</code> can be used to set the intensity of a Omnicure S2000. <code>g.omni_on()</code> and <code>g.omni_off()</code> is then used to turn on and off the UV light, respectively.</p>"},{"location":"tutorials/in-situ-uv-curing/#example-uv-curing-on-the-fly","title":"Example: UV curing on-the-fly","text":"<pre><code>from mecode import G\n\ng = G()\n\ncom_ports = {\n    'uv': 1, # UV Omnicure COM PORT\n    'P': 5   # Pressure controller COM PORT\n}\n\n\n# define length of a single extruded filament\nL = 50 # mm\n\n# Print height\ndz = 1 # mm\n\n# set print speed in mm/s\ng.feed(10)\n\n# move nozzle to initial printing height\ng.move(z=dz)\n\n# Print path strategy\n#   1. turn on pressure supply to start printing\n#   2. turn on UV after a 5 second delay\n#   3. print a single filament of length `L`\n#   4. turn off pressure supply to stop printing\n#   5. turn of UV\n# turn pressure on (e.g., to start printing)\ng.toggle_pressure(com_port=com_ports['P']) # ON\ng.omni_intensity(com_port=com_ports['uv'], value=50)\ng.omni_on(com_port=com_ports['uv'])\ng.dwell(5)\n\ng.move(x=L)\n\ng.toggle_pressure(com_port=com_ports['P']) # OFF\ng.omni_off(com_port=com_ports['uv'])\n\n\n\ng.teardown()\n\ng.view('2d')\n</code></pre> Generated gcode <pre><code>Running mecode v0.2.38\n\nG1 F10\nG1 Z1.000000\nCall togglePress P5\n$strtask4=\"SIL504E\"\nCall omniSetInt P1\nCall omniOn P1\nG4 P5\nG1 X50.000000\nCall togglePress P5\nCall omniOff P1\n\nApproximate print time: \n        5.101 seconds \n        0.1 min \n        0.0 hrs\n</code></pre>"},{"location":"tutorials/matrix-transformations/","title":"Matrix Transformation","text":""},{"location":"tutorials/matrix-transformations/#matrix-transforms","title":"Matrix Transforms","text":"<p>A wrapper class, GMatrix will run all move and arc commands through a  2D transformation matrix before forwarding them to <code>G</code>.</p> <p>To use, simply instantiate a <code>GMatrix</code> object instead of a <code>G</code> object:</p> <pre><code># Replace this line \n#   from mecode import G\n# with this one\nfrom mecode import GMatrix\nimport numpy as np\n\ng = GMatrix()\n\n# set print speed\ng.feed(1)\n\ng.toggle_pressure(1)\n\n# save the current transformation matrix on the stack.\ng.push_matrix()\n\n# rotate our transformation matrix by 45 degrees.\ng.rotate(np.pi/4)\n\n# generate a serpentine path of length 25 mm, 5 lines, and 1 mm spacing\ng.serpentine(25, 5, 1, color=(1,0,0))\n\n# revert to the prior transformation matrix.\ng.pop_matrix()\n\ng.toggle_pressure(1)\n\ng.teardown()\n\ng.view('2d')\n</code></pre> <p>The transformation matrix is 2D instead of 3D to simplify arc support.</p> Generated gcode <pre><code>Running mecode v0.2.38\nG1 F1\nCall togglePress P1\nG1 X17.677670 Y17.677670\nG1 X-0.707107 Y0.707107\nG1 X-17.677670 Y-17.677670\nG1 X-0.707107 Y0.707107\nG1 X17.677670 Y17.677670\nG1 X-0.707107 Y0.707107\nG1 X-17.677670 Y-17.677670\nG1 X-0.707107 Y0.707107\nG1 X17.677670 Y17.677670\nCall togglePress P1\n\nApproximate print time: \n        129.000 seconds \n        2.1 min \n        0.0 hrs\n</code></pre>"},{"location":"tutorials/matrix-transformations/#result-before-rotating-by-45-degrees","title":"Result: before rotating by 45 degrees","text":""},{"location":"tutorials/matrix-transformations/#result-after-rotation-transformation","title":"Result: after rotation transformation","text":""},{"location":"tutorials/multilayer-prints/","title":"Multilayer Prints","text":""},{"location":"tutorials/multilayer-prints/#example-hollow-box","title":"Example: hollow box","text":"<pre><code>from mecode import G\n\ng = G()\n\n# define box side length\nL = 10 # mm\n\n# number of layers to print \nn_layers = 10\n\n# spacing between layers\ndz = 1\n\n# set print speed in mm/s\ng.feed(10)\n\n# move nozzle to initial printing height\ng.move(z=dz)\n\n# create a list of rgba colors to showcase `color` support in `view()`\ncolors = [(1,0,0,0.4), (0,1,0,0.4), (0,0,1,0.4),(0,0,0,0.5)]\n\n# turn pressure on (e.g., to start printing)\ng.toggle_pressure(com_port=5)\n\n# generate print path\nfor j in range(n_layers):\n    # move from (0,0) to (L,0)\n    g.move(x=L, color=colors[0])\n\n    # move from (L,0) to (L,L)\n    g.move(y=L, color=colors[1])\n\n    # move from (L,L) to (0,L)\n    g.move(x=-L, color=colors[2])\n\n    # move from (0,L) to (0,0)\n    g.move(y=-L, color=colors[3])\n\n    g.move(z=dz)\n\n# turn pressure off (e.g., to stop printing)\ng.toggle_pressure(com_port=5) \n\ng.teardown()\n\ng.view()\n</code></pre> Generated gcode <pre><code>Running mecode v0.2.38\n\nG1 F10\nG1 Z1.000000\nCall togglePress P5\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nG1 X10.000000\nG1 Y10.000000\nG1 X-10.000000\nG1 Y-10.000000\nG1 Z1.000000\nCall togglePress P5\n\nApproximate print time: \n        55.299 seconds \n        0.9 min \n        0.0 hrs\n</code></pre>"},{"location":"tutorials/multimaterial-printing/","title":"Multimaterial Printing","text":""},{"location":"tutorials/multimaterial-printing/#multimaterial-printing","title":"Multimaterial Printing","text":"<p>When working with a machine that has more than one Z-Axis, it is useful to use the <code>rename_axis()</code> function. Using this function your code can always refer to the vertical axis as 'Z' or whatever you provide as an argument. You can also dynamically rename the axis. For example, if you run <code>g.move(A=3)</code>-- this would correspond to a gcode command addressing the <code>A</code> axis: <code>G1 A3</code>. The latter approached is illustrated in the example below.</p>"},{"location":"tutorials/multimaterial-printing/#example-hollow-cylinder","title":"Example: Hollow Cylinder","text":"<p>The following is an example wherein a hollow cylinder is printed, where each layer is composed of a different material.</p> <pre><code>from mecode import G\n\ng = G()\n\n# COM1 = Pressure controller for material #1\n# COM5 = Pressure controller for material #2\ncom_ports = [1, 5]\ncolors = [(1,0,0,0.5), (0,1,0,0.5)]\naxis = ['Z', 'A']\n\n# offset distance b/w axis `Z` and `A`\noffset = 10 # mm\n\n# radius of cylinder\nR = 10 # mm\n\n# Print height\ndz = 1 # mm\n\n# number of layers\nn_layers = 20\n\n# set print speed in mm/s\ng.feed(10)\n\n# move nozzle to initial printing height\ng.move(z=dz)\n\n# move axis `Z` to starting position\ng.move(x=R)\n# g.set_home(x=0,y=0)\n\n# Print path strategy\n#   1. print first circle with material #1\n#   2. stop printing w/ material #1\n#   3. move material #2 axes to starting location\n#   4. start printing material #2\n#   ...repeat for n_layers\n# turn pressure on (e.g., to start printing)\n\ndef switching_strategy(j):\n    '''this function contains the logic for moving from one axis (nozzle 1) to another (nozzle 2)'''\n    # move active axis up and away\n    g.move(**{axis[j%2]: 50})\n\n    # move other axis to starting position\n    g.move(x=-offset if j%2==0 else +offset)\n    g.abs_move(**{axis[(j+1)%2]: (j+2)*dz})\n\nfor j in range(n_layers):\n    g.toggle_pressure(com_port=com_ports[j%2]) # ON\n    g.arc(x=-R, y=R, color=colors[j%2])\n    g.arc(x=R, y=-R, color=colors[j%2])\n    g.toggle_pressure(com_port=com_ports[j%2]) # OFF\n    g.move(z=dz)\n    switching_strategy(j)\n\ng.teardown()\n\ng.view('3d')\n</code></pre> Generated Gcode <pre><code>Running mecode v0.2.38\nG1 F10\nG1 Z1.000000\nG1 X10.000000\n; starting layer 0\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A2.000000\nG91\n; starting layer 1\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z3.000000\nG91\n; starting layer 2\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A4.000000\nG91\n; starting layer 3\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z5.000000\nG91\n; starting layer 4\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A6.000000\nG91\n; starting layer 5\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z7.000000\nG91\n; starting layer 6\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A8.000000\nG91\n; starting layer 7\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z9.000000\nG91\n; starting layer 8\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A10.000000\nG91\n; starting layer 9\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z11.000000\nG91\n; starting layer 10\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A12.000000\nG91\n; starting layer 11\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z13.000000\nG91\n; starting layer 12\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A14.000000\nG91\n; starting layer 13\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z15.000000\nG91\n; starting layer 14\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A16.000000\nG91\n; starting layer 15\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z17.000000\nG91\n; starting layer 16\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A18.000000\nG91\n; starting layer 17\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z19.000000\nG91\n; starting layer 18\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 Z50.000000\nG1 X-10.000000\nG90\nG1 A20.000000\nG91\n; starting layer 19\nCall togglePress P1\nG1 X-0.096074 Y0.975452\nG1 X-0.284529 Y0.937966\nG1 X-0.462050 Y0.864434\nG1 X-0.621814 Y0.757683\nG1 X-0.757683 Y0.621814\nG1 X-0.864434 Y0.462050\nG1 X-0.937966 Y0.284529\nG1 X-0.975452 Y0.096074\nG1 X-0.975452 Y-0.096074\nG1 X-0.937966 Y-0.284529\nG1 X-0.864434 Y-0.462050\nG1 X-0.757683 Y-0.621814\nG1 X-0.621814 Y-0.757683\nG1 X-0.462050 Y-0.864434\nG1 X-0.284529 Y-0.937966\nG1 X-0.096074 Y-0.975452\nG1 X0.096074 Y-0.975452\nG1 X0.284529 Y-0.937966\nG1 X0.462050 Y-0.864434\nG1 X0.621814 Y-0.757683\nG1 X0.757683 Y-0.621814\nG1 X0.864434 Y-0.462050\nG1 X0.937966 Y-0.284529\nG1 X0.975452 Y-0.096074\nG1 X0.975452 Y0.096074\nG1 X0.937966 Y0.284529\nG1 X0.864434 Y0.462050\nG1 X0.757683 Y0.621814\nG1 X0.621814 Y0.757683\nG1 X0.462050 Y0.864434\nG1 X0.284529 Y0.937966\nG1 X0.096074 Y0.975452\nCall togglePress P1\nG1 Z1.000000\nG1 A50.000000\nG1 X10.000000\nG90\nG1 Z21.000000\nG91\n\nApproximate print time: \n        775.411 seconds \n        12.9 min \n        0.2 hrs\n</code></pre>"},{"location":"tutorials/multimaterial-printing/#result-3d-plot","title":"Result: 3d plot","text":"<p>Bug</p> <p>Currently viewing multiaxis printing is not supported. Instead you will see each layer separated by the <code>offset</code> distance defined above. In practice, this gcode will generate a single cylinder.</p>"},{"location":"tutorials/serial-communication/","title":"Serial Communication","text":""},{"location":"tutorials/serial-communication/#direct-control-via-serial-communication","title":"Direct control via serial communication","text":"<p>With the option <code>direct_write=True</code>, a serial connection to the controlled device  is established via USB serial at a virtual COM port of the computer and the  g-code commands are sent directly to the connected device using a serial  communication protocol:</p> <pre><code>import mecode\n\ng = mecode.G(\n    direct_write=True, \n    direct_write_mode=\"serial\", \n    printer_port=\"/dev/tty.usbmodem1411\", \n    baudrate=115200\n)\n# Under MS Windows, use printer_port=\"COMx\" where x has to be replaced by the port number of the virtual COM port the device is connected to according to the device manager.\n\ng.write(\"M302 S0\")  # send g-Code. Here: allow cold extrusion. Danger: Make sure extruder is clean without filament inserted \n\ng.absolute()  # Absolute positioning mode\n\ng.move(x=10, y=10, z=10, F=500)  # move 10mm in x and 10mm in y and 10mm in z at a feedrate of 500 mm/min\n\ng.retract(10)  # Move extruder motor\n\ng.write(\"M400\")  # IMPORTANT! wait until execution of all commands is finished\n\ng.teardown()  # Disconnect (close serial connection)\n</code></pre>"},{"location":"tutorials/visualization/","title":"Advanced Visualization","text":""},{"location":"tutorials/visualization/#example-using-matplotlib-axes-to-extend-plotting-capabilities","title":"Example: using matplotlib axes to extend plotting capabilities","text":"<p>By passing an <code>axes</code> handle to <code>view()</code> you can take advantage of all plotting features from matplotlib.</p> <pre><code>from mecode import G\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\n\ng = G()\n\ng.feed(1)\n\ng.toggle_pressure(1)\ng.serpentine(25, 5, 1, color=(1,0,0))\ng.toggle_pressure(1)\n\ng.teardown()\n\nfig, ax = plt.subplots()\nax = g.view('2d', ax=ax)\nax.set_xlim(-5, 30)\nax.set_ylim(-2, 5)\nax.add_patch(Rectangle(\n    (0,0), 25, (5-1)*1, lw=5, ec='dodgerblue', fc='none',  alpha=0.3)\n    )\nplt.show()\n</code></pre> Generated Gcode <pre><code>Running mecode v0.2.38\nG1 F1\nCall togglePress P1\nG1 X25.000000\nG1 Y1.000000\nG1 X-25.000000\nG1 Y1.000000\nG1 X25.000000\nG1 Y1.000000\nG1 X-25.000000\nG1 Y1.000000\nG1 X25.000000\nCall togglePress P1\n\nApproximate print time: \n        177.637 seconds \n        3.0 min \n        0.0 hrs\n</code></pre>"},{"location":"tutorials/visualization/#result-example-using-matplotlib-patchesrectangle","title":"Result: example using matplotlib patches.Rectangle","text":""},{"location":"tutorials/visualization/#example-printing-droplets","title":"Example: printing droplets","text":"<pre><code>    from mecode import G\n    import numpy as np\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Rectangle\n\n    g = G()\n    g.feed(10)\n\n    for j in range(10):\n        g.toggle_pressure(5) # ON\n        g.move(x=+j/10, color=(1,0,0))\n        g.toggle_pressure(5) # OFF\n        g.move(x=2)\n\n    g.teardown()\n\n    g.view('3d', shape='droplet', radius=0.5)\n</code></pre> Generated Gcode <pre><code>G91\nG1 F10\nCall togglePress P5\nG1 X0.000000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.100000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.200000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.300000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.400000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.500000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.600000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.700000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.800000\nCall togglePress P5\nG1 X2.000000\nCall togglePress P5\nG1 X0.900000\nCall togglePress P5\nG1 X2.000000\n\n; Approximate print time:\n;       2.450 seconds\n;       0.0 min\n;       0.0 hrs\n</code></pre>"},{"location":"tutorials/visualization/#result","title":"Result","text":""}]}